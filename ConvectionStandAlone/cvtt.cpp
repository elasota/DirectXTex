/*
    Convection Texture Tools
    Copyright (c) 2018 Eric Lasota

    Permission is hereby granted, free of charge, to any person obtaining
    a copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to
    permit persons to whom the Software is furnished to do so, subject
    to the following conditions:

    The above copyright notice and this permission notice shall be included
    in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

    -------------------------------------------------------------------------------------

    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the MIT License.

    http://go.microsoft.com/fwlink/?LinkId=248926
*/
#include <stdint.h>
#include <assert.h>
#include <float.h>
#include <string.h>
#include <algorithm>

#if (defined(_M_IX86_FP) && _M_IX86_FP >= 2) || defined(_M_X64)
#include <emmintrin.h>
#endif

#include "cvtt.h"

#define UNREFERENCED_PARAMETER(n) ((void)n)

namespace CVTT
{
    namespace BC7Data
    {
        enum AlphaMode
        {
            AlphaMode_Combined,
            AlphaMode_Separate,
            AlphaMode_None,
        };

        enum PBitMode
        {
            PBitMode_PerEndpoint,
            PBitMode_PerSubset,
            PBitMode_None
        };

        struct BC7ModeInfo
        {
            PBitMode m_pBitMode;
            AlphaMode m_alphaMode;
            int m_rgbBits;
            int m_alphaBits;
            int m_partitionBits;
            int m_numSubsets;
            int m_indexBits;
            int m_alphaIndexBits;
            bool m_hasIndexSelector;
        };

        BC7ModeInfo g_modes[] =
        {
            { PBitMode_PerEndpoint, AlphaMode_None, 4, 0, 4, 3, 3, 0, false },     // 0
            { PBitMode_PerSubset, AlphaMode_None, 6, 0, 6, 2, 3, 0, false },       // 1
            { PBitMode_None, AlphaMode_None, 5, 0, 6, 3, 2, 0, false },            // 2
            { PBitMode_PerEndpoint, AlphaMode_None, 7, 0, 6, 2, 2, 0, false },     // 3 (Mode reference has an error, P-bit is really per-endpoint)

            { PBitMode_None, AlphaMode_Separate, 5, 6, 0, 1, 2, 3, true },         // 4
            { PBitMode_None, AlphaMode_Separate, 7, 8, 0, 1, 2, 2, false },        // 5
            { PBitMode_PerEndpoint, AlphaMode_Combined, 7, 7, 0, 1, 4, 0, false }, // 6
            { PBitMode_PerEndpoint, AlphaMode_Combined, 5, 5, 6, 2, 2, 0, false }  // 7
        };

        struct BC6HModeInfo
        {
            uint16_t m_modeID;
            bool m_partitioned;
            bool m_transformed;
            int m_aPrec;
            int m_bPrec[3];
        };

        // [partitioned][precision]
        bool g_hdrModesExistForPrecision[2][17] =
        {
            //0      1      2      3      4      5      6      7      8      9      10     11     12     13     14     15     16
            { false, false, false, false, false, false, false, false, false, false, true,  true,  true,  false, false, false, true },
            { false, false, false, false, false, false, true,  true,  true,  true,  true,  true,  false, false, false, false, false },
        };

        BC6HModeInfo g_hdrModes[] =
        {
            { 0x00, true,  true,  10, { 5, 5, 5 } },
            { 0x01, true,  true,  7,  { 6, 6, 6 } },
            { 0x02, true,  true,  11, { 5, 4, 4 } },
            { 0x06, true,  true,  11, { 4, 5, 4 } },
            { 0x0a, true,  true,  11, { 4, 4, 5 } },
            { 0x0e, true,  true,  9,  { 5, 5, 5 } },
            { 0x12, true,  true,  8,  { 6, 5, 5 } },
            { 0x16, true,  true,  8,  { 5, 6, 5 } },
            { 0x1a, true,  true,  8,  { 5, 5, 6 } },
            { 0x1e, true,  false, 6,  { 6, 6, 6 } },
            { 0x03, false, false, 10, { 10, 10, 10 } },
            { 0x07, false, true,  11, { 9, 9, 9 } },
            { 0x0b, false, true,  12, { 8, 8, 8 } },
            { 0x0f, false, true,  16, { 4, 4, 4 } },
        };

        const int g_maxHDRPrecision = 16;

        static const size_t g_numHDRModes = sizeof(g_hdrModes) / sizeof(g_hdrModes[0]);

        static uint16_t g_partitionMap[64] =
        {
            0xCCCC, 0x8888, 0xEEEE, 0xECC8,
            0xC880, 0xFEEC, 0xFEC8, 0xEC80,
            0xC800, 0xFFEC, 0xFE80, 0xE800,
            0xFFE8, 0xFF00, 0xFFF0, 0xF000,
            0xF710, 0x008E, 0x7100, 0x08CE,
            0x008C, 0x7310, 0x3100, 0x8CCE,
            0x088C, 0x3110, 0x6666, 0x366C,
            0x17E8, 0x0FF0, 0x718E, 0x399C,
            0xaaaa, 0xf0f0, 0x5a5a, 0x33cc,
            0x3c3c, 0x55aa, 0x9696, 0xa55a,
            0x73ce, 0x13c8, 0x324c, 0x3bdc,
            0x6996, 0xc33c, 0x9966, 0x660,
            0x272, 0x4e4, 0x4e40, 0x2720,
            0xc936, 0x936c, 0x39c6, 0x639c,
            0x9336, 0x9cc6, 0x817e, 0xe718,
            0xccf0, 0xfcc, 0x7744, 0xee22,
        };

        static uint32_t g_partitionMap2[64] =
        {
            0xaa685050, 0x6a5a5040, 0x5a5a4200, 0x5450a0a8,
            0xa5a50000, 0xa0a05050, 0x5555a0a0, 0x5a5a5050,
            0xaa550000, 0xaa555500, 0xaaaa5500, 0x90909090,
            0x94949494, 0xa4a4a4a4, 0xa9a59450, 0x2a0a4250,
            0xa5945040, 0x0a425054, 0xa5a5a500, 0x55a0a0a0,
            0xa8a85454, 0x6a6a4040, 0xa4a45000, 0x1a1a0500,
            0x0050a4a4, 0xaaa59090, 0x14696914, 0x69691400,
            0xa08585a0, 0xaa821414, 0x50a4a450, 0x6a5a0200,
            0xa9a58000, 0x5090a0a8, 0xa8a09050, 0x24242424,
            0x00aa5500, 0x24924924, 0x24499224, 0x50a50a50,
            0x500aa550, 0xaaaa4444, 0x66660000, 0xa5a0a5a0,
            0x50a050a0, 0x69286928, 0x44aaaa44, 0x66666600,
            0xaa444444, 0x54a854a8, 0x95809580, 0x96969600,
            0xa85454a8, 0x80959580, 0xaa141414, 0x96960000,
            0xaaaa1414, 0xa05050a0, 0xa0a5a5a0, 0x96000000,
            0x40804080, 0xa9a8a9a8, 0xaaaaaa44, 0x2a4a5254,
        };

        static int g_fixupIndexes2[64] =
        {
            15,15,15,15,
            15,15,15,15,
            15,15,15,15,
            15,15,15,15,
            15, 2, 8, 2,
            2, 8, 8,15,
            2, 8, 2, 2,
            8, 8, 2, 2,

            15,15, 6, 8,
            2, 8,15,15,
            2, 8, 2, 2,
            2,15,15, 6,
            6, 2, 6, 8,
            15,15, 2, 2,
            15,15,15,15,
            15, 2, 2,15,
        };

        static int g_fixupIndexes3[64][2] =
        {
            { 3,15 },{ 3, 8 },{ 15, 8 },{ 15, 3 },
            { 8,15 },{ 3,15 },{ 15, 3 },{ 15, 8 },
            { 8,15 },{ 8,15 },{ 6,15 },{ 6,15 },
            { 6,15 },{ 5,15 },{ 3,15 },{ 3, 8 },
            { 3,15 },{ 3, 8 },{ 8,15 },{ 15, 3 },
            { 3,15 },{ 3, 8 },{ 6,15 },{ 10, 8 },
            { 5, 3 },{ 8,15 },{ 8, 6 },{ 6,10 },
            { 8,15 },{ 5,15 },{ 15,10 },{ 15, 8 },

            { 8,15 },{ 15, 3 },{ 3,15 },{ 5,10 },
            { 6,10 },{ 10, 8 },{ 8, 9 },{ 15,10 },
            { 15, 6 },{ 3,15 },{ 15, 8 },{ 5,15 },
            { 15, 3 },{ 15, 6 },{ 15, 6 },{ 15, 8 },
            { 3,15 },{ 15, 3 },{ 5,15 },{ 5,15 },
            { 5,15 },{ 8,15 },{ 5,15 },{ 10,15 },
            { 5,15 },{ 10,15 },{ 8,15 },{ 13,15 },
            { 15, 3 },{ 12,15 },{ 3,15 },{ 3, 8 },
        };

        static const unsigned char g_fragments[] =
        {
            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,  // 0, 16
            0, 1, 2, 3,  // 16, 4
            0, 1, 4,  // 20, 3
            0, 1, 2, 4,  // 23, 4
            2, 3, 7,  // 27, 3
            1, 2, 3, 7,  // 30, 4
            0, 1, 2, 3, 4, 5, 6, 7,  // 34, 8
            0, 1, 4, 8,  // 42, 4
            0, 1, 2, 4, 5, 8,  // 46, 6
            0, 1, 2, 3, 4, 5, 6, 8,  // 52, 8
            1, 4, 5, 6, 9,  // 60, 5
            2, 5, 6, 7, 10,  // 65, 5
            5, 6, 9, 10,  // 70, 4
            2, 3, 7, 11,  // 74, 4
            1, 2, 3, 6, 7, 11,  // 78, 6
            0, 1, 2, 3, 5, 6, 7, 11,  // 84, 8
            0, 1, 2, 3, 8, 9, 10, 11,  // 92, 8
            2, 3, 6, 7, 8, 9, 10, 11,  // 100, 8
            4, 5, 6, 7, 8, 9, 10, 11,  // 108, 8
            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,  // 116, 12
            0, 4, 8, 12,  // 128, 4
            0, 2, 3, 4, 6, 7, 8, 12,  // 132, 8
            0, 1, 2, 4, 5, 8, 9, 12,  // 140, 8
            0, 1, 2, 3, 4, 5, 6, 8, 9, 12,  // 148, 10
            3, 6, 7, 8, 9, 12,  // 158, 6
            3, 5, 6, 7, 8, 9, 10, 12,  // 164, 8
            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12,  // 172, 12
            0, 1, 2, 5, 6, 7, 11, 12,  // 184, 8
            5, 8, 9, 10, 13,  // 192, 5
            8, 12, 13,  // 197, 3
            4, 8, 12, 13,  // 200, 4
            2, 3, 6, 9, 12, 13,  // 204, 6
            0, 1, 2, 3, 8, 9, 12, 13,  // 210, 8
            0, 1, 4, 5, 8, 9, 12, 13,  // 218, 8
            2, 3, 6, 7, 8, 9, 12, 13,  // 226, 8
            2, 3, 5, 6, 9, 10, 12, 13,  // 234, 8
            0, 3, 6, 7, 9, 10, 12, 13,  // 242, 8
            0, 1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 13,  // 250, 12
            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 13,  // 262, 13
            2, 3, 4, 7, 8, 11, 12, 13,  // 275, 8
            1, 2, 6, 7, 8, 11, 12, 13,  // 283, 8
            2, 3, 4, 6, 7, 8, 9, 11, 12, 13,  // 291, 10
            2, 3, 4, 5, 10, 11, 12, 13,  // 301, 8
            0, 1, 6, 7, 10, 11, 12, 13,  // 309, 8
            6, 9, 10, 11, 14,  // 317, 5
            0, 2, 4, 6, 8, 10, 12, 14,  // 322, 8
            1, 3, 5, 7, 8, 10, 12, 14,  // 330, 8
            1, 3, 4, 6, 9, 11, 12, 14,  // 338, 8
            0, 2, 5, 7, 9, 11, 12, 14,  // 346, 8
            0, 3, 4, 5, 8, 9, 13, 14,  // 354, 8
            2, 3, 4, 7, 8, 9, 13, 14,  // 362, 8
            1, 2, 5, 6, 9, 10, 13, 14,  // 370, 8
            0, 3, 4, 7, 9, 10, 13, 14,  // 378, 8
            0, 3, 5, 6, 8, 11, 13, 14,  // 386, 8
            1, 2, 4, 7, 8, 11, 13, 14,  // 394, 8
            0, 1, 4, 7, 10, 11, 13, 14,  // 402, 8
            0, 3, 6, 7, 10, 11, 13, 14,  // 410, 8
            8, 12, 13, 14,  // 418, 4
            1, 2, 3, 7, 8, 12, 13, 14,  // 422, 8
            4, 8, 9, 12, 13, 14,  // 430, 6
            0, 4, 5, 8, 9, 12, 13, 14,  // 436, 8
            1, 2, 3, 6, 7, 8, 9, 12, 13, 14,  // 444, 10
            2, 6, 8, 9, 10, 12, 13, 14,  // 454, 8
            0, 1, 2, 4, 5, 6, 8, 9, 10, 12, 13, 14,  // 462, 12
            0, 7, 9, 10, 11, 12, 13, 14,  // 474, 8
            1, 2, 3, 4, 5, 6, 8, 15,  // 482, 8
            3, 7, 11, 15,  // 490, 4
            0, 1, 3, 4, 5, 7, 11, 15,  // 494, 8
            0, 4, 5, 10, 11, 15,  // 502, 6
            1, 2, 3, 6, 7, 10, 11, 15,  // 508, 8
            0, 1, 2, 3, 5, 6, 7, 10, 11, 15,  // 516, 10
            0, 4, 5, 6, 9, 10, 11, 15,  // 526, 8
            0, 1, 2, 3, 4, 5, 6, 7, 9, 10, 11, 15,  // 534, 12
            1, 2, 4, 5, 8, 9, 12, 15,  // 546, 8
            2, 3, 5, 6, 8, 9, 12, 15,  // 554, 8
            0, 3, 5, 6, 9, 10, 12, 15,  // 562, 8
            1, 2, 4, 7, 9, 10, 12, 15,  // 570, 8
            1, 2, 5, 6, 8, 11, 12, 15,  // 578, 8
            0, 3, 4, 7, 8, 11, 12, 15,  // 586, 8
            0, 1, 5, 6, 10, 11, 12, 15,  // 594, 8
            1, 2, 6, 7, 10, 11, 12, 15,  // 602, 8
            1, 3, 4, 6, 8, 10, 13, 15,  // 610, 8
            0, 2, 5, 7, 8, 10, 13, 15,  // 618, 8
            0, 2, 4, 6, 9, 11, 13, 15,  // 626, 8
            1, 3, 5, 7, 9, 11, 13, 15,  // 634, 8
            0, 1, 2, 3, 4, 5, 7, 8, 12, 13, 15,  // 642, 11
            2, 3, 4, 5, 8, 9, 14, 15,  // 653, 8
            0, 1, 6, 7, 8, 9, 14, 15,  // 661, 8
            0, 1, 5, 10, 14, 15,  // 669, 6
            0, 3, 4, 5, 9, 10, 14, 15,  // 675, 8
            0, 1, 5, 6, 9, 10, 14, 15,  // 683, 8
            11, 14, 15,  // 691, 3
            7, 11, 14, 15,  // 694, 4
            1, 2, 4, 5, 8, 11, 14, 15,  // 698, 8
            0, 1, 4, 7, 8, 11, 14, 15,  // 706, 8
            0, 1, 4, 5, 10, 11, 14, 15,  // 714, 8
            2, 3, 6, 7, 10, 11, 14, 15,  // 722, 8
            4, 5, 6, 7, 10, 11, 14, 15,  // 730, 8
            0, 1, 4, 5, 7, 8, 10, 11, 14, 15,  // 738, 10
            0, 1, 2, 3, 5, 6, 7, 9, 10, 11, 14, 15,  // 748, 12
            0, 1, 2, 3, 4, 5, 6, 7, 9, 10, 11, 14, 15,  // 760, 13
            0, 1, 2, 3, 4, 6, 7, 11, 12, 14, 15,  // 773, 11
            3, 4, 8, 9, 10, 13, 14, 15,  // 784, 8
            11, 13, 14, 15,  // 792, 4
            0, 1, 2, 4, 11, 13, 14, 15,  // 796, 8
            0, 1, 2, 4, 5, 10, 11, 13, 14, 15,  // 804, 10
            7, 10, 11, 13, 14, 15,  // 814, 6
            3, 6, 7, 10, 11, 13, 14, 15,  // 820, 8
            1, 5, 9, 10, 11, 13, 14, 15,  // 828, 8
            1, 2, 3, 5, 6, 7, 9, 10, 11, 13, 14, 15,  // 836, 12
            12, 13, 14, 15,  // 848, 4
            0, 1, 2, 3, 12, 13, 14, 15,  // 852, 8
            0, 1, 4, 5, 12, 13, 14, 15,  // 860, 8
            4, 5, 6, 7, 12, 13, 14, 15,  // 868, 8
            4, 8, 9, 10, 12, 13, 14, 15,  // 876, 8
            0, 4, 5, 8, 9, 10, 12, 13, 14, 15,  // 884, 10
            0, 1, 4, 5, 6, 8, 9, 10, 12, 13, 14, 15,  // 894, 12
            0, 1, 2, 3, 4, 7, 8, 11, 12, 13, 14, 15,  // 906, 12
            0, 1, 3, 4, 8, 9, 11, 12, 13, 14, 15,  // 918, 11
            0, 2, 3, 7, 8, 10, 11, 12, 13, 14, 15,  // 929, 11
            7, 9, 10, 11, 12, 13, 14, 15,  // 940, 8
            3, 6, 7, 9, 10, 11, 12, 13, 14, 15,  // 948, 10
            2, 3, 5, 6, 7, 9, 10, 11, 12, 13, 14, 15,  // 958, 12
            8, 9, 10, 11, 12, 13, 14, 15,  // 970, 8
            0, 4, 5, 6, 8, 9, 10, 11, 12, 13, 14, 15,  // 978, 12
            0, 1, 4, 5, 6, 8, 9, 10, 11, 12, 13, 14, 15,  // 990, 13
            3, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,  // 1003, 12
            2, 3, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,  // 1015, 13
            4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,  // 1028, 12
            0, 2,  // 1040, 2
            1, 3,  // 1042, 2
            0, 1, 4, 5,  // 1044, 4
            0, 1, 2, 4, 5,  // 1048, 5
            2, 3, 6,  // 1053, 3
            0, 2, 4, 6,  // 1056, 4
            1, 2, 5, 6,  // 1060, 4
            0, 1, 2, 3, 5, 6,  // 1064, 6
            0, 1, 2, 4, 5, 6,  // 1070, 6
            0, 1, 2, 3, 4, 5, 6,  // 1076, 7
            0, 3, 4, 7,  // 1083, 4
            0, 1, 2, 3, 4, 7,  // 1087, 6
            1, 3, 5, 7,  // 1093, 4
            2, 3, 6, 7,  // 1097, 4
            1, 2, 3, 6, 7,  // 1101, 5
            1, 2, 3, 5, 6, 7,  // 1106, 6
            0, 1, 2, 3, 5, 6, 7,  // 1112, 7
            4, 5, 6, 7,  // 1119, 4
            0, 8,  // 1123, 2
            0, 1, 4, 5, 8,  // 1125, 5
            0, 1, 8, 9,  // 1130, 4
            4, 5, 8, 9,  // 1134, 4
            0, 1, 4, 5, 8, 9,  // 1138, 6
            2, 6, 8, 9,  // 1144, 4
            6, 7, 8, 9,  // 1148, 4
            0, 2, 4, 6, 8, 10,  // 1152, 6
            1, 2, 5, 6, 9, 10,  // 1158, 6
            0, 3, 4, 7, 9, 10,  // 1164, 6
            0, 1, 2, 8, 9, 10,  // 1170, 6
            4, 5, 6, 8, 9, 10,  // 1176, 6
            3, 11,  // 1182, 2
            2, 3, 6, 7, 11,  // 1184, 5
            0, 3, 8, 11,  // 1189, 4
            0, 3, 4, 7, 8, 11,  // 1193, 6
            1, 3, 5, 7, 9, 11,  // 1199, 6
            2, 3, 10, 11,  // 1205, 4
            1, 5, 10, 11,  // 1209, 4
            4, 5, 10, 11,  // 1213, 4
            6, 7, 10, 11,  // 1217, 4
            2, 3, 6, 7, 10, 11,  // 1221, 6
            1, 2, 3, 9, 10, 11,  // 1227, 6
            5, 6, 7, 9, 10, 11,  // 1233, 6
            8, 9, 10, 11,  // 1239, 4
            4, 12,  // 1243, 2
            0, 1, 2, 3, 4, 5, 8, 12,  // 1245, 8
            8, 9, 12,  // 1253, 3
            0, 4, 5, 8, 9, 12,  // 1256, 6
            0, 1, 4, 5, 8, 9, 12,  // 1262, 7
            2, 3, 5, 6, 8, 9, 12,  // 1269, 7
            1, 5, 9, 13,  // 1276, 4
            6, 7, 9, 13,  // 1280, 4
            1, 4, 7, 10, 13,  // 1284, 5
            1, 6, 8, 11, 13,  // 1289, 5
            0, 1, 12, 13,  // 1294, 4
            4, 5, 12, 13,  // 1298, 4
            0, 1, 6, 7, 12, 13,  // 1302, 6
            0, 1, 4, 8, 12, 13,  // 1308, 6
            8, 9, 12, 13,  // 1314, 4
            4, 8, 9, 12, 13,  // 1318, 5
            4, 5, 8, 9, 12, 13,  // 1323, 6
            0, 4, 5, 8, 9, 12, 13,  // 1329, 7
            0, 1, 6, 10, 12, 13,  // 1336, 6
            3, 6, 7, 9, 10, 12, 13,  // 1342, 7
            0, 1, 10, 11, 12, 13,  // 1349, 6
            2, 4, 7, 9, 14,  // 1355, 5
            4, 5, 10, 14,  // 1360, 4
            2, 6, 10, 14,  // 1364, 4
            2, 5, 8, 11, 14,  // 1368, 5
            0, 2, 12, 14,  // 1373, 4
            8, 10, 12, 14,  // 1377, 4
            4, 6, 8, 10, 12, 14,  // 1381, 6
            13, 14,  // 1387, 2
            9, 10, 13, 14,  // 1389, 4
            5, 6, 9, 10, 13, 14,  // 1393, 6
            0, 1, 2, 12, 13, 14,  // 1399, 6
            4, 5, 6, 12, 13, 14,  // 1405, 6
            8, 9, 12, 13, 14,  // 1411, 5
            8, 9, 10, 12, 13, 14,  // 1416, 6
            7, 15,  // 1422, 2
            0, 5, 10, 15,  // 1424, 4
            0, 1, 2, 3, 6, 7, 11, 15,  // 1428, 8
            10, 11, 15,  // 1436, 3
            0, 1, 5, 6, 10, 11, 15,  // 1439, 7
            3, 6, 7, 10, 11, 15,  // 1446, 6
            12, 15,  // 1452, 2
            0, 3, 12, 15,  // 1454, 4
            4, 7, 12, 15,  // 1458, 4
            0, 3, 6, 9, 12, 15,  // 1462, 6
            0, 3, 5, 10, 12, 15,  // 1468, 6
            8, 11, 12, 15,  // 1474, 4
            5, 6, 8, 11, 12, 15,  // 1478, 6
            4, 7, 8, 11, 12, 15,  // 1484, 6
            1, 3, 13, 15,  // 1490, 4
            9, 11, 13, 15,  // 1494, 4
            5, 7, 9, 11, 13, 15,  // 1498, 6
            2, 3, 14, 15,  // 1504, 4
            2, 3, 4, 5, 14, 15,  // 1508, 6
            6, 7, 14, 15,  // 1514, 4
            2, 3, 5, 9, 14, 15,  // 1518, 6
            2, 3, 8, 9, 14, 15,  // 1524, 6
            10, 14, 15,  // 1530, 3
            0, 4, 5, 9, 10, 14, 15,  // 1533, 7
            2, 3, 7, 11, 14, 15,  // 1540, 6
            10, 11, 14, 15,  // 1546, 4
            7, 10, 11, 14, 15,  // 1550, 5
            6, 7, 10, 11, 14, 15,  // 1555, 6
            1, 2, 3, 13, 14, 15,  // 1561, 6
            5, 6, 7, 13, 14, 15,  // 1567, 6
            10, 11, 13, 14, 15,  // 1573, 5
            9, 10, 11, 13, 14, 15,  // 1578, 6
            0, 4, 8, 9, 12, 13, 14, 15,  // 1584, 8
            9, 10, 12, 13, 14, 15,  // 1592, 6
            8, 11, 12, 13, 14, 15,  // 1598, 6
            3, 7, 10, 11, 12, 13, 14, 15,  // 1604, 8
        };
        static const int g_shapeRanges[][2] =
        {
            { 0, 16 },{ 16, 4 },{ 20, 3 },{ 23, 4 },{ 27, 3 },{ 30, 4 },{ 34, 8 },{ 42, 4 },{ 46, 6 },{ 52, 8 },{ 60, 5 },
            { 65, 5 },{ 70, 4 },{ 74, 4 },{ 78, 6 },{ 84, 8 },{ 92, 8 },{ 100, 8 },{ 108, 8 },{ 116, 12 },{ 128, 4 },{ 132, 8 },
            { 140, 8 },{ 148, 10 },{ 158, 6 },{ 164, 8 },{ 172, 12 },{ 184, 8 },{ 192, 5 },{ 197, 3 },{ 200, 4 },{ 204, 6 },{ 210, 8 },
            { 218, 8 },{ 226, 8 },{ 234, 8 },{ 242, 8 },{ 250, 12 },{ 262, 13 },{ 275, 8 },{ 283, 8 },{ 291, 10 },{ 301, 8 },{ 309, 8 },
            { 317, 5 },{ 322, 8 },{ 330, 8 },{ 338, 8 },{ 346, 8 },{ 354, 8 },{ 362, 8 },{ 370, 8 },{ 378, 8 },{ 386, 8 },{ 394, 8 },
            { 402, 8 },{ 410, 8 },{ 418, 4 },{ 422, 8 },{ 430, 6 },{ 436, 8 },{ 444, 10 },{ 454, 8 },{ 462, 12 },{ 474, 8 },{ 482, 8 },
            { 490, 4 },{ 494, 8 },{ 502, 6 },{ 508, 8 },{ 516, 10 },{ 526, 8 },{ 534, 12 },{ 546, 8 },{ 554, 8 },{ 562, 8 },{ 570, 8 },
            { 578, 8 },{ 586, 8 },{ 594, 8 },{ 602, 8 },{ 610, 8 },{ 618, 8 },{ 626, 8 },{ 634, 8 },{ 642, 11 },{ 653, 8 },{ 661, 8 },
            { 669, 6 },{ 675, 8 },{ 683, 8 },{ 691, 3 },{ 694, 4 },{ 698, 8 },{ 706, 8 },{ 714, 8 },{ 722, 8 },{ 730, 8 },{ 738, 10 },
            { 748, 12 },{ 760, 13 },{ 773, 11 },{ 784, 8 },{ 792, 4 },{ 796, 8 },{ 804, 10 },{ 814, 6 },{ 820, 8 },{ 828, 8 },{ 836, 12 },
            { 848, 4 },{ 852, 8 },{ 860, 8 },{ 868, 8 },{ 876, 8 },{ 884, 10 },{ 894, 12 },{ 906, 12 },{ 918, 11 },{ 929, 11 },{ 940, 8 },
            { 948, 10 },{ 958, 12 },{ 970, 8 },{ 978, 12 },{ 990, 13 },{ 1003, 12 },{ 1015, 13 },{ 1028, 12 },{ 1040, 2 },{ 1042, 2 },{ 1044, 4 },
            { 1048, 5 },{ 1053, 3 },{ 1056, 4 },{ 1060, 4 },{ 1064, 6 },{ 1070, 6 },{ 1076, 7 },{ 1083, 4 },{ 1087, 6 },{ 1093, 4 },{ 1097, 4 },
            { 1101, 5 },{ 1106, 6 },{ 1112, 7 },{ 1119, 4 },{ 1123, 2 },{ 1125, 5 },{ 1130, 4 },{ 1134, 4 },{ 1138, 6 },{ 1144, 4 },{ 1148, 4 },
            { 1152, 6 },{ 1158, 6 },{ 1164, 6 },{ 1170, 6 },{ 1176, 6 },{ 1182, 2 },{ 1184, 5 },{ 1189, 4 },{ 1193, 6 },{ 1199, 6 },{ 1205, 4 },
            { 1209, 4 },{ 1213, 4 },{ 1217, 4 },{ 1221, 6 },{ 1227, 6 },{ 1233, 6 },{ 1239, 4 },{ 1243, 2 },{ 1245, 8 },{ 1253, 3 },{ 1256, 6 },
            { 1262, 7 },{ 1269, 7 },{ 1276, 4 },{ 1280, 4 },{ 1284, 5 },{ 1289, 5 },{ 1294, 4 },{ 1298, 4 },{ 1302, 6 },{ 1308, 6 },{ 1314, 4 },
            { 1318, 5 },{ 1323, 6 },{ 1329, 7 },{ 1336, 6 },{ 1342, 7 },{ 1349, 6 },{ 1355, 5 },{ 1360, 4 },{ 1364, 4 },{ 1368, 5 },{ 1373, 4 },
            { 1377, 4 },{ 1381, 6 },{ 1387, 2 },{ 1389, 4 },{ 1393, 6 },{ 1399, 6 },{ 1405, 6 },{ 1411, 5 },{ 1416, 6 },{ 1422, 2 },{ 1424, 4 },
            { 1428, 8 },{ 1436, 3 },{ 1439, 7 },{ 1446, 6 },{ 1452, 2 },{ 1454, 4 },{ 1458, 4 },{ 1462, 6 },{ 1468, 6 },{ 1474, 4 },{ 1478, 6 },
            { 1484, 6 },{ 1490, 4 },{ 1494, 4 },{ 1498, 6 },{ 1504, 4 },{ 1508, 6 },{ 1514, 4 },{ 1518, 6 },{ 1524, 6 },{ 1530, 3 },{ 1533, 7 },
            { 1540, 6 },{ 1546, 4 },{ 1550, 5 },{ 1555, 6 },{ 1561, 6 },{ 1567, 6 },{ 1573, 5 },{ 1578, 6 },{ 1584, 8 },{ 1592, 6 },{ 1598, 6 },
            { 1604, 8 },
        };
        static const int g_shapes1[][2] =
        {
            { 0, 16 }
        };
        static const int g_shapes2[64][2] =
        {
            { 33, 96 },{ 63, 66 },{ 20, 109 },{ 22, 107 },{ 37, 92 },{ 7, 122 },{ 8, 121 },{ 23, 106 },
            { 38, 91 },{ 2, 127 },{ 9, 120 },{ 26, 103 },{ 3, 126 },{ 6, 123 },{ 1, 128 },{ 19, 110 },
            { 15, 114 },{ 124, 5 },{ 72, 57 },{ 115, 14 },{ 125, 4 },{ 70, 59 },{ 100, 29 },{ 60, 69 },
            { 116, 13 },{ 99, 30 },{ 78, 51 },{ 94, 35 },{ 104, 25 },{ 111, 18 },{ 71, 58 },{ 90, 39 },
            { 45, 84 },{ 16, 113 },{ 82, 47 },{ 95, 34 },{ 87, 42 },{ 83, 46 },{ 53, 76 },{ 48, 81 },
            { 68, 61 },{ 105, 24 },{ 98, 31 },{ 88, 41 },{ 75, 54 },{ 43, 86 },{ 52, 77 },{ 117, 12 },
            { 119, 10 },{ 118, 11 },{ 85, 44 },{ 101, 28 },{ 36, 93 },{ 55, 74 },{ 89, 40 },{ 79, 50 },
            { 56, 73 },{ 49, 80 },{ 64, 65 },{ 27, 102 },{ 32, 97 },{ 112, 17 },{ 67, 62 },{ 21, 108 },
        };
        static const int g_shapes3[64][3] =
        {
            { 148, 160, 240 },{ 132, 212, 205 },{ 136, 233, 187 },{ 175, 237, 143 },{ 6, 186, 232 },{ 33, 142, 232 },{ 131, 123, 142 },{ 131, 96, 186 },
            { 6, 171, 110 },{ 1, 18, 110 },{ 1, 146, 123 },{ 33, 195, 66 },{ 20, 51, 66 },{ 20, 178, 96 },{ 2, 177, 106 },{ 211, 4, 59 },
            { 8, 191, 91 },{ 230, 14, 29 },{ 1, 188, 234 },{ 151, 110, 168 },{ 20, 144, 238 },{ 137, 66, 206 },{ 173, 179, 232 },{ 209, 194, 186 },
            { 239, 165, 142 },{ 131, 152, 242 },{ 214, 54, 12 },{ 140, 219, 201 },{ 190, 150, 231 },{ 156, 135, 241 },{ 185, 227, 167 },{ 145, 210, 59 },
            { 138, 174, 106 },{ 189, 229, 14 },{ 176, 133, 106 },{ 78, 178, 195 },{ 111, 146, 171 },{ 216, 180, 196 },{ 217, 181, 193 },{ 184, 228, 166 },
            { 192, 225, 153 },{ 134, 141, 123 },{ 6, 222, 198 },{ 149, 183, 96 },{ 33, 226, 164 },{ 161, 215, 51 },{ 197, 221, 18 },{ 1, 223, 199 },
            { 154, 163, 110 },{ 20, 236, 169 },{ 157, 204, 66 },{ 1, 202, 220 },{ 20, 170, 235 },{ 203, 158, 66 },{ 162, 155, 110 },{ 6, 201, 218 },
            { 139, 135, 123 },{ 33, 167, 224 },{ 182, 150, 96 },{ 19, 200, 213 },{ 63, 207, 159 },{ 147, 172, 109 },{ 129, 130, 128 },{ 208, 14, 59 },
        };

        static const int g_shapeList1[] =
        {
            0,
        };

        static const int g_shapeList1Collapse[] =
        {
            0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1,
        };
        static const int g_shapeList2[] =
        {
            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
            12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,
            23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33,
            34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44,
            45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55,
            56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66,
            67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77,
            78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88,
            89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,
            100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110,
            111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121,
            122, 123, 124, 125, 126, 127, 128,
        };
        static const int g_shapeList2Collapse[] =
        {
            -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
            10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
            21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
            32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42,
            43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53,
            54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64,
            65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75,
            76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86,
            87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97,
            98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108,
            109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,
            120, 121, 122, 123, 124, 125, 126, 127, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1,
        };

        static const int g_shapeList12[] =
        {
            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
            11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
            22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,
            33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
            44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54,
            55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65,
            66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76,
            77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87,
            88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98,
            99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109,
            110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120,
            121, 122, 123, 124, 125, 126, 127, 128,
        };

        static const int g_shapeList12Collapse[] =
        {
            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
            11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
            22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,
            33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
            44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54,
            55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65,
            66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76,
            77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87,
            88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98,
            99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109,
            110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120,
            121, 122, 123, 124, 125, 126, 127, 128, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1,
        };

        static const int g_shapeList3[] =
        {
            1, 2, 4, 6, 8, 12, 14, 18, 19, 20, 29,
            33, 51, 54, 59, 63, 66, 78, 91, 96, 106, 109,
            110, 111, 123, 128, 129, 130, 131, 132, 133, 134, 135,
            136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146,
            147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157,
            158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168,
            169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179,
            180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190,
            191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201,
            202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212,
            213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,
            224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234,
            235, 236, 237, 238, 239, 240, 241, 242,
        };

        static const int g_shapeList3Collapse[] =
        {
            -1, 0, 1, -1, 2, -1, 3, -1, 4, -1, -1,
            -1, 5, -1, 6, -1, -1, -1, 7, 8, 9, -1,
            -1, -1, -1, -1, -1, -1, -1, 10, -1, -1, -1,
            11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, 12, -1, -1, 13,
            -1, -1, -1, -1, 14, -1, -1, -1, 15, -1, -1,
            16, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, 17, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, 18, -1, -1, -1, -1, 19, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, 20, -1, -1, 21,
            22, 23, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, 24, -1, -1, -1, -1, 25, 26, 27, 28,
            29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,
            40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50,
            51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61,
            62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72,
            73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83,
            84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94,
            95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105,
            106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116,
            117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127,
            128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138,
            139,
        };

        static const int g_shapeList3Short[] =
        {
            1, 2, 4, 6, 18, 20, 33, 51, 59, 66, 96,
            106, 110, 123, 131, 132, 136, 142, 143, 146, 148, 160,
            171, 175, 177, 178, 186, 187, 195, 205, 211, 212, 232,
            233, 237, 240,
        };

        static const int g_shapeList3ShortCollapse[] =
        {
            -1, 0, 1, -1, 2, -1, 3, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, 4, -1, 5, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, 7, -1, -1, -1,
            -1, -1, -1, -1, 8, -1, -1, -1, -1, -1, -1,
            9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, 10, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, 11, -1, -1, -1,
            12, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, 13, -1, -1, -1, -1, -1, -1, -1, 14,
            15, -1, -1, -1, 16, -1, -1, -1, -1, -1, 17,
            18, -1, -1, 19, -1, 20, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, 21, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, 22, -1, -1, -1, 23,
            -1, 24, 25, -1, -1, -1, -1, -1, -1, -1, 26,
            27, -1, -1, -1, -1, -1, -1, -1, 28, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, 29, -1, -1, -1,
            -1, -1, 30, 31, -1, -1, -1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, 32, 33, -1, -1, -1, 34, -1, -1, 35, -1,
            -1,
        };

        static const int g_shapeListAll[] =
        {
            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
            11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
            22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,
            33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
            44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54,
            55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65,
            66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76,
            77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87,
            88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98,
            99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109,
            110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120,
            121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131,
            132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142,
            143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153,
            154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164,
            165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,
            176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186,
            187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197,
            198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208,
            209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219,
            220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230,
            231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241,
            242,
        };

        static const int g_numShapes1 = sizeof(g_shapeList1) / sizeof(g_shapeList1[0]);
        static const int g_numShapes2 = sizeof(g_shapeList2) / sizeof(g_shapeList2[0]);
        static const int g_numShapes12 = sizeof(g_shapeList12) / sizeof(g_shapeList12[0]);
        static const int g_numShapes3 = sizeof(g_shapeList3) / sizeof(g_shapeList3[0]);
        static const int g_numShapes3Short = sizeof(g_shapeList3Short) / sizeof(g_shapeList3Short[0]);
        static const int g_numShapesAll = sizeof(g_shapeListAll) / sizeof(g_shapeListAll[0]);
        static const int g_numFragments = sizeof(g_fragments) / sizeof(g_fragments[0]);

        static const int g_maxFragmentsPerMode = (g_numShapes2 > g_numShapes3) ? g_numShapes2 : g_numShapes3;
    }

    namespace BC6HData
    {
        enum EField
        {
            NA, // N/A
            M,  // Mode
            D,  // Shape
            RW,
            RX,
            RY,
            RZ,
            GW,
            GX,
            GY,
            GZ,
            BW,
            BX,
            BY,
            BZ,
        };

        struct ModeDescriptor
        {
            EField m_eField;
            uint8_t   m_uBit;
        };

        const ModeDescriptor g_modeDescriptors[14][82] =
        {
            {   // Mode 1 (0x00) - 10 5 5 5
                { M, 0 },{ M, 1 },{ GY, 4 },{ BY, 4 },{ BZ, 4 },{ RW, 0 },{ RW, 1 },{ RW, 2 },{ RW, 3 },{ RW, 4 },
                { RW, 5 },{ RW, 6 },{ RW, 7 },{ RW, 8 },{ RW, 9 },{ GW, 0 },{ GW, 1 },{ GW, 2 },{ GW, 3 },{ GW, 4 },
                { GW, 5 },{ GW, 6 },{ GW, 7 },{ GW, 8 },{ GW, 9 },{ BW, 0 },{ BW, 1 },{ BW, 2 },{ BW, 3 },{ BW, 4 },
                { BW, 5 },{ BW, 6 },{ BW, 7 },{ BW, 8 },{ BW, 9 },{ RX, 0 },{ RX, 1 },{ RX, 2 },{ RX, 3 },{ RX, 4 },
                { GZ, 4 },{ GY, 0 },{ GY, 1 },{ GY, 2 },{ GY, 3 },{ GX, 0 },{ GX, 1 },{ GX, 2 },{ GX, 3 },{ GX, 4 },
                { BZ, 0 },{ GZ, 0 },{ GZ, 1 },{ GZ, 2 },{ GZ, 3 },{ BX, 0 },{ BX, 1 },{ BX, 2 },{ BX, 3 },{ BX, 4 },
                { BZ, 1 },{ BY, 0 },{ BY, 1 },{ BY, 2 },{ BY, 3 },{ RY, 0 },{ RY, 1 },{ RY, 2 },{ RY, 3 },{ RY, 4 },
                { BZ, 2 },{ RZ, 0 },{ RZ, 1 },{ RZ, 2 },{ RZ, 3 },{ RZ, 4 },{ BZ, 3 },{ D, 0 },{ D, 1 },{ D, 2 },
                { D, 3 },{ D, 4 },
            },

            {   // Mode 2 (0x01) - 7 6 6 6
                { M, 0 },{ M, 1 },{ GY, 5 },{ GZ, 4 },{ GZ, 5 },{ RW, 0 },{ RW, 1 },{ RW, 2 },{ RW, 3 },{ RW, 4 },
                { RW, 5 },{ RW, 6 },{ BZ, 0 },{ BZ, 1 },{ BY, 4 },{ GW, 0 },{ GW, 1 },{ GW, 2 },{ GW, 3 },{ GW, 4 },
                { GW, 5 },{ GW, 6 },{ BY, 5 },{ BZ, 2 },{ GY, 4 },{ BW, 0 },{ BW, 1 },{ BW, 2 },{ BW, 3 },{ BW, 4 },
                { BW, 5 },{ BW, 6 },{ BZ, 3 },{ BZ, 5 },{ BZ, 4 },{ RX, 0 },{ RX, 1 },{ RX, 2 },{ RX, 3 },{ RX, 4 },
                { RX, 5 },{ GY, 0 },{ GY, 1 },{ GY, 2 },{ GY, 3 },{ GX, 0 },{ GX, 1 },{ GX, 2 },{ GX, 3 },{ GX, 4 },
                { GX, 5 },{ GZ, 0 },{ GZ, 1 },{ GZ, 2 },{ GZ, 3 },{ BX, 0 },{ BX, 1 },{ BX, 2 },{ BX, 3 },{ BX, 4 },
                { BX, 5 },{ BY, 0 },{ BY, 1 },{ BY, 2 },{ BY, 3 },{ RY, 0 },{ RY, 1 },{ RY, 2 },{ RY, 3 },{ RY, 4 },
                { RY, 5 },{ RZ, 0 },{ RZ, 1 },{ RZ, 2 },{ RZ, 3 },{ RZ, 4 },{ RZ, 5 },{ D, 0 },{ D, 1 },{ D, 2 },
                { D, 3 },{ D, 4 },
            },

            {   // Mode 3 (0x02) - 11 5 4 4
                { M, 0 },{ M, 1 },{ M, 2 },{ M, 3 },{ M, 4 },{ RW, 0 },{ RW, 1 },{ RW, 2 },{ RW, 3 },{ RW, 4 },
                { RW, 5 },{ RW, 6 },{ RW, 7 },{ RW, 8 },{ RW, 9 },{ GW, 0 },{ GW, 1 },{ GW, 2 },{ GW, 3 },{ GW, 4 },
                { GW, 5 },{ GW, 6 },{ GW, 7 },{ GW, 8 },{ GW, 9 },{ BW, 0 },{ BW, 1 },{ BW, 2 },{ BW, 3 },{ BW, 4 },
                { BW, 5 },{ BW, 6 },{ BW, 7 },{ BW, 8 },{ BW, 9 },{ RX, 0 },{ RX, 1 },{ RX, 2 },{ RX, 3 },{ RX, 4 },
                { RW,10 },{ GY, 0 },{ GY, 1 },{ GY, 2 },{ GY, 3 },{ GX, 0 },{ GX, 1 },{ GX, 2 },{ GX, 3 },{ GW,10 },
                { BZ, 0 },{ GZ, 0 },{ GZ, 1 },{ GZ, 2 },{ GZ, 3 },{ BX, 0 },{ BX, 1 },{ BX, 2 },{ BX, 3 },{ BW,10 },
                { BZ, 1 },{ BY, 0 },{ BY, 1 },{ BY, 2 },{ BY, 3 },{ RY, 0 },{ RY, 1 },{ RY, 2 },{ RY, 3 },{ RY, 4 },
                { BZ, 2 },{ RZ, 0 },{ RZ, 1 },{ RZ, 2 },{ RZ, 3 },{ RZ, 4 },{ BZ, 3 },{ D, 0 },{ D, 1 },{ D, 2 },
                { D, 3 },{ D, 4 },
            },

            {   // Mode 4 (0x06) - 11 4 5 4
                { M, 0 },{ M, 1 },{ M, 2 },{ M, 3 },{ M, 4 },{ RW, 0 },{ RW, 1 },{ RW, 2 },{ RW, 3 },{ RW, 4 },
                { RW, 5 },{ RW, 6 },{ RW, 7 },{ RW, 8 },{ RW, 9 },{ GW, 0 },{ GW, 1 },{ GW, 2 },{ GW, 3 },{ GW, 4 },
                { GW, 5 },{ GW, 6 },{ GW, 7 },{ GW, 8 },{ GW, 9 },{ BW, 0 },{ BW, 1 },{ BW, 2 },{ BW, 3 },{ BW, 4 },
                { BW, 5 },{ BW, 6 },{ BW, 7 },{ BW, 8 },{ BW, 9 },{ RX, 0 },{ RX, 1 },{ RX, 2 },{ RX, 3 },{ RW,10 },
                { GZ, 4 },{ GY, 0 },{ GY, 1 },{ GY, 2 },{ GY, 3 },{ GX, 0 },{ GX, 1 },{ GX, 2 },{ GX, 3 },{ GX, 4 },
                { GW,10 },{ GZ, 0 },{ GZ, 1 },{ GZ, 2 },{ GZ, 3 },{ BX, 0 },{ BX, 1 },{ BX, 2 },{ BX, 3 },{ BW,10 },
                { BZ, 1 },{ BY, 0 },{ BY, 1 },{ BY, 2 },{ BY, 3 },{ RY, 0 },{ RY, 1 },{ RY, 2 },{ RY, 3 },{ BZ, 0 },
                { BZ, 2 },{ RZ, 0 },{ RZ, 1 },{ RZ, 2 },{ RZ, 3 },{ GY, 4 },{ BZ, 3 },{ D, 0 },{ D, 1 },{ D, 2 },
                { D, 3 },{ D, 4 },
            },

            {   // Mode 5 (0x0a) - 11 4 4 5
                { M, 0 },{ M, 1 },{ M, 2 },{ M, 3 },{ M, 4 },{ RW, 0 },{ RW, 1 },{ RW, 2 },{ RW, 3 },{ RW, 4 },
                { RW, 5 },{ RW, 6 },{ RW, 7 },{ RW, 8 },{ RW, 9 },{ GW, 0 },{ GW, 1 },{ GW, 2 },{ GW, 3 },{ GW, 4 },
                { GW, 5 },{ GW, 6 },{ GW, 7 },{ GW, 8 },{ GW, 9 },{ BW, 0 },{ BW, 1 },{ BW, 2 },{ BW, 3 },{ BW, 4 },
                { BW, 5 },{ BW, 6 },{ BW, 7 },{ BW, 8 },{ BW, 9 },{ RX, 0 },{ RX, 1 },{ RX, 2 },{ RX, 3 },{ RW,10 },
                { BY, 4 },{ GY, 0 },{ GY, 1 },{ GY, 2 },{ GY, 3 },{ GX, 0 },{ GX, 1 },{ GX, 2 },{ GX, 3 },{ GW,10 },
                { BZ, 0 },{ GZ, 0 },{ GZ, 1 },{ GZ, 2 },{ GZ, 3 },{ BX, 0 },{ BX, 1 },{ BX, 2 },{ BX, 3 },{ BX, 4 },
                { BW,10 },{ BY, 0 },{ BY, 1 },{ BY, 2 },{ BY, 3 },{ RY, 0 },{ RY, 1 },{ RY, 2 },{ RY, 3 },{ BZ, 1 },
                { BZ, 2 },{ RZ, 0 },{ RZ, 1 },{ RZ, 2 },{ RZ, 3 },{ BZ, 4 },{ BZ, 3 },{ D, 0 },{ D, 1 },{ D, 2 },
                { D, 3 },{ D, 4 },
            },

            {   // Mode 6 (0x0e) - 9 5 5 5
                { M, 0 },{ M, 1 },{ M, 2 },{ M, 3 },{ M, 4 },{ RW, 0 },{ RW, 1 },{ RW, 2 },{ RW, 3 },{ RW, 4 },
                { RW, 5 },{ RW, 6 },{ RW, 7 },{ RW, 8 },{ BY, 4 },{ GW, 0 },{ GW, 1 },{ GW, 2 },{ GW, 3 },{ GW, 4 },
                { GW, 5 },{ GW, 6 },{ GW, 7 },{ GW, 8 },{ GY, 4 },{ BW, 0 },{ BW, 1 },{ BW, 2 },{ BW, 3 },{ BW, 4 },
                { BW, 5 },{ BW, 6 },{ BW, 7 },{ BW, 8 },{ BZ, 4 },{ RX, 0 },{ RX, 1 },{ RX, 2 },{ RX, 3 },{ RX, 4 },
                { GZ, 4 },{ GY, 0 },{ GY, 1 },{ GY, 2 },{ GY, 3 },{ GX, 0 },{ GX, 1 },{ GX, 2 },{ GX, 3 },{ GX, 4 },
                { BZ, 0 },{ GZ, 0 },{ GZ, 1 },{ GZ, 2 },{ GZ, 3 },{ BX, 0 },{ BX, 1 },{ BX, 2 },{ BX, 3 },{ BX, 4 },
                { BZ, 1 },{ BY, 0 },{ BY, 1 },{ BY, 2 },{ BY, 3 },{ RY, 0 },{ RY, 1 },{ RY, 2 },{ RY, 3 },{ RY, 4 },
                { BZ, 2 },{ RZ, 0 },{ RZ, 1 },{ RZ, 2 },{ RZ, 3 },{ RZ, 4 },{ BZ, 3 },{ D, 0 },{ D, 1 },{ D, 2 },
                { D, 3 },{ D, 4 },
            },

            {   // Mode 7 (0x12) - 8 6 5 5
                { M, 0 },{ M, 1 },{ M, 2 },{ M, 3 },{ M, 4 },{ RW, 0 },{ RW, 1 },{ RW, 2 },{ RW, 3 },{ RW, 4 },
                { RW, 5 },{ RW, 6 },{ RW, 7 },{ GZ, 4 },{ BY, 4 },{ GW, 0 },{ GW, 1 },{ GW, 2 },{ GW, 3 },{ GW, 4 },
                { GW, 5 },{ GW, 6 },{ GW, 7 },{ BZ, 2 },{ GY, 4 },{ BW, 0 },{ BW, 1 },{ BW, 2 },{ BW, 3 },{ BW, 4 },
                { BW, 5 },{ BW, 6 },{ BW, 7 },{ BZ, 3 },{ BZ, 4 },{ RX, 0 },{ RX, 1 },{ RX, 2 },{ RX, 3 },{ RX, 4 },
                { RX, 5 },{ GY, 0 },{ GY, 1 },{ GY, 2 },{ GY, 3 },{ GX, 0 },{ GX, 1 },{ GX, 2 },{ GX, 3 },{ GX, 4 },
                { BZ, 0 },{ GZ, 0 },{ GZ, 1 },{ GZ, 2 },{ GZ, 3 },{ BX, 0 },{ BX, 1 },{ BX, 2 },{ BX, 3 },{ BX, 4 },
                { BZ, 1 },{ BY, 0 },{ BY, 1 },{ BY, 2 },{ BY, 3 },{ RY, 0 },{ RY, 1 },{ RY, 2 },{ RY, 3 },{ RY, 4 },
                { RY, 5 },{ RZ, 0 },{ RZ, 1 },{ RZ, 2 },{ RZ, 3 },{ RZ, 4 },{ RZ, 5 },{ D, 0 },{ D, 1 },{ D, 2 },
                { D, 3 },{ D, 4 },
            },

            {   // Mode 8 (0x16) - 8 5 6 5
                { M, 0 },{ M, 1 },{ M, 2 },{ M, 3 },{ M, 4 },{ RW, 0 },{ RW, 1 },{ RW, 2 },{ RW, 3 },{ RW, 4 },
                { RW, 5 },{ RW, 6 },{ RW, 7 },{ BZ, 0 },{ BY, 4 },{ GW, 0 },{ GW, 1 },{ GW, 2 },{ GW, 3 },{ GW, 4 },
                { GW, 5 },{ GW, 6 },{ GW, 7 },{ GY, 5 },{ GY, 4 },{ BW, 0 },{ BW, 1 },{ BW, 2 },{ BW, 3 },{ BW, 4 },
                { BW, 5 },{ BW, 6 },{ BW, 7 },{ GZ, 5 },{ BZ, 4 },{ RX, 0 },{ RX, 1 },{ RX, 2 },{ RX, 3 },{ RX, 4 },
                { GZ, 4 },{ GY, 0 },{ GY, 1 },{ GY, 2 },{ GY, 3 },{ GX, 0 },{ GX, 1 },{ GX, 2 },{ GX, 3 },{ GX, 4 },
                { GX, 5 },{ GZ, 0 },{ GZ, 1 },{ GZ, 2 },{ GZ, 3 },{ BX, 0 },{ BX, 1 },{ BX, 2 },{ BX, 3 },{ BX, 4 },
                { BZ, 1 },{ BY, 0 },{ BY, 1 },{ BY, 2 },{ BY, 3 },{ RY, 0 },{ RY, 1 },{ RY, 2 },{ RY, 3 },{ RY, 4 },
                { BZ, 2 },{ RZ, 0 },{ RZ, 1 },{ RZ, 2 },{ RZ, 3 },{ RZ, 4 },{ BZ, 3 },{ D, 0 },{ D, 1 },{ D, 2 },
                { D, 3 },{ D, 4 },
            },

            {   // Mode 9 (0x1a) - 8 5 5 6
                { M, 0 },{ M, 1 },{ M, 2 },{ M, 3 },{ M, 4 },{ RW, 0 },{ RW, 1 },{ RW, 2 },{ RW, 3 },{ RW, 4 },
                { RW, 5 },{ RW, 6 },{ RW, 7 },{ BZ, 1 },{ BY, 4 },{ GW, 0 },{ GW, 1 },{ GW, 2 },{ GW, 3 },{ GW, 4 },
                { GW, 5 },{ GW, 6 },{ GW, 7 },{ BY, 5 },{ GY, 4 },{ BW, 0 },{ BW, 1 },{ BW, 2 },{ BW, 3 },{ BW, 4 },
                { BW, 5 },{ BW, 6 },{ BW, 7 },{ BZ, 5 },{ BZ, 4 },{ RX, 0 },{ RX, 1 },{ RX, 2 },{ RX, 3 },{ RX, 4 },
                { GZ, 4 },{ GY, 0 },{ GY, 1 },{ GY, 2 },{ GY, 3 },{ GX, 0 },{ GX, 1 },{ GX, 2 },{ GX, 3 },{ GX, 4 },
                { BZ, 0 },{ GZ, 0 },{ GZ, 1 },{ GZ, 2 },{ GZ, 3 },{ BX, 0 },{ BX, 1 },{ BX, 2 },{ BX, 3 },{ BX, 4 },
                { BX, 5 },{ BY, 0 },{ BY, 1 },{ BY, 2 },{ BY, 3 },{ RY, 0 },{ RY, 1 },{ RY, 2 },{ RY, 3 },{ RY, 4 },
                { BZ, 2 },{ RZ, 0 },{ RZ, 1 },{ RZ, 2 },{ RZ, 3 },{ RZ, 4 },{ BZ, 3 },{ D, 0 },{ D, 1 },{ D, 2 },
                { D, 3 },{ D, 4 },
            },

            {   // Mode 10 (0x1e) - 6 6 6 6
                { M, 0 },{ M, 1 },{ M, 2 },{ M, 3 },{ M, 4 },{ RW, 0 },{ RW, 1 },{ RW, 2 },{ RW, 3 },{ RW, 4 },
                { RW, 5 },{ GZ, 4 },{ BZ, 0 },{ BZ, 1 },{ BY, 4 },{ GW, 0 },{ GW, 1 },{ GW, 2 },{ GW, 3 },{ GW, 4 },
                { GW, 5 },{ GY, 5 },{ BY, 5 },{ BZ, 2 },{ GY, 4 },{ BW, 0 },{ BW, 1 },{ BW, 2 },{ BW, 3 },{ BW, 4 },
                { BW, 5 },{ GZ, 5 },{ BZ, 3 },{ BZ, 5 },{ BZ, 4 },{ RX, 0 },{ RX, 1 },{ RX, 2 },{ RX, 3 },{ RX, 4 },
                { RX, 5 },{ GY, 0 },{ GY, 1 },{ GY, 2 },{ GY, 3 },{ GX, 0 },{ GX, 1 },{ GX, 2 },{ GX, 3 },{ GX, 4 },
                { GX, 5 },{ GZ, 0 },{ GZ, 1 },{ GZ, 2 },{ GZ, 3 },{ BX, 0 },{ BX, 1 },{ BX, 2 },{ BX, 3 },{ BX, 4 },
                { BX, 5 },{ BY, 0 },{ BY, 1 },{ BY, 2 },{ BY, 3 },{ RY, 0 },{ RY, 1 },{ RY, 2 },{ RY, 3 },{ RY, 4 },
                { RY, 5 },{ RZ, 0 },{ RZ, 1 },{ RZ, 2 },{ RZ, 3 },{ RZ, 4 },{ RZ, 5 },{ D, 0 },{ D, 1 },{ D, 2 },
                { D, 3 },{ D, 4 },
            },

            {   // Mode 11 (0x03) - 10 10
                { M, 0 },{ M, 1 },{ M, 2 },{ M, 3 },{ M, 4 },{ RW, 0 },{ RW, 1 },{ RW, 2 },{ RW, 3 },{ RW, 4 },
                { RW, 5 },{ RW, 6 },{ RW, 7 },{ RW, 8 },{ RW, 9 },{ GW, 0 },{ GW, 1 },{ GW, 2 },{ GW, 3 },{ GW, 4 },
                { GW, 5 },{ GW, 6 },{ GW, 7 },{ GW, 8 },{ GW, 9 },{ BW, 0 },{ BW, 1 },{ BW, 2 },{ BW, 3 },{ BW, 4 },
                { BW, 5 },{ BW, 6 },{ BW, 7 },{ BW, 8 },{ BW, 9 },{ RX, 0 },{ RX, 1 },{ RX, 2 },{ RX, 3 },{ RX, 4 },
                { RX, 5 },{ RX, 6 },{ RX, 7 },{ RX, 8 },{ RX, 9 },{ GX, 0 },{ GX, 1 },{ GX, 2 },{ GX, 3 },{ GX, 4 },
                { GX, 5 },{ GX, 6 },{ GX, 7 },{ GX, 8 },{ GX, 9 },{ BX, 0 },{ BX, 1 },{ BX, 2 },{ BX, 3 },{ BX, 4 },
                { BX, 5 },{ BX, 6 },{ BX, 7 },{ BX, 8 },{ BX, 9 },{ NA, 0 },{ NA, 0 },{ NA, 0 },{ NA, 0 },{ NA, 0 },
                { NA, 0 },{ NA, 0 },{ NA, 0 },{ NA, 0 },{ NA, 0 },{ NA, 0 },{ NA, 0 },{ NA, 0 },{ NA, 0 },{ NA, 0 },
                { NA, 0 },{ NA, 0 },
            },

            {   // Mode 12 (0x07) - 11 9
                { M, 0 },{ M, 1 },{ M, 2 },{ M, 3 },{ M, 4 },{ RW, 0 },{ RW, 1 },{ RW, 2 },{ RW, 3 },{ RW, 4 },
                { RW, 5 },{ RW, 6 },{ RW, 7 },{ RW, 8 },{ RW, 9 },{ GW, 0 },{ GW, 1 },{ GW, 2 },{ GW, 3 },{ GW, 4 },
                { GW, 5 },{ GW, 6 },{ GW, 7 },{ GW, 8 },{ GW, 9 },{ BW, 0 },{ BW, 1 },{ BW, 2 },{ BW, 3 },{ BW, 4 },
                { BW, 5 },{ BW, 6 },{ BW, 7 },{ BW, 8 },{ BW, 9 },{ RX, 0 },{ RX, 1 },{ RX, 2 },{ RX, 3 },{ RX, 4 },
                { RX, 5 },{ RX, 6 },{ RX, 7 },{ RX, 8 },{ RW,10 },{ GX, 0 },{ GX, 1 },{ GX, 2 },{ GX, 3 },{ GX, 4 },
                { GX, 5 },{ GX, 6 },{ GX, 7 },{ GX, 8 },{ GW,10 },{ BX, 0 },{ BX, 1 },{ BX, 2 },{ BX, 3 },{ BX, 4 },
                { BX, 5 },{ BX, 6 },{ BX, 7 },{ BX, 8 },{ BW,10 },{ NA, 0 },{ NA, 0 },{ NA, 0 },{ NA, 0 },{ NA, 0 },
                { NA, 0 },{ NA, 0 },{ NA, 0 },{ NA, 0 },{ NA, 0 },{ NA, 0 },{ NA, 0 },{ NA, 0 },{ NA, 0 },{ NA, 0 },
                { NA, 0 },{ NA, 0 },
            },

            {   // Mode 13 (0x0b) - 12 8
                { M, 0 },{ M, 1 },{ M, 2 },{ M, 3 },{ M, 4 },{ RW, 0 },{ RW, 1 },{ RW, 2 },{ RW, 3 },{ RW, 4 },
                { RW, 5 },{ RW, 6 },{ RW, 7 },{ RW, 8 },{ RW, 9 },{ GW, 0 },{ GW, 1 },{ GW, 2 },{ GW, 3 },{ GW, 4 },
                { GW, 5 },{ GW, 6 },{ GW, 7 },{ GW, 8 },{ GW, 9 },{ BW, 0 },{ BW, 1 },{ BW, 2 },{ BW, 3 },{ BW, 4 },
                { BW, 5 },{ BW, 6 },{ BW, 7 },{ BW, 8 },{ BW, 9 },{ RX, 0 },{ RX, 1 },{ RX, 2 },{ RX, 3 },{ RX, 4 },
                { RX, 5 },{ RX, 6 },{ RX, 7 },{ RW,11 },{ RW,10 },{ GX, 0 },{ GX, 1 },{ GX, 2 },{ GX, 3 },{ GX, 4 },
                { GX, 5 },{ GX, 6 },{ GX, 7 },{ GW,11 },{ GW,10 },{ BX, 0 },{ BX, 1 },{ BX, 2 },{ BX, 3 },{ BX, 4 },
                { BX, 5 },{ BX, 6 },{ BX, 7 },{ BW,11 },{ BW,10 },{ NA, 0 },{ NA, 0 },{ NA, 0 },{ NA, 0 },{ NA, 0 },
                { NA, 0 },{ NA, 0 },{ NA, 0 },{ NA, 0 },{ NA, 0 },{ NA, 0 },{ NA, 0 },{ NA, 0 },{ NA, 0 },{ NA, 0 },
                { NA, 0 },{ NA, 0 },
            },

            {   // Mode 14 (0x0f) - 16 4
                { M, 0 },{ M, 1 },{ M, 2 },{ M, 3 },{ M, 4 },{ RW, 0 },{ RW, 1 },{ RW, 2 },{ RW, 3 },{ RW, 4 },
                { RW, 5 },{ RW, 6 },{ RW, 7 },{ RW, 8 },{ RW, 9 },{ GW, 0 },{ GW, 1 },{ GW, 2 },{ GW, 3 },{ GW, 4 },
                { GW, 5 },{ GW, 6 },{ GW, 7 },{ GW, 8 },{ GW, 9 },{ BW, 0 },{ BW, 1 },{ BW, 2 },{ BW, 3 },{ BW, 4 },
                { BW, 5 },{ BW, 6 },{ BW, 7 },{ BW, 8 },{ BW, 9 },{ RX, 0 },{ RX, 1 },{ RX, 2 },{ RX, 3 },{ RW,15 },
                { RW,14 },{ RW,13 },{ RW,12 },{ RW,11 },{ RW,10 },{ GX, 0 },{ GX, 1 },{ GX, 2 },{ GX, 3 },{ GW,15 },
                { GW,14 },{ GW,13 },{ GW,12 },{ GW,11 },{ GW,10 },{ BX, 0 },{ BX, 1 },{ BX, 2 },{ BX, 3 },{ BW,15 },
                { BW,14 },{ BW,13 },{ BW,12 },{ BW,11 },{ BW,10 },{ NA, 0 },{ NA, 0 },{ NA, 0 },{ NA, 0 },{ NA, 0 },
                { NA, 0 },{ NA, 0 },{ NA, 0 },{ NA, 0 },{ NA, 0 },{ NA, 0 },{ NA, 0 },{ NA, 0 },{ NA, 0 },{ NA, 0 },
                { NA, 0 },{ NA, 0 },
            },
        };
    }

    namespace
    {
        struct InputBlock
        {
            int32_t m_pixels[16];
        };

        struct InputBlock16
        {
            int64_t m_pixels[16];
        };

 #if (defined(_M_IX86_FP) && _M_IX86_FP >= 2) || defined(_M_X64)
        // SSE2 version

        struct ParallelMath
        {
            template<unsigned int TRoundingMode>
			struct RoundForScope
			{
				unsigned int m_oldCSR;

				RoundForScope()
				{
					m_oldCSR = _mm_getcsr();
					_mm_setcsr((m_oldCSR & ~_MM_ROUND_MASK) | (TRoundingMode));
				}

				~RoundForScope()
				{
					_mm_setcsr(m_oldCSR);
				}
			};

            struct RoundTowardZeroForScope : RoundForScope<_MM_ROUND_TOWARD_ZERO>
            {
            };

            struct RoundTowardNearestForScope : RoundForScope<_MM_ROUND_NEAREST>
            {
            };

            struct RoundUpForScope : RoundForScope<_MM_ROUND_UP>
            {
            };

            static const int ParallelSize = 8;

            struct Int16
            {
                __m128i m_value;

                inline Int16 operator+(int16_t other) const
                {
                    Int16 result;
                    result.m_value = _mm_add_epi16(m_value, _mm_set1_epi16(other));
                    return result;
                }

                inline Int16 operator+(Int16 other) const
                {
                    Int16 result;
                    result.m_value = _mm_add_epi16(m_value, other.m_value);
                    return result;
                }

                inline Int16 operator|(Int16 other) const
                {
                    Int16 result;
                    result.m_value = _mm_or_si128(m_value, other.m_value);
                    return result;
                }

                inline Int16 operator-(Int16 other) const
                {
                    Int16 result;
                    result.m_value = _mm_sub_epi16(m_value, other.m_value);
                    return result;
                }

                inline Int16 operator*(const Int16& other) const
                {
                    Int16 result;
                    result.m_value = _mm_mullo_epi16(m_value, other.m_value);
                    return result;
                }

                inline Int16 operator<<(int bits) const
                {
                    Int16 result;
                    result.m_value = _mm_slli_epi16(m_value, bits);
                    return result;
                }
            };

            struct Int32
            {
                __m128i m_values[2];

                inline Int32 operator+(const Int32& other) const
                {
                    Int32 result;
                    result.m_values[0] = _mm_add_epi32(m_values[0], other.m_values[0]);
                    result.m_values[1] = _mm_add_epi32(m_values[1], other.m_values[1]);
                    return result;
                }

                inline Int32 operator-(const Int32& other) const
                {
                    Int32 result;
                    result.m_values[0] = _mm_sub_epi32(m_values[0], other.m_values[0]);
                    result.m_values[1] = _mm_sub_epi32(m_values[1], other.m_values[1]);
                    return result;
                }

                inline Int32 operator<<(const int other) const
                {
                    Int32 result;
                    result.m_values[0] = _mm_slli_epi32(m_values[0], other);
                    result.m_values[1] = _mm_slli_epi32(m_values[1], other);
                    return result;
                }
            };

            struct Int64
            {
                __m128i m_values[4];
            };

            struct Float
            {
                __m128 m_values[2];

                inline Float operator+(const Float& other) const
                {
                    Float result;
                    result.m_values[0] = _mm_add_ps(m_values[0], other.m_values[0]);
                    result.m_values[1] = _mm_add_ps(m_values[1], other.m_values[1]);
                    return result;
                }

                inline Float operator+(float other) const
                {
                    Float result;
                    result.m_values[0] = _mm_add_ps(m_values[0], _mm_set1_ps(other));
                    result.m_values[1] = _mm_add_ps(m_values[1], _mm_set1_ps(other));
                    return result;
                }

                inline Float operator-(const Float& other) const
                {
                    Float result;
                    result.m_values[0] = _mm_sub_ps(m_values[0], other.m_values[0]);
                    result.m_values[1] = _mm_sub_ps(m_values[1], other.m_values[1]);
                    return result;
                }

                inline Float operator-() const
                {
                    Float result;
                    result.m_values[0] = _mm_sub_ps(_mm_setzero_ps(), m_values[0]);
                    result.m_values[1] = _mm_sub_ps(_mm_setzero_ps(), m_values[1]);
                    return result;
                }

                inline Float operator*(const Float& other) const
                {
                    Float result;
                    result.m_values[0] = _mm_mul_ps(m_values[0], other.m_values[0]);
                    result.m_values[1] = _mm_mul_ps(m_values[1], other.m_values[1]);
                    return result;
                }

                inline Float operator*(float other) const
                {
                    Float result;
                    result.m_values[0] = _mm_mul_ps(m_values[0], _mm_set1_ps(other));
                    result.m_values[1] = _mm_mul_ps(m_values[1], _mm_set1_ps(other));
                    return result;
                }

                inline Float operator/(const Float& other) const
                {
                    Float result;
                    result.m_values[0] = _mm_div_ps(m_values[0], other.m_values[0]);
                    result.m_values[1] = _mm_div_ps(m_values[1], other.m_values[1]);
                    return result;
                }

                inline Float operator/(float other) const
                {
                    Float result;
                    result.m_values[0] = _mm_div_ps(m_values[0], _mm_set1_ps(other));
                    result.m_values[1] = _mm_div_ps(m_values[1], _mm_set1_ps(other));
                    return result;
                }
            };

            struct Int16CompFlag
            {
                __m128i m_value;

                inline Int16CompFlag operator&(const Int16CompFlag& other) const
                {
                    Int16CompFlag result;
                    result.m_value = _mm_and_si128(m_value, other.m_value);
                    return result;
                }

                inline Int16CompFlag operator|(const Int16CompFlag& other) const
                {
                    Int16CompFlag result;
                    result.m_value = _mm_or_si128(m_value, other.m_value);
                    return result;
                }
            };

            struct FloatCompFlag
            {
                __m128 m_values[2];
            };

            static Float Select(FloatCompFlag flag, Float a, Float b)
            {
                Float result;
                for (int i = 0; i < 2; i++)
                    result.m_values[i] = _mm_or_ps(_mm_and_ps(flag.m_values[i], a.m_values[i]), _mm_andnot_ps(flag.m_values[i], b.m_values[i]));
                return result;
            }

            static Int16 Select(Int16CompFlag flag, Int16 a, Int16 b)
            {
                Int16 result;
                result.m_value = _mm_or_si128(_mm_and_si128(flag.m_value, a.m_value), _mm_andnot_si128(flag.m_value, b.m_value));
                return result;
            }

            static Int16 SelectIfNonZero(Int16CompFlag flag, Int16 v)
            {
                Int16 result;
                result.m_value = _mm_and_si128(flag.m_value, v.m_value);
                return result;
            }

            static void ConditionalSet(Int16& dest, Int16CompFlag flag, const Int16 src)
            {
                dest.m_value = _mm_or_si128(_mm_andnot_si128(flag.m_value, dest.m_value), _mm_and_si128(flag.m_value, src.m_value));
            }

            static void NotConditionalSet(Int16& dest, Int16CompFlag flag, const Int16 src)
            {
                dest.m_value = _mm_or_si128(_mm_and_si128(flag.m_value, dest.m_value), _mm_andnot_si128(flag.m_value, src.m_value));
            }

            static void ConditionalSet(Float& dest, FloatCompFlag flag, const Float src)
            {
                for (int i = 0; i < 2; i++)
                    dest.m_values[i] = _mm_or_ps(_mm_andnot_ps(flag.m_values[i], dest.m_values[i]), _mm_and_ps(flag.m_values[i], src.m_values[i]));
            }

            static void NotConditionalSet(Float& dest, FloatCompFlag flag, const Float src)
            {
                for (int i = 0; i < 2; i++)
                    dest.m_values[i] = _mm_or_ps(_mm_and_ps(flag.m_values[i], dest.m_values[i]), _mm_andnot_ps(flag.m_values[i], src.m_values[i]));
            }

            static void MakeSafeDenominator(Float& v)
            {
                ConditionalSet(v, Equal(v, MakeFloatZero()), MakeFloat(1.0f));
            }

            static Int16 TruncateToPrecision(Int16 v, int precision, bool isSigned)
            {
                int lostBits = 16 - precision;
                if (lostBits == 0)
                    return v;

                Int16 result;
                result.m_value = _mm_slli_epi16(v.m_value, lostBits);
                if (isSigned)
                    result.m_value = _mm_srai_epi16(v.m_value, lostBits);
                else
                    result.m_value = _mm_srli_epi16(v.m_value, lostBits);

                return result;
            }

            static Int16 MinUnsigned(Int16 a, Int16 b)
            {
                __m128i bitFlip = _mm_set1_epi16(-32768);

                Int16 result;
                result.m_value = _mm_xor_si128(_mm_min_epi16(_mm_xor_si128(a.m_value, bitFlip), _mm_xor_si128(b.m_value, bitFlip)), bitFlip);
                return result;
            }

            static Int16 MinSigned(Int16 a, Int16 b)
            {
                Int16 result;
                result.m_value = _mm_min_epi16(a.m_value, b.m_value);
                return result;
            }

            static Int16 MinU8(Int16 a, Int16 b)
            {
                Int16 result;
                result.m_value = _mm_min_epi16(a.m_value, b.m_value);
                return result;
            }

            static Float Min(Float a, Float b)
            {
                Float result;
                for (int i = 0; i < 2; i++)
                    result.m_values[i] = _mm_min_ps(a.m_values[i], b.m_values[i]);
                return result;
            }

            static Int16 MaxUnsigned(Int16 a, Int16 b)
            {
                __m128i bitFlip = _mm_set1_epi16(-32768);

                Int16 result;
                result.m_value = _mm_xor_si128(_mm_min_epi16(_mm_xor_si128(a.m_value, bitFlip), _mm_xor_si128(b.m_value, bitFlip)), bitFlip);
                return result;
            }

            static Int16 MaxSigned(Int16 a, Int16 b)
            {
                Int16 result;
                result.m_value = _mm_max_epi16(a.m_value, b.m_value);
                return result;
            }

            static Int16 MaxU8(Int16 a, Int16 b)
            {
                Int16 result;
                result.m_value = _mm_max_epi16(a.m_value, b.m_value);
                return result;
            }

            static Float Max(Float a, Float b)
            {
                Float result;
                for (int i = 0; i < 2; i++)
                    result.m_values[i] = _mm_max_ps(a.m_values[i], b.m_values[i]);
                return result;
            }

            static Float Clamp(Float v, float min, float max)
            {
                Float result;
                for (int i = 0; i < 2; i++)
                    result.m_values[i] = _mm_max_ps(_mm_min_ps(v.m_values[i], _mm_set1_ps(max)), _mm_set1_ps(min));
                return result;
            }

            static Float Reciprocal(Float v)
            {
                Float result;
                for (int i = 0; i < 2; i++)
                    result.m_values[i] = _mm_rcp_ps(v.m_values[i]);
                return result;
            }

            static void ReadPackedInputs(const InputBlock* inputBlocks, int pxOffset, Int32& outPackedPx)
            {
                for (int i = 0; i < 4; i++)
                    reinterpret_cast<int32_t*>(&outPackedPx.m_values[0])[i] = inputBlocks[i].m_pixels[pxOffset];
                for (int i = 0; i < 4; i++)
                    reinterpret_cast<int32_t*>(&outPackedPx.m_values[1])[i] = inputBlocks[i + 4].m_pixels[pxOffset];
            }

            static void ConvertHDRInputs(const InputBlock16* inputBlocks, int pxOffset, int channel, Int16& chOut)
            {
                for (int i = 0; i < 8; i++)
                    reinterpret_cast<int16_t*>(&chOut.m_value)[i] = static_cast<int16_t>((inputBlocks[i].m_pixels[pxOffset] >> (channel * 16)) & 0xffff);
            }

            static void UnpackChannel(Int32 inputPx, int ch, Int16& chOut)
            {
                __m128i ch0 = _mm_srli_epi32(inputPx.m_values[0], ch * 8);
                __m128i ch1 = _mm_srli_epi32(inputPx.m_values[1], ch * 8);
                ch0 = _mm_and_si128(ch0, _mm_set1_epi32(0xff));
                ch1 = _mm_and_si128(ch1, _mm_set1_epi32(0xff));

                chOut.m_value = _mm_packs_epi32(ch0, ch1);
            }

            static void UnpackChannel(Int64 inputPx, int ch, Int16& chOut)
            {
                __m128i ch0 = _mm_srli_epi32(inputPx.m_values[0], ch * 8);
                __m128i ch1 = _mm_srli_epi32(inputPx.m_values[1], ch * 8);
                ch0 = _mm_and_si128(ch0, _mm_set1_epi32(0xff));
                ch1 = _mm_and_si128(ch1, _mm_set1_epi32(0xff));

                chOut.m_value = _mm_packs_epi32(ch0, ch1);
            }

            static Float MakeFloat(float v)
            {
                Float f;
                f.m_values[0] = f.m_values[1] = _mm_set1_ps(v);
                return f;
            }

            static Float MakeFloatZero()
            {
                Float f;
                f.m_values[0] = f.m_values[1] = _mm_setzero_ps();
                return f;
            }

            static Int16 MakeUInt16(uint16_t v)
            {
                Int16 result;
                result.m_value = _mm_set1_epi16(static_cast<short>(v));
                return result;
            }

            static Int16 MakeSInt16(int16_t v)
            {
                Int16 result;
                result.m_value = _mm_set1_epi16(static_cast<short>(v));
                return result;
            }

            static Int32 MakeSInt32(int32_t v)
            {
                Int32 result;
                result.m_values[0] = _mm_set1_epi32(v);
                result.m_values[1] = _mm_set1_epi32(v);
                return result;
            }

            static uint16_t ExtractUInt16(const Int16& v, int offset)
            {
                return reinterpret_cast<const uint16_t*>(&v)[offset];
            }

            static void PutUInt16(Int16 &dest, int offset, uint16_t v)
            {
                reinterpret_cast<uint16_t*>(&dest)[offset] = v;
            }

            static float ExtractFloat(const Float& v, int offset)
            {
                return reinterpret_cast<const float*>(&v)[offset];
            }

            static void PutFloat(Float &dest, int offset, float v)
            {
                reinterpret_cast<float*>(&dest)[offset] = v;
            }

            static Int16CompFlag Less(Int16 a, Int16 b)
            {
                Int16CompFlag result;
                result.m_value = _mm_cmplt_epi16(a.m_value, b.m_value);
                return result;
            }

            static Int16CompFlag LessOrEqual(Int16 a, Int16 b)
            {
                Int16CompFlag result;
                result.m_value = _mm_or_si128(_mm_cmplt_epi16(a.m_value, b.m_value), _mm_cmpeq_epi16(a.m_value, b.m_value));
                return result;
            }

            static FloatCompFlag Less(Float a, Float b)
            {
                FloatCompFlag result;
                for (int i = 0; i < 2; i++)
                    result.m_values[i] = _mm_cmplt_ps(a.m_values[i], b.m_values[i]);
                return result;
            }

            static FloatCompFlag LessOrEqual(Float a, Float b)
            {
                FloatCompFlag result;
                for (int i = 0; i < 2; i++)
                    result.m_values[i] = _mm_cmple_ps(a.m_values[i], b.m_values[i]);
                return result;
            }

            static Int16CompFlag Equal(Int16 a, Int16 b)
            {
                Int16CompFlag result;
                result.m_value = _mm_cmpeq_epi16(a.m_value, b.m_value);
                return result;
            }

            static FloatCompFlag Equal(Float a, Float b)
            {
                FloatCompFlag result;
                for (int i = 0; i < 2; i++)
                    result.m_values[i] = _mm_cmpeq_ps(a.m_values[i], b.m_values[i]);
                return result;
            }

            static Float UInt16ToFloat(Int16 v)
            {
                Float result;
                result.m_values[0] = _mm_cvtepi32_ps(_mm_unpacklo_epi16(v.m_value, _mm_setzero_si128()));
                result.m_values[1] = _mm_cvtepi32_ps(_mm_unpackhi_epi16(v.m_value, _mm_setzero_si128()));
                return result;
            }

            static Int32 UInt16ToInt32(Int16 v)
            {
                Int32 result;
                result.m_values[0] = _mm_unpacklo_epi16(v.m_value, _mm_setzero_si128());
                result.m_values[1] = _mm_unpackhi_epi16(v.m_value, _mm_setzero_si128());
                return result;
            }

            static Int32 SInt16ToInt32(Int16 v)
            {
                Int32 result;
                result.m_values[0] = _mm_srai_epi32(_mm_unpacklo_epi16(_mm_setzero_si128(), v.m_value), 16);
                result.m_values[1] = _mm_srai_epi32(_mm_unpackhi_epi16(_mm_setzero_si128(), v.m_value), 16);
                return result;
            }

            static Float SInt16ToFloat(Int16 v)
            {
                Float result;
                result.m_values[0] = _mm_cvtepi32_ps(_mm_srai_epi32(_mm_unpacklo_epi16(_mm_setzero_si128(), v.m_value), 16));
                result.m_values[1] = _mm_cvtepi32_ps(_mm_srai_epi32(_mm_unpackhi_epi16(_mm_setzero_si128(), v.m_value), 16));
                return result;
            }

            template<bool TSigned>
            static Float Int16ToFloat(Int16 v)
            {
                if (TSigned)
                    return SInt16ToFloat(v);
                else
                    return UInt16ToFloat(v);
            }

            static Int16CompFlag FloatFlagToInt16(FloatCompFlag v)
            {
                __m128i lo = _mm_castps_si128(v.m_values[0]);
                __m128i hi = _mm_castps_si128(v.m_values[1]);

                Int16CompFlag result;
                result.m_value = _mm_packs_epi32(lo, hi);
                return result;
            }

            static FloatCompFlag Int16FlagToFloat(Int16CompFlag v)
            {
                __m128i lo = _mm_unpacklo_epi16(v.m_value, v.m_value);
                __m128i hi = _mm_unpackhi_epi16(v.m_value, v.m_value);

                FloatCompFlag result;
                result.m_values[0] = _mm_castsi128_ps(lo);
                result.m_values[1] = _mm_castsi128_ps(hi);
                return result;
            }

            static Int16CompFlag AndNot(Int16CompFlag a, Int16CompFlag b)
            {
                Int16CompFlag result;
                result.m_value = _mm_andnot_si128(b.m_value, a.m_value);
                return result;
            }

            static Int16 RoundAndConvertToU16(Float v, const void*)
            {
                __m128i lo = _mm_cvttps_epi32(_mm_add_ps(v.m_values[0], _mm_set1_ps(-32768)));
                __m128i hi = _mm_cvttps_epi32(_mm_add_ps(v.m_values[1], _mm_set1_ps(-32768)));

                __m128i packed = _mm_packs_epi32(lo, hi);

                Int16 result;
                result.m_value = _mm_xor_si128(packed, _mm_set1_epi16(-32768));
                return result;
            }

            static Int16 RoundAndConvertToS16(Float v, const void*)
            {
                __m128i lo = _mm_cvttps_epi32(v.m_values[0]);
                __m128i hi = _mm_cvttps_epi32(v.m_values[1]);

                __m128i packed = _mm_packs_epi32(lo, hi);

                Int16 result;
                result.m_value = _mm_packs_epi32(lo, hi);
                return result;
            }

            static Int16 FloatToSInt16(Float v, const void*)
            {
                __m128i lo = _mm_cvttps_epi32(v.m_values[0]);
                __m128i hi = _mm_cvttps_epi32(v.m_values[1]);

                Int16 result;
                result.m_value = _mm_packs_epi32(lo, hi);
                return result;
            }

            static Int16 FloatToUInt8(Float v, const RoundTowardNearestForScope* scope)
            {
                return FloatToSInt16(v, scope);
            }

            static Float Sqrt(Float f)
            {
                Float result;
                for (int i = 0; i < 2; i++)
                    result.m_values[i] = _mm_sqrt_ps(f.m_values[i]);
                return result;
            }

            static Int16 SqDiffU8(Int16 a, Int16 b)
            {
                __m128i diff = _mm_sub_epi16(a.m_value, b.m_value);

                Int16 result;
                result.m_value = _mm_mullo_epi16(diff, diff);
                return result;
            }

            static Float SqDiffUInt16(Int16 a, Int16 b)
            {
                Float af = Int16ToFloat<false>(a);
                Float bf = Int16ToFloat<false>(b);
                Float diff = af - bf;

                return diff * diff;
            }

            static Float SqDiffSInt16(Int16 a, Int16 b)
            {
                Float af = Int16ToFloat<true>(a);
                Float bf = Int16ToFloat<true>(b);
                Float diff = af - bf;

                return diff * diff;
            }

            static Int16 UnsignedRightShift(Int16 v, int bits)
            {
                Int16 result;
                result.m_value = _mm_srli_epi16(v.m_value, bits);
                return result;
            }

            static Int32 UnsignedRightShift(Int32 v, int bits)
            {
                Int32 result;
                result.m_values[0] = _mm_srli_epi32(v.m_values[0], bits);
                result.m_values[1] = _mm_srli_epi32(v.m_values[1], bits);
                return result;
            }

            static Int16 SignedRightShift(Int16 v, int bits)
            {
                Int16 result;
                result.m_value = _mm_srai_epi16(v.m_value, bits);
                return result;
            }

            static Int32 SignedRightShift(Int32 v, int bits)
            {
                Int32 result;
                result.m_values[0] = _mm_srai_epi32(v.m_values[0], bits);
                result.m_values[1] = _mm_srai_epi32(v.m_values[1], bits);
                return result;
            }

            static Int16 TruncateInt32To16(Int32 v)
            {
                __m128i low = _mm_srai_epi32(_mm_slli_epi32(v.m_values[0], 16), 16);
                __m128i high = _mm_srai_epi32(_mm_slli_epi32(v.m_values[1], 16), 16);

                Int16 result;
                result.m_value = _mm_packs_epi32(low, high);
                return result;
            }

            static Int32 MultiplyS16(Int16 a, Int16 b)
            {
                __m128i high = _mm_mulhi_epi16(a.m_value, b.m_value);
                __m128i low = _mm_mullo_epi16(a.m_value, b.m_value);

                Int32 result;
                result.m_values[0] = _mm_unpacklo_epi16(low, high);
                result.m_values[1] = _mm_unpackhi_epi16(low, high);
                return result;
            }

            static Int32 MultiplyU16(Int16 a, Int16 b)
            {
                __m128i high = _mm_mulhi_epu16(a.m_value, b.m_value);
                __m128i low = _mm_mullo_epi16(a.m_value, b.m_value);

                Int32 result;
                result.m_values[0] = _mm_unpacklo_epi16(low, high);
                result.m_values[1] = _mm_unpackhi_epi16(low, high);
                return result;
            }

            static bool AnySet(Int16CompFlag v)
            {
                return _mm_movemask_epi8(v.m_value) != 0;
            }

            static bool AllSet(Int16CompFlag v)
            {
                return _mm_movemask_epi8(v.m_value) == 0xffff;
            }

            static bool AnySet(FloatCompFlag v)
            {
                return _mm_movemask_ps(v.m_values[0]) != 0 || _mm_movemask_ps(v.m_values[1]) != 0;
            }

            static bool AllSet(FloatCompFlag v)
            {
                return _mm_movemask_ps(v.m_values[0]) == 0xf && _mm_movemask_ps(v.m_values[1]) == 0xf;
            }
        };

 #else
        // Scalar version

        struct ParallelMath
        {
            struct RoundTowardZeroForScope
            {
            };

            struct RoundTowardNearestForScope
            {
            };

            struct RoundUpForScope
            {
            };

            static const int ParallelSize = 1;

            typedef float Float;
            typedef int16_t Int16;
            typedef int32_t Int32;
            typedef int64_t Int64;
            typedef bool Int16CompFlag;
            typedef bool Int32CompFlag;
            typedef bool FloatCompFlag;

            template<class T>
            inline static void ConditionalSet(T& dest, bool flag, const T src)
            {
                if (flag)
                    dest = src;
            }

            template<class T>
            inline static void NotConditionalSet(T& dest, bool flag, const T src)
            {
                if (!flag)
                    dest = src;
            }

            static void MakeSafeDenominator(float& v)
            {
                if (v == 0.f)
                    v = 1.0f;
            }

            template<class T>
            inline static T Select(bool flag, T a, T b)
            {
                return flag ? a : b;
            }

            template<class T>
            inline static T SelectIfNonZero(bool flag, T v)
            {
                return flag ? v : static_cast<T>(0);
            }

            template<class T>
            inline static T Min(T a, T b)
            {
                if (a < b)
                    return a;
                return b;
            }

            inline static uint16_t MinU8(uint16_t a, uint16_t b)
            {
                return Min(a, b);
            }

            inline static int16_t MinSigned(int16_t a, int16_t b)
            {
                return Min(a, b);
            }

            inline static int16_t MinUnsigned(uint16_t a, uint16_t b)
            {
                return Min(a, b);
            }

            template<class T>
            inline static T Max(T a, T b)
            {
                if (a > b)
                    return a;
                return b;
            }

            inline static int16_t MaxU8(uint16_t a, uint16_t b)
            {
                return Max(a, b);
            }

            inline static int16_t MaxSigned(int16_t a, int16_t b)
            {
                return Max(a, b);
            }

            inline static int16_t MaxUnsigned(uint16_t a, uint16_t b)
            {
                return Max(a, b);
            }

            template<class T>
            inline static T Clamp(T v, T min, T max)
            {
                return Max(Min(v, max), min);
            }

            inline static void ReadPackedInputs(const InputBlock* inputBlocks, int pxOffset, Int32& outPackedPx)
            {
                outPackedPx = inputBlocks[0].m_pixels[pxOffset];
            }

            inline static void ConvertHDRInputs(const InputBlock16* inputBlocks, int pxOffset, int channel, Int16& chOut)
            {
                chOut = (inputBlocks[0].m_pixels[pxOffset] >> (channel * 16)) & 0xffff;
            }

            inline static void UnpackChannel(Int32 inputPx, int ch, Int16& chOut)
            {
                chOut = static_cast<uint16_t>((inputPx >> (ch * 8)) & 0xff);
            }

            inline static float MakeFloat(float v)
            {
                return v;
            }

            inline static float MakeFloatZero()
            {
                return 0.f;
            }

            inline static int16_t MakeUInt16(uint16_t v)
            {
                return v;
            }

            inline static int16_t MakeSInt16(int16_t v)
            {
                return v;
            }

            inline static int32_t MakeSInt32(int32_t v)
            {
                return v;
            }

            inline static int16_t ExtractUInt16(int16_t v, int offset)
            {
                (void)offset;
                return v;
            }

            static void PutUInt16(Int16 &dest, int offset, uint16_t v)
            {
                (void)offset;
                dest = v;
            }

            inline static float ExtractFloat(float v, int offset)
            {
                (void)offset;
                return v;
            }

            inline static void PutFloat(float &dest, int offset, float v)
            {
                (void)offset;
                dest = v;
            }

            template<class T>
            inline static bool Less(T a, T b)
            {
                return a < b;
            }

            template<class T>
            inline static bool Equal(T a, T b)
            {
                return a == b;
            }

            template<class T>
            inline static bool LessOrEqual(T a, T b)
            {
                return a <= b;
            }

            inline static float UInt16ToFloat(uint16_t v)
            {
                return static_cast<float>(v);
            }

            inline static float SInt16ToFloat(int16_t v)
            {
                return static_cast<float>(v);
            }

            inline static Int16CompFlag FloatFlagToInt16(FloatCompFlag v)
            {
                return v;
            }

            inline static FloatCompFlag Int16FlagToFloat(Int16CompFlag v)
            {
                return v;
            }

            inline static bool AndNot(bool a, bool b)
            {
                return a && (!b);
            }

            static int16_t RoundAndConvertToU16(float v, const RoundTowardNearestForScope*)
            {
                return static_cast<int16_t>(floorf(v + 0.5f));
            }

            static int16_t RoundAndConvertToU16(float v, const RoundTowardZeroForScope*)
            {
                return static_cast<int16_t>(v);
            }

            static int16_t RoundAndConvertToS16(float v, const RoundTowardNearestForScope*)
            {
                return static_cast<int16_t>(floorf(v + 0.5f));
            }

            static int16_t RoundAndConvertToS16(float v, const RoundTowardZeroForScope*)
            {
                return static_cast<int16_t>(v);
            }

            static int32_t UInt16ToInt32(uint16_t v)
            {
                return v;
            }

            static int32_t SInt16ToInt32(int16_t v)
            {
                return v;
            }

            template<bool TSigned>
            static float Int16ToFloat(int16_t v)
            {
                if (TSigned)
                    return SInt16ToFloat(v);
                else
                    return UInt16ToFloat(v);
            }

            inline static uint16_t FloatToSInt16(float v, const RoundTowardNearestForScope*)
            {
                return static_cast<int16_t>(floorf(v + 0.5f));
            }

            inline static uint16_t FloatToSInt16(float v, const RoundUpForScope*)
            {
                return static_cast<int16_t>(ceilf(v));
            }

            inline static uint16_t FloatToUInt8(float v, const RoundTowardNearestForScope*)
            {
                v = floorf(v + 0.5f);
                return static_cast<uint16_t>(v);
            }

            inline static float Sqrt(float f)
            {
                return sqrtf(f);
            }

            inline static uint16_t SqDiffU8(uint16_t a, uint16_t b)
            {
                int diff = static_cast<int>(a) - static_cast<int>(b);
                return static_cast<uint16_t>(diff * diff);
            }

            inline static float SqDiffSInt16(int16_t a, int16_t b)
            {
                float diff = static_cast<float>(a) - static_cast<float>(b);
                return diff * diff;
            }

            inline static float SqDiffUInt16(uint16_t a, uint16_t b)
            {
                float diff = static_cast<float>(a) - static_cast<float>(b);
                return diff * diff;
            }

            inline static bool AnySet(bool b)
            {
                return b;
            }

            inline static bool AllSet(bool b)
            {
                return b;
            }

            inline static int16_t UnsignedRightShift(int16_t v, int bits)
            {
                uint32_t i = static_cast<uint32_t>(v) & 0xffff;
                return static_cast<int16_t>(i >> bits);
            }

            inline static int32_t UnsignedRightShift(int32_t v, int bits)
            {
                uint32_t i = static_cast<uint32_t>(v);
                return static_cast<int32_t>(i >> bits);
            }

            inline static int16_t TruncateInt32To16(int32_t v)
            {
                return static_cast<int16_t>(v & 0xffff);
            }

            inline static int32_t SignedRightShift(int32_t v, int bits)
            {
                return (v >> bits);
            }

            inline static int32_t MultiplyS16(int16_t a, int16_t b)
            {
                return a * b;
            }

            inline static int32_t MultiplyU16(uint16_t a, uint16_t b)
            {
                return a * b;
            }

            inline static float Reciprocal(float f)
            {
                return 1.0f / f;
            }

            inline static int16_t TruncateToPrecision(int16_t v, int bits, bool isSigned)
            {
                int lostBits = 16 - bits;

                if (lostBits == 0)
                    return v;

                if (isSigned)
                    return static_cast<int16_t>(static_cast<int16_t>((v << lostBits) & 0xffff) >> lostBits);
                else
                    return static_cast<int16_t>(static_cast<uint16_t>((v << lostBits) & 0xffff) >> lostBits);
            }
        };

 #endif

        struct PackingVector
        {
            uint32_t m_vector[4];
            int m_offset;

            void Init()
            {
                for (int i = 0; i < 4; i++)
                    m_vector[i] = 0;

                m_offset = 0;
            }

            inline void Pack(uint16_t value, int bits)
            {
                int vOffset = m_offset >> 5;
                int bitOffset = m_offset & 0x1f;

                m_vector[vOffset] |= (static_cast<uint32_t>(value) << bitOffset) & static_cast<uint32_t>(0xffffffff);

                int overflowBits = bitOffset + bits - 32;
                if (overflowBits > 0)
                    m_vector[vOffset + 1] |= (static_cast<uint32_t>(value) >> (bits - overflowBits));

                m_offset += bits;
            }

            inline void Flush(uint8_t* output)
            {
                assert(m_offset == 128);

                for (int v = 0; v < 4; v++)
                {
                    uint32_t chunk = m_vector[v];
                    for (int b = 0; b < 4; b++)
                        output[v * 4 + b] = static_cast<uint8_t>((chunk >> (b * 8)) & 0xff);
                }
            }
        };

        void ComputeTweakFactors2(int tweak, int range, float* outFactors)
        {
            int totalUnits = range - 1;
            int minOutsideUnits = ((tweak >> 1) & 1);
            int maxOutsideUnits = (tweak & 1);
            int insideUnits = totalUnits - minOutsideUnits - maxOutsideUnits;

            outFactors[0] = -static_cast<float>(minOutsideUnits) / static_cast<float>(insideUnits);
            outFactors[1] = static_cast<float>(maxOutsideUnits) / static_cast<float>(insideUnits) + 1.0f;
        }

        ParallelMath::Float ScaleHDRValue(ParallelMath::Float v, bool isSigned)
        {
            if (isSigned)
            {
                ParallelMath::Float offset = ParallelMath::Select(ParallelMath::Less(v, ParallelMath::MakeFloatZero()), ParallelMath::MakeFloat(-30.0f), ParallelMath::MakeFloat(30.0f));
                return (v * 32.0f + offset) / 31.0f;
            }
            else
                return (v * 64.0f + 30.0f) / 31.0f;
        }

        ParallelMath::Int16 UnscaleHDRValue(ParallelMath::Int16 v, bool isSigned)
        {
            if (isSigned)
            {
                ParallelMath::Int16CompFlag negative = ParallelMath::Less(v, ParallelMath::MakeSInt16(0));
                ParallelMath::Int16 absComp = ParallelMath::Select(negative, ParallelMath::Int16(ParallelMath::MakeSInt16(0) - v), v);
                ParallelMath::Int32 multiplied = ParallelMath::MultiplyS16(absComp, ParallelMath::MakeUInt16(31));
                ParallelMath::Int32 shifted = ParallelMath::SignedRightShift(multiplied, 5);
                ParallelMath::Int16 absCompScaled = ParallelMath::TruncateInt32To16(shifted);
                ParallelMath::Int16 signBits = ParallelMath::Select(negative, ParallelMath::MakeUInt16(0x8000), ParallelMath::MakeUInt16(0));

                return absCompScaled | signBits;
            }
            else
                return ParallelMath::TruncateInt32To16(ParallelMath::SignedRightShift(ParallelMath::MultiplyU16(v, ParallelMath::MakeUInt16(31)), 6));
        }

        void UnscaleHDREndpoints(ParallelMath::Int16 inEP[2][3], ParallelMath::Int16 outEP[2][3], bool isSigned)
        {
            for (int epi = 0; epi < 2; epi++)
                for (int ch = 0; ch < 3; ch++)
                    outEP[epi][ch] = UnscaleHDRValue(inEP[epi][ch], isSigned);
        }

        template<int TVectorSize>
        class UnfinishedEndpoints
        {
        public:
            typedef ParallelMath::Float MFloat;
            typedef ParallelMath::Int16 MInt16;

            UnfinishedEndpoints()
            {
            }

            UnfinishedEndpoints(const MFloat base[TVectorSize], const MFloat offset[TVectorSize])
            {
                for (int ch = 0; ch < TVectorSize; ch++)
                    m_base[ch] = base[ch];
                for (int ch = 0; ch < TVectorSize; ch++)
                    m_offset[ch] = offset[ch];
            }

            UnfinishedEndpoints(const UnfinishedEndpoints& other)
                : UnfinishedEndpoints(other.m_base, other.m_offset)
            {
            }

            void FinishHDRUnsigned(int tweak, int range, MInt16* outEP0, MInt16* outEP1)
            {
                ParallelMath::RoundTowardNearestForScope roundingMode;

                float tweakFactors[2];
                ComputeTweakFactors2(tweak, range, tweakFactors);

                for (int ch = 0; ch < TVectorSize; ch++)
                {
                    MInt16 channelEPs[2];
                    for (int epi = 0; epi < 2; epi++)
                    {
                        MFloat f = ParallelMath::Clamp(m_base[ch] + m_offset[ch] * tweakFactors[epi], 0.0f, 31743.0f);
                        channelEPs[epi] = ParallelMath::RoundAndConvertToU16(f, &roundingMode);
                    }

                    outEP0[ch] = channelEPs[0];
                    outEP1[ch] = channelEPs[1];
                }
            }

            void FinishHDRSigned(int tweak, int range, MInt16* outEP0, MInt16* outEP1)
            {
                ParallelMath::RoundTowardNearestForScope roundingMode;

                float tweakFactors[2];
                ComputeTweakFactors2(tweak, range, tweakFactors);

                for (int ch = 0; ch < TVectorSize; ch++)
                {
                    MInt16 channelEPs[2];
                    for (int epi = 0; epi < 2; epi++)
                    {
                        MFloat f = ParallelMath::Clamp(m_base[ch] + m_offset[ch] * tweakFactors[epi], -31743.0f, 31743.0f);
                        channelEPs[epi] = ParallelMath::RoundAndConvertToS16(f, &roundingMode);
                    }

                    outEP0[ch] = channelEPs[0];
                    outEP1[ch] = channelEPs[1];
                }
            }

            void FinishLDR(int tweak, int range, MInt16* outEP0, MInt16* outEP1)
            {
                ParallelMath::RoundTowardNearestForScope roundingMode;

                float tweakFactors[2];
                ComputeTweakFactors2(tweak, range, tweakFactors);

                for (int ch = 0; ch < TVectorSize; ch++)
                {
                    MFloat ep0f = ParallelMath::Clamp(m_base[ch] + m_offset[ch] * tweakFactors[0], 0.0f, 255.0f);
                    MFloat ep1f = ParallelMath::Clamp(m_base[ch] + m_offset[ch] * tweakFactors[1], 0.0f, 255.0f);
                    outEP0[ch] = ParallelMath::FloatToUInt8(ep0f, &roundingMode);
                    outEP1[ch] = ParallelMath::FloatToUInt8(ep1f, &roundingMode);
                }
            }

            template<int TNewVectorSize>
            UnfinishedEndpoints<TNewVectorSize> ExpandTo(float filler)
            {
                MFloat newBase[TNewVectorSize];
                MFloat newOffset[TNewVectorSize];

                for (int ch = 0; ch < TNewVectorSize && ch < TVectorSize; ch++)
                {
                    newBase[ch] = m_base[ch];
                    newOffset[ch] = m_offset[ch];
                }

                MFloat fillerV = ParallelMath::MakeFloat(filler);

                for (int ch = TVectorSize; ch < TNewVectorSize; ch++)
                {
                    newBase[ch] = fillerV;
                    newOffset[ch] = ParallelMath::MakeFloatZero();
                }

                return UnfinishedEndpoints<TNewVectorSize>(newBase, newOffset);
            }

        private:
            MFloat m_base[TVectorSize];
            MFloat m_offset[TVectorSize];
        };

        template<int TMatrixSize>
        class PackedCovarianceMatrix
        {
        public:
            // 0: xx,
            // 1: xy, yy
            // 3: xz, yz, zz 
            // 6: xw, yw, zw, ww
            // ... etc.
            static const int PyramidSize = (TMatrixSize * (TMatrixSize + 1)) / 2;

            typedef ParallelMath::Float MFloat;

            PackedCovarianceMatrix()
            {
                for (int i = 0; i < PyramidSize; i++)
                    m_values[i] = ParallelMath::MakeFloatZero();
            }

            void Add(const ParallelMath::Float vec[TMatrixSize], ParallelMath::Float weight)
            {
                int index = 0;
                for (int row = 0; row < TMatrixSize; row++)
                {
                    for (int col = 0; col <= row; col++)
                    {
                        m_values[index] = m_values[index] + vec[row] * vec[col] * weight;
                        index++;
                    }
                }
            }

            void Product(MFloat outVec[TMatrixSize], const MFloat inVec[TMatrixSize])
            {
                for (int row = 0; row < TMatrixSize; row++)
                {
                    MFloat sum = ParallelMath::MakeFloatZero();

                    int index = (row * (row + 1)) >> 1;
                    for (int col = 0; col < TMatrixSize; col++)
                    {
                        sum = sum + inVec[col] * m_values[index];
                        if (col >= row)
                            index += col + 1;
                        else
                            index++;
                    }

                    outVec[row] = sum;
                }
            }

        private:
            ParallelMath::Float m_values[PyramidSize];
        };

        static const int NumEndpointSelectorPasses = 3;

        template<int TVectorSize, int TIterationCount>
        class EndpointSelector
        {
        public:
            typedef ParallelMath::Float MFloat;

            EndpointSelector()
            {
                for (int ch = 0; ch < TVectorSize; ch++)
                {
                    m_centroid[ch] = ParallelMath::MakeFloatZero();
                    m_direction[ch] = ParallelMath::MakeFloatZero();
                }
                m_weightTotal = ParallelMath::MakeFloatZero();
                m_minDist = ParallelMath::MakeFloat(FLT_MAX);
                m_maxDist = ParallelMath::MakeFloat(-FLT_MAX);
            }

            void ContributePass(const MFloat value[TVectorSize], int pass, MFloat weight)
            {
                if (pass == 0)
                    ContributeCentroid(value, weight);
                else if (pass == 1)
                    ContributeDirection(value, weight);
                else if (pass == 2)
                    ContributeMinMax(value);
            }

            void FinishPass(int pass)
            {
                if (pass == 0)
                    FinishCentroid();
                else if (pass == 1)
                    FinishDirection();
            }

            UnfinishedEndpoints<TVectorSize> GetEndpoints(const float channelWeights[TVectorSize]) const
            {
                MFloat unweightedBase[TVectorSize];
                MFloat unweightedOffset[TVectorSize];

                for (int ch = 0; ch < TVectorSize; ch++)
                {
                    MFloat min = m_centroid[ch] + m_direction[ch] * m_minDist;
                    MFloat max = m_centroid[ch] + m_direction[ch] * m_maxDist;

                    float safeWeight = channelWeights[ch];
                    if (safeWeight == 0.f)
                        safeWeight = 1.0f;

                    unweightedBase[ch] = min / channelWeights[ch];
                    unweightedOffset[ch] = (max - min) / channelWeights[ch];
                }

                return UnfinishedEndpoints<TVectorSize>(unweightedBase, unweightedOffset);
            }

        private:
            void ContributeCentroid(const MFloat value[TVectorSize], MFloat weight)
            {
                for (int ch = 0; ch < TVectorSize; ch++)
                    m_centroid[ch] = m_centroid[ch] + value[ch] * weight;
                m_weightTotal = m_weightTotal + weight;
            }

            void FinishCentroid()
            {
                MFloat denom = m_weightTotal;
                ParallelMath::MakeSafeDenominator(denom);

                for (int ch = 0; ch < TVectorSize; ch++)
                    m_centroid[ch] = m_centroid[ch] / denom;
            }

            void ContributeDirection(const MFloat value[TVectorSize], MFloat weight)
            {
                MFloat diff[TVectorSize];
                for (int ch = 0; ch < TVectorSize; ch++)
                    diff[ch] = value[ch] - m_centroid[ch];

                m_covarianceMatrix.Add(diff, weight);
            }

            void FinishDirection()
            {
                MFloat approx[TVectorSize];
                for (int ch = 0; ch < TVectorSize; ch++)
                    approx[ch] = ParallelMath::MakeFloat(1.0f);

                for (int i = 0; i < TIterationCount; i++)
                {
                    MFloat product[TVectorSize];
                    m_covarianceMatrix.Product(product, approx);

                    MFloat largestComponent = product[0];
                    for (int ch = 1; ch < TVectorSize; ch++)
                        largestComponent = ParallelMath::Max(largestComponent, product[ch]);

                    // product = largestComponent*newApprox
                    ParallelMath::MakeSafeDenominator(largestComponent);
                    for (int ch = 0; ch < TVectorSize; ch++)
                        approx[ch] = product[ch] / largestComponent;
                }

                // Normalize
                MFloat approxLen = ParallelMath::MakeFloatZero();
                for (int ch = 0; ch < TVectorSize; ch++)
                    approxLen = approxLen + approx[ch] * approx[ch];

                approxLen = ParallelMath::Sqrt(approxLen);

                ParallelMath::MakeSafeDenominator(approxLen);

                for (int ch = 0; ch < TVectorSize; ch++)
                    m_direction[ch] = approx[ch] / approxLen;
            }

            void ContributeMinMax(const MFloat value[TVectorSize])
            {
                MFloat dist = ParallelMath::MakeFloatZero();
                for (int ch = 0; ch < TVectorSize; ch++)
                    dist = dist + m_direction[ch] * (value[ch] - m_centroid[ch]);

                m_minDist = ParallelMath::Min(m_minDist, dist);
                m_maxDist = ParallelMath::Max(m_maxDist, dist);
            }
        
            ParallelMath::Float m_centroid[TVectorSize];
            ParallelMath::Float m_direction[TVectorSize];
            PackedCovarianceMatrix<TVectorSize> m_covarianceMatrix;
            ParallelMath::Float m_weightTotal;

            ParallelMath::Float m_minDist;
            ParallelMath::Float m_maxDist;
        };

        static const ParallelMath::Int16 g_weightReciprocals[] =
        {
            ParallelMath::MakeUInt16(0),        // -1 
            ParallelMath::MakeUInt16(0),        // 0
            ParallelMath::MakeUInt16(32768),    // 1
            ParallelMath::MakeUInt16(16384),    // 2
            ParallelMath::MakeUInt16(10923),    // 3
            ParallelMath::MakeUInt16(8192),     // 4
            ParallelMath::MakeUInt16(6554),     // 5
            ParallelMath::MakeUInt16(5461),     // 6
            ParallelMath::MakeUInt16(4681),     // 7
            ParallelMath::MakeUInt16(4096),     // 8
            ParallelMath::MakeUInt16(3641),     // 9
            ParallelMath::MakeUInt16(3277),     // 10
            ParallelMath::MakeUInt16(2979),     // 11
            ParallelMath::MakeUInt16(2731),     // 12
            ParallelMath::MakeUInt16(2521),     // 13
            ParallelMath::MakeUInt16(2341),     // 14
            ParallelMath::MakeUInt16(2185),     // 15
        };

        template<int TVectorSize>
        class IndexSelector
        {
        public:
            typedef ParallelMath::Float MFloat;
            typedef ParallelMath::Int16 MInt16;
            typedef ParallelMath::Int32 MInt32;

            template<bool TSigned>
            void Init(const float channelWeights[TVectorSize], MInt16 interpolationEndPoints[2][TVectorSize], MInt16 colorSpaceEndpoints[2][TVectorSize], int range)
            {
                // In BC6H, the interpolation endpoints are higher-precision than the endpoints in color space.
                // We need to select indexes using the color-space endpoints.

                m_isUniform = true;
                for (int ch = 1; ch < TVectorSize; ch++)
                {
                    if (channelWeights[ch] != channelWeights[0])
                        m_isUniform = false;
                }

                // To work with channel weights, we need something where:
                // pxDiff = px - ep[0]
                // epDiff = ep[1] - ep[0]
                //
                // weightedEPDiff = epDiff * channelWeights
                // normalizedWeightedAxis = weightedEPDiff / len(weightedEPDiff)
                // normalizedIndex = dot(pxDiff * channelWeights, normalizedWeightedAxis) / len(weightedEPDiff)
                // index = normalizedIndex * maxValue
                //
                // Equivalent to:
                // axis = channelWeights * maxValue * epDiff * channelWeights / lenSquared(epDiff * channelWeights)
                // index = dot(axis, pxDiff)

                for (int ep = 0; ep < 2; ep++)
                    for (int ch = 0; ch < TVectorSize; ch++)
                        m_endPoint[ep][ch] = interpolationEndPoints[ep][ch];

                m_range = range;
                m_maxValue = static_cast<float>(range - 1);

                MFloat epDiffWeighted[TVectorSize];
                for (int ch = 0; ch < TVectorSize; ch++)
                {
                    m_origin[ch] = ParallelMath::Int16ToFloat<TSigned>(colorSpaceEndpoints[0][ch]);
                    m_opposingOrigin[ch] = ParallelMath::Int16ToFloat<TSigned>(colorSpaceEndpoints[1][ch]);
                    epDiffWeighted[ch] = (ParallelMath::Int16ToFloat<TSigned>(colorSpaceEndpoints[1][ch]) - m_origin[ch]) * channelWeights[ch];
                }

                MFloat lenSquared = epDiffWeighted[0] * epDiffWeighted[0];
                for (int ch = 1; ch < TVectorSize; ch++)
                    lenSquared = lenSquared + epDiffWeighted[ch] * epDiffWeighted[ch];

                ParallelMath::MakeSafeDenominator(lenSquared);

                MFloat maxValueDividedByLengthSquared = ParallelMath::MakeFloat(m_maxValue) / lenSquared;

                for (int ch = 0; ch < TVectorSize; ch++)
                    m_axis[ch] = epDiffWeighted[ch] * channelWeights[ch] * maxValueDividedByLengthSquared;
            }

            template<bool TSigned>
            void Init(const float channelWeights[TVectorSize], MInt16 endPoints[2][TVectorSize], int range)
            {
                Init<TSigned>(channelWeights, endPoints, endPoints, range);
            }

            void Reconstruct(MInt16 index, MInt16* pixel)
            {
                MInt16 weight = ParallelMath::UnsignedRightShift(index * g_weightReciprocals[m_range] + 256, 9);

                for (int ch = 0; ch < TVectorSize; ch++)
                    pixel[ch] = ParallelMath::UnsignedRightShift(((ParallelMath::MakeUInt16(64) - weight) * m_endPoint[0][ch] + weight * m_endPoint[1][ch] + ParallelMath::MakeUInt16(32)), 6);
            }

            void ReconstructHDR(MInt16 index, MInt16* pixel, bool isSigned) const
            {
                MInt16 weight = ParallelMath::UnsignedRightShift(index * g_weightReciprocals[m_range] + 256, 9);

                for (int ch = 0; ch < TVectorSize; ch++)
                {
                    MInt32 ep0, ep1;
                    if (isSigned)
                    {
                        ep0 = ParallelMath::UInt16ToInt32(m_endPoint[0][ch]);
                        ep1 = ParallelMath::UInt16ToInt32(m_endPoint[1][ch]);
                    }
                    else
                    {
                        ep0 = ParallelMath::SInt16ToInt32(m_endPoint[0][ch]);
                        ep1 = ParallelMath::SInt16ToInt32(m_endPoint[1][ch]);
                    }

                    MInt32 pixel32;
                    if (isSigned)
                        pixel32 = ParallelMath::MultiplyS16((ParallelMath::MakeUInt16(64) - weight), m_endPoint[0][ch]) + ParallelMath::MultiplyS16(weight, m_endPoint[1][ch]);
                    else
                        pixel32 = ParallelMath::MultiplyU16((ParallelMath::MakeUInt16(64) - weight), m_endPoint[0][ch]) + ParallelMath::MultiplyU16(weight, m_endPoint[1][ch]);

                    pixel32 = ParallelMath::SignedRightShift(pixel32 + ParallelMath::MakeSInt32(32), 6);

                    MInt16 pixel16 = ParallelMath::TruncateInt32To16(pixel32);

                    pixel[ch] = UnscaleHDRValue(pixel16, isSigned);
                }
            }

            MInt16 SelectIndex(const MFloat* pixel, ParallelMath::RoundTowardNearestForScope* rtn) const
            {
                MFloat dist = (pixel[0] - m_origin[0]) * m_axis[0];
                for (int ch = 1; ch < TVectorSize; ch++)
                    dist = dist + (pixel[ch] - m_origin[ch]) * m_axis[ch];

                return ParallelMath::FloatToUInt8(ParallelMath::Clamp(dist, 0.0f, m_maxValue), rtn);
            }

            MInt16 SelectIndex(const MFloat* pixel) const
            {
                ParallelMath::RoundTowardNearestForScope rtn;
                return SelectIndex(pixel, &rtn);
            }

            void Invert(ParallelMath::Int16CompFlag invert)
            {
                ParallelMath::FloatCompFlag invertFloat = ParallelMath::Int16FlagToFloat(invert);

                for (int ch = 0; ch < TVectorSize; ch++)
                {
                    MInt16 firstEP = m_endPoint[0][ch];
                    MInt16 secondEP = m_endPoint[1][ch];

                    m_endPoint[0][ch] = ParallelMath::Select(invert, secondEP, firstEP);
                    m_endPoint[1][ch] = ParallelMath::Select(invert, firstEP, secondEP);

                    MFloat origin = m_origin[ch];
                    MFloat opposingOrigin = m_opposingOrigin[ch];

                    ParallelMath::ConditionalSet(m_origin[ch], invertFloat, opposingOrigin);
                    ParallelMath::ConditionalSet(m_opposingOrigin[ch], invertFloat, origin);
                    ParallelMath::ConditionalSet(m_axis[ch], invertFloat, -m_axis[ch]);
                }
            }

        private:
            MInt16 m_endPoint[2][TVectorSize];
            MFloat m_origin[TVectorSize];
            MFloat m_opposingOrigin[TVectorSize];
            MFloat m_axis[TVectorSize];
            int m_range;
            float m_maxValue;
            bool m_isUniform;
        };

        // Solve for a, b where v = a*t + b
        // This allows endpoints to be mapped to where T=0 and T=1
        // Least squares from totals:
        // a = (tv - t*v/w)/(tt - t*t/w)
        // b = (v - a*t)/w
        template<int TVectorSize>
        class EndpointRefiner
        {
        public:
            typedef ParallelMath::Float MFloat;
            typedef ParallelMath::Int16 MInt16;

            MFloat m_tv[TVectorSize];
            MFloat m_v[TVectorSize];
            MFloat m_tt;
            MFloat m_t;
            MFloat m_w;

            float m_rcpMaxIndex;
            float m_channelWeights[TVectorSize];
            float m_rcpChannelWeights[TVectorSize];

            void Init(int indexRange, const float channelWeights[TVectorSize])
            {
                for (int ch = 0; ch < TVectorSize; ch++)
                {
                    m_tv[ch] = ParallelMath::MakeFloatZero();
                    m_v[ch] = ParallelMath::MakeFloatZero();
                }
                m_tt = ParallelMath::MakeFloatZero();
                m_t = ParallelMath::MakeFloatZero();
                m_w = ParallelMath::MakeFloatZero();

                m_rcpMaxIndex = 1.0f / static_cast<float>(indexRange - 1);

                for (int ch = 0; ch < TVectorSize; ch++)
                {
                    m_channelWeights[ch] = channelWeights[ch];
                    m_rcpChannelWeights[ch] = 1.0f;
                    if (m_channelWeights[ch] != 0.0f)
                        m_rcpChannelWeights[ch] = 1.0f / channelWeights[ch];
                }
            }

            void Contribute(const MFloat* floatPixel, MInt16 index, MFloat weight)
            {
                MFloat t = ParallelMath::UInt16ToFloat(index) * m_rcpMaxIndex;

                for (int ch = 0; ch < TVectorSize; ch++)
                {
                    MFloat v = floatPixel[ch] * (weight * m_channelWeights[ch]);

                    m_tv[ch] = m_tv[ch] + t * v;
                    m_v[ch] = m_v[ch] + v;
                }
                m_tt = m_tt + weight * t * t;
                m_t = m_t + weight * t;
                m_w = m_w + weight;
            }

            void ContributeUnweighted(const MFloat* floatPixel, MInt16 index)
            {
                MFloat t = ParallelMath::UInt16ToFloat(index) * m_rcpMaxIndex;

                for (int ch = 0; ch < TVectorSize; ch++)
                {
                    MFloat v = floatPixel[ch] * (m_channelWeights[ch]);

                    m_tv[ch] = m_tv[ch] + t * v;
                    m_v[ch] = m_v[ch] + v;
                }
                m_tt = m_tt + t * t;
                m_t = m_t + t;
                m_w = m_w + ParallelMath::MakeFloat(1.0f);
            }

            void GetRefinedEndpoints(MFloat endPoint[2][TVectorSize])
            {
                // a = (tv - t*v/w)/(tt - t*t/w)
                // b = (v - a*t)/w
                MFloat w = m_w;

                ParallelMath::MakeSafeDenominator(w);
                MFloat wRcp = ParallelMath::Reciprocal(w);

                MFloat adenom = (m_tt * m_w - m_t * m_t) * wRcp;

                ParallelMath::FloatCompFlag adenomZero = ParallelMath::Equal(adenom, ParallelMath::MakeFloatZero());
                ParallelMath::ConditionalSet(adenom, adenomZero, ParallelMath::MakeFloat(1.0f));

                for (int ch = 0; ch < TVectorSize; ch++)
                {
                    /*
                    if (adenom == 0.0)
                        p1 = p2 = er.v / er.w;
                    else
                    {
                        float4 a = (er.tv - er.t*er.v / er.w) / adenom;
                        float4 b = (er.v - a * er.t) / er.w;
                        p1 = b;
                        p2 = a + b;
                    }
                    */

                    MFloat a = (m_tv[ch] - m_t * m_v[ch] * wRcp) / adenom;
                    MFloat b = (m_v[ch] - a * m_t) * wRcp;

                    MFloat p1 = b;
                    MFloat p2 = a + b;

                    ParallelMath::ConditionalSet(p1, adenomZero, (m_v[ch] * wRcp));
                    ParallelMath::ConditionalSet(p2, adenomZero, p1);

                    // Unweight
                    float inverseWeight = m_rcpChannelWeights[ch];

                    endPoint[0][ch] = p1 * inverseWeight;
                    endPoint[1][ch] = p2 * inverseWeight;
                }
            }

            void GetRefinedEndpointsLDR(MInt16 endPoint[2][TVectorSize])
            {
                ParallelMath::RoundTowardNearestForScope roundingMode;

                MFloat floatEndPoint[2][TVectorSize];
                GetRefinedEndpoints(floatEndPoint);

                for (int epi = 0; epi < 2; epi++)
                    for (int ch = 0; ch < TVectorSize; ch++)
                        endPoint[epi][ch] = ParallelMath::FloatToUInt8(ParallelMath::Clamp(floatEndPoint[epi][ch], 0.0f, 255.0f), &roundingMode);
            }

            void GetRefinedEndpointsHDR(MInt16 endPoint[2][TVectorSize], bool isSigned)
            {
                ParallelMath::RoundTowardZeroForScope rtz;

                MFloat floatEndPoint[2][TVectorSize];
                GetRefinedEndpoints(floatEndPoint);

                for (int epi = 0; epi < 2; epi++)
                {
                    for (int ch = 0; ch < TVectorSize; ch++)
                    {
                        MFloat f = floatEndPoint[epi][ch];
                        if (isSigned)
                            endPoint[epi][ch] = ParallelMath::RoundAndConvertToS16(ParallelMath::Clamp(f, -31743.0f, 31743.0f), &rtz);
                        else
                            endPoint[epi][ch] = ParallelMath::RoundAndConvertToU16(ParallelMath::Clamp(f, 0.0f, 31743.0f), &rtz);
                    }
                }
            }
        };

        class BCCommon
        {
        public:
            typedef ParallelMath::Int16 MInt16;
            typedef ParallelMath::Int32 MInt32;
            typedef ParallelMath::Float MFloat;

            static int TweakRoundsForRange(int range)
            {
                if (range == 3)
                    return 3;
                return 4;
            }

            template<int TVectorSize>
            static MFloat ComputeErrorLDR(uint32_t flags, const MInt16 reconstructed[TVectorSize], const MInt16 original[TVectorSize], const float channelWeights[TVectorSize])
            {
                MFloat error = ParallelMath::MakeFloatZero();
                if (flags & CVTT_FLAGS_UNIFORM)
                {
                    for (int ch = 0; ch < TVectorSize; ch++)
                        error = error + ParallelMath::UInt16ToFloat(ParallelMath::SqDiffU8(reconstructed[ch], original[ch]));
                }
                else
                {
                    for (int ch = 0; ch < TVectorSize; ch++)
                        error = error + ParallelMath::UInt16ToFloat(ParallelMath::SqDiffU8(reconstructed[ch], original[ch])) * ParallelMath::MakeFloat(channelWeights[ch]);
                }

                return error;
            }

            template<int TVectorSize, bool TSigned>
            static MFloat ComputeErrorHDR(uint32_t flags, const MInt16 reconstructed[TVectorSize], const MInt16 original[TVectorSize], const float channelWeights[TVectorSize])
            {
                MFloat error = ParallelMath::MakeFloatZero();
                if (flags & CVTT_FLAGS_UNIFORM)
                {
                    for (int ch = 0; ch < TVectorSize; ch++)
                    {
                        if (TSigned)
                            error = error + ParallelMath::SqDiffSInt16(reconstructed[ch], original[ch]);
                        else
                            error = error + ParallelMath::SqDiffUInt16(reconstructed[ch], original[ch]);
                    }
                }
                else
                {
                    for (int ch = 0; ch < TVectorSize; ch++)
                    {
                        if (TSigned)
                            error = error + ParallelMath::SqDiffSInt16(reconstructed[ch], original[ch]) * ParallelMath::MakeFloat(channelWeights[ch]);
                        else
                            error = error + ParallelMath::SqDiffUInt16(reconstructed[ch], original[ch]) * ParallelMath::MakeFloat(channelWeights[ch]);
                    }
                }

                return error;
            }

            template<int TChannelCount>
            static void PreWeightPixels(MFloat preWeightedPixels[16][TChannelCount], const MInt16 pixels[16][TChannelCount], const float channelWeights[TChannelCount])
            {
                for (int px = 0; px < 16; px++)
                {
                    for (int ch = 0; ch < TChannelCount; ch++)
                        preWeightedPixels[px][ch] = ParallelMath::UInt16ToFloat(pixels[px][ch]) * channelWeights[ch];
                }
            }
        };

        class BC7Computer
        {
        public:
            static const int NumTweakRounds = 4;
            static const int NumRefineRounds = 2;

            typedef ParallelMath::Int16 MInt16;
            typedef ParallelMath::Int32 MInt32;
            typedef ParallelMath::Float MFloat;

            struct WorkInfo
            {
                MInt16 m_mode;
                MFloat m_error;
                MInt16 m_ep[3][2][4];
                MInt16 m_indexes[16];
                MInt16 m_indexes2[16];

                union
                {
                    MInt16 m_partition;
                    struct IndexSelectorAndRotation
                    {
                        MInt16 m_indexSelector;
                        MInt16 m_rotation;
                    } m_isr;
                };
            };

            static void TweakAlpha(const MInt16 original[2], int tweak, int range, MInt16 result[2])
            {
                ParallelMath::RoundTowardNearestForScope roundingMode;

                float tf[2];
                ComputeTweakFactors2(tweak, range, tf);

                MFloat base = ParallelMath::UInt16ToFloat(original[0]);
                MFloat offs = ParallelMath::UInt16ToFloat(original[1]) - base;

                result[0] = ParallelMath::FloatToUInt8(ParallelMath::Clamp(base + offs * tf[0], 0.0f, 255.0f), &roundingMode);
                result[1] = ParallelMath::FloatToUInt8(ParallelMath::Clamp(base + offs * tf[1], 0.0f, 255.0f), &roundingMode);
            }

            static void Quantize(MInt16* color, int bits, int channels)
            {
                ParallelMath::RoundTowardNearestForScope roundingMode;

                float maxColor = static_cast<float>((1 << bits) - 1);

                for (int i = 0; i < channels; i++)
                    color[i] = ParallelMath::FloatToUInt8(ParallelMath::Clamp(ParallelMath::UInt16ToFloat(color[i]) * ParallelMath::MakeFloat(1.0f / 255.0f) * maxColor, 0.f, 255.f), &roundingMode);
            }

            static void QuantizeP(MInt16* color, int bits, uint16_t p, int channels)
            {
                ParallelMath::RoundTowardNearestForScope roundingMode;

                uint16_t pShift = static_cast<uint16_t>(1 << (7 - bits));
                MInt16 pShiftV = ParallelMath::MakeUInt16(pShift);

                float maxColorF = static_cast<float>(255 - (1 << (7 - bits)));

                float maxQuantized = static_cast<float>((1 << bits) - 1);

                for (int ch = 0; ch < channels; ch++)
                {
                    MInt16 clr = color[ch];
                    if (p)
                        clr = ParallelMath::MaxU8(clr, pShiftV) - pShiftV;

                    MFloat rerangedColor = ParallelMath::UInt16ToFloat(clr) * maxQuantized / maxColorF;

                    clr = ParallelMath::FloatToUInt8(ParallelMath::Clamp(rerangedColor, 0.0f, maxQuantized), &roundingMode) << 1;
                    if (p)
                        clr = clr | ParallelMath::MakeUInt16(1);

                    color[ch] = clr;
                }
            }

            static void Unquantize(MInt16* color, int bits, int channels)
            {
                for (int ch = 0; ch < channels; ch++)
                {
                    MInt16 clr = color[ch];
                    clr = clr << (8 - bits);
                    color[ch] = clr | ParallelMath::UnsignedRightShift(clr, bits);
                }
            }

            static void CompressEndpoints0(MInt16 ep[2][4], uint16_t p[2])
            {
                for (int j = 0; j < 2; j++)
                {
                    QuantizeP(ep[j], 4, p[j], 3);
                    Unquantize(ep[j], 5, 3);
                    ep[j][3] = ParallelMath::MakeUInt16(255);
                }
            }

            static void CompressEndpoints1(MInt16 ep[2][4], uint16_t p)
            {
                for (int j = 0; j < 2; j++)
                {
                    QuantizeP(ep[j], 6, p, 3);
                    Unquantize(ep[j], 7, 3);
                    ep[j][3] = ParallelMath::MakeUInt16(255);
                }
            }

            static void CompressEndpoints2(MInt16 ep[2][4])
            {
                for (int j = 0; j < 2; j++)
                {
                    Quantize(ep[j], 5, 3);
                    Unquantize(ep[j], 5, 3);
                    ep[j][3] = ParallelMath::MakeUInt16(255);
                }
            }

            static void CompressEndpoints3(MInt16 ep[2][4], uint16_t p[2])
            {
                for (int j = 0; j < 2; j++)
                {
                    QuantizeP(ep[j], 7, p[j], 3);
                    ep[j][3] = ParallelMath::MakeUInt16(255);
                }
            }

            static void CompressEndpoints4(MInt16 epRGB[2][3], MInt16 epA[2])
            {
                for (int j = 0; j < 2; j++)
                {
                    Quantize(epRGB[j], 5, 3);
                    Unquantize(epRGB[j], 5, 3);

                    Quantize(epA + j, 6, 1);
                    Unquantize(epA + j, 6, 1);
                }
            }

            static void CompressEndpoints5(MInt16 epRGB[2][3], MInt16 epA[2])
            {
                for (int j = 0; j < 2; j++)
                {
                    Quantize(epRGB[j], 7, 3);
                    Unquantize(epRGB[j], 7, 3);
                }

                // Alpha is full precision
                (void)epA;
            }

            static void CompressEndpoints6(MInt16 ep[2][4], uint16_t p[2])
            {
                for (int j = 0; j < 2; j++)
                    QuantizeP(ep[j], 7, p[j], 4);
            }

            static void CompressEndpoints7(MInt16 ep[2][4], uint16_t p[2])
            {
                for (int j = 0; j < 2; j++)
                {
                    QuantizeP(ep[j], 5, p[j], 4);
                    Unquantize(ep[j], 6, 4);
                }
            }

            struct SinglePlaneTemporaries
            {
                UnfinishedEndpoints<3> unfinishedRGB[BC7Data::g_numShapesAll];
                UnfinishedEndpoints<4> unfinishedRGBA[BC7Data::g_numShapes12];

                MInt16 fragmentBestIndexes[BC7Data::g_numFragments];
                MInt16 shapeBestEP[BC7Data::g_maxFragmentsPerMode][2][4];
                MFloat shapeBestError[BC7Data::g_maxFragmentsPerMode];
            };

            static void TrySinglePlane(uint32_t flags, const MInt16 pixels[16][4], const MFloat floatPixels[16][4], const float channelWeights[4], WorkInfo& work)
            {
                SinglePlaneTemporaries temps;

                MInt16 maxAlpha = ParallelMath::MakeUInt16(0);
                MInt16 minAlpha = ParallelMath::MakeUInt16(255);
                for (int px = 0; px < 16; px++)
                {
                    maxAlpha = ParallelMath::MaxU8(maxAlpha, pixels[px][3]);
                    minAlpha = ParallelMath::MinU8(minAlpha, pixels[px][3]);
                }

                bool anyBlockHasAlpha = ParallelMath::AnySet(ParallelMath::Less(maxAlpha, ParallelMath::MakeUInt16(255)));

                // Try RGB modes if any block has a min alpha 251 or higher
                bool allowRGBModes = ParallelMath::AnySet(ParallelMath::Less(ParallelMath::MakeUInt16(250), minAlpha));

                // Try mode 7 if any block has alpha.
                // Mode 7 is almost never selected for RGB blocks because mode 4 has very accurate 7.7.7.1 endpoints
                // and its parity bit doesn't affect alpha, meaning mode 7 can only be better in extremely specific
                // situations, and only by at most 1 unit of error per pixel.
                bool allowMode7 = anyBlockHasAlpha;

                MFloat preWeightedPixels[16][4];

                BCCommon::PreWeightPixels<4>(preWeightedPixels, pixels, channelWeights);

                const int *rgbInitialEPCollapseList = NULL;

                // Get initial RGB endpoints
                if (allowRGBModes)
                {
                    const int *shapeList;
                    int numShapesToEvaluate;

                    if (flags & CVTT_FLAGS_BC7_USE_3SUBSETS)
                    {
                        shapeList = BC7Data::g_shapeListAll;
                        rgbInitialEPCollapseList = BC7Data::g_shapeListAll;
                        numShapesToEvaluate = BC7Data::g_numShapesAll;
                    }
                    else
                    {
                        shapeList = BC7Data::g_shapeList12;
                        rgbInitialEPCollapseList = BC7Data::g_shapeList12Collapse;
                        numShapesToEvaluate = BC7Data::g_numShapes12;
                    }

                    for (int shapeIter = 0; shapeIter < numShapesToEvaluate; shapeIter++)
                    {
                        int shape = shapeList[shapeIter];

                        int shapeStart = BC7Data::g_shapeRanges[shape][0];
                        int shapeSize = BC7Data::g_shapeRanges[shape][1];

                        EndpointSelector<3, 8> epSelector;

                        for (int epPass = 0; epPass < NumEndpointSelectorPasses; epPass++)
                        {
                            for (int spx = 0; spx < shapeSize; spx++)
                            {
                                int px = BC7Data::g_fragments[shapeStart + spx];
                                epSelector.ContributePass(preWeightedPixels[px], epPass, ParallelMath::MakeFloat(1.0f));
                            }
                            epSelector.FinishPass(epPass);
                        }
                        temps.unfinishedRGB[shapeIter] = epSelector.GetEndpoints(channelWeights);
                    }
                }

                const int *rgbaInitialEPCollapseList = BC7Data::g_shapeList12Collapse;

                // Get initial RGBA endpoints
                {
                    const int *shapeList = BC7Data::g_shapeList12;
                    int numShapesToEvaluate = BC7Data::g_numShapes12;

                    for (int shapeIter = 0; shapeIter < numShapesToEvaluate; shapeIter++)
                    {
                        int shape = shapeList[shapeIter];

                        if (anyBlockHasAlpha || !allowRGBModes)
                        {
                            int shapeStart = BC7Data::g_shapeRanges[shape][0];
                            int shapeSize = BC7Data::g_shapeRanges[shape][1];

                            EndpointSelector<4, 8> epSelector;

                            for (int epPass = 0; epPass < NumEndpointSelectorPasses; epPass++)
                            {
                                for (int spx = 0; spx < shapeSize; spx++)
                                {
                                    int px = BC7Data::g_fragments[shapeStart + spx];
                                    epSelector.ContributePass(preWeightedPixels[px], epPass, ParallelMath::MakeFloat(1.0f));
                                }
                                epSelector.FinishPass(epPass);
                            }
                            temps.unfinishedRGBA[shapeIter] = epSelector.GetEndpoints(channelWeights);
                        }
                        else
                        {
                            temps.unfinishedRGBA[shapeIter] = temps.unfinishedRGB[rgbInitialEPCollapseList[shape]].ExpandTo<4>(255);
                        }
                    }
                }

                for (uint16_t mode = 0; mode <= 7; mode++)
                {
                    if ((flags & CVTT_FLAGS_BC7_FORCE_MODE6) && mode != 6)
                        continue;

                    if (!(flags & CVTT_FLAGS_BC7_USE_3SUBSETS) && BC7Data::g_modes[mode].m_numSubsets == 3)
                        continue;

                    if (mode == 4 || mode == 5)
                        continue;

                    if (mode < 4 && !allowRGBModes)
                        continue;

                    if (mode == 7 && !allowMode7)
                        continue;

                    bool isRGB = (mode < 4);

                    unsigned int numPartitions = 1 << BC7Data::g_modes[mode].m_partitionBits;
                    int numSubsets = BC7Data::g_modes[mode].m_numSubsets;
                    int indexPrec = BC7Data::g_modes[mode].m_indexBits;

                    int parityBitMax = 1;
                    if (BC7Data::g_modes[mode].m_pBitMode == BC7Data::PBitMode_PerEndpoint)
                        parityBitMax = 4;
                    else if (BC7Data::g_modes[mode].m_pBitMode == BC7Data::PBitMode_PerSubset)
                        parityBitMax = 2;

                    int numShapes;
                    const int *shapeList;
                    const int *shapeCollapseList;

                    if (numSubsets == 1)
                    {
                        numShapes = BC7Data::g_numShapes1;
                        shapeList = BC7Data::g_shapeList1;
                        shapeCollapseList = BC7Data::g_shapeList1Collapse;
                    }
                    else if (numSubsets == 2)
                    {
                        numShapes = BC7Data::g_numShapes2;
                        shapeList = BC7Data::g_shapeList2;
                        shapeCollapseList = BC7Data::g_shapeList2Collapse;
                    }
                    else
                    {
                        assert(numSubsets == 3);
                        if (numPartitions == 16)
                        {
                            numShapes = BC7Data::g_numShapes3Short;
                            shapeList = BC7Data::g_shapeList3Short;
                            shapeCollapseList = BC7Data::g_shapeList3ShortCollapse;
                        }
                        else
                        {
                            assert(numPartitions == 64);
                            numShapes = BC7Data::g_numShapes3;
                            shapeList = BC7Data::g_shapeList3;
                            shapeCollapseList = BC7Data::g_shapeList3Collapse;
                        }
                    }

                    for (int slot = 0; slot < BC7Data::g_maxFragmentsPerMode; slot++)
                        temps.shapeBestError[slot] = ParallelMath::MakeFloat(FLT_MAX);

                    for (int shapeIter = 0; shapeIter < numShapes; shapeIter++)
                    {
                        int shape = shapeList[shapeIter];
                        int shapeStart = BC7Data::g_shapeRanges[shape][0];
                        int shapeLength = BC7Data::g_shapeRanges[shape][1];
                        int shapeCollapsedEvalIndex = shapeCollapseList[shape];

                        assert(shapeCollapsedEvalIndex >= 0);

                        for (int tweak = 0; tweak < NumTweakRounds; tweak++)
                        {
                            MInt16 baseEP[2][4];

                            if (isRGB)
                            {
                                temps.unfinishedRGB[rgbInitialEPCollapseList[shape]].FinishLDR(tweak, 1 << indexPrec, baseEP[0], baseEP[1]);
                                baseEP[0][3] = baseEP[1][3] = ParallelMath::MakeUInt16(255);
                            }
                            else
                            {
                                temps.unfinishedRGBA[rgbaInitialEPCollapseList[shape]].FinishLDR(tweak, 1 << indexPrec, baseEP[0], baseEP[1]);
                            }

                            for (int pIter = 0; pIter < parityBitMax; pIter++)
                            {
                                uint16_t p[2];
                                p[0] = (pIter & 1);
                                p[1] = ((pIter >> 1) & 1);

                                MInt16 ep[2][4];

                                for (int epi = 0; epi < 2; epi++)
                                    for (int ch = 0; ch < 4; ch++)
                                        ep[epi][ch] = baseEP[epi][ch];

                                for (int refine = 0; refine < NumRefineRounds; refine++)
                                {
                                    switch (mode)
                                    {
                                    case 0:
                                        CompressEndpoints0(ep, p);
                                        break;
                                    case 1:
                                        CompressEndpoints1(ep, p[0]);
                                        break;
                                    case 2:
                                        CompressEndpoints2(ep);
                                        break;
                                    case 3:
                                        CompressEndpoints3(ep, p);
                                        break;
                                    case 6:
                                        CompressEndpoints6(ep, p);
                                        break;
                                    case 7:
                                        CompressEndpoints7(ep, p);
                                        break;
                                    default:
                                        assert(false);
                                        break;
                                    };

                                    MFloat shapeError = ParallelMath::MakeFloatZero();

                                    IndexSelector<4> indexSelector;
                                    indexSelector.Init<false>(channelWeights, ep, 1 << indexPrec);

                                    EndpointRefiner<4> epRefiner;
                                    epRefiner.Init(1 << indexPrec, channelWeights);

                                    MInt16 indexes[16];

                                    for (int pxi = 0; pxi < shapeLength; pxi++)
                                    {
                                        int px = BC7Data::g_fragments[shapeStart + pxi];

                                        MInt16 index = indexSelector.SelectIndex(floatPixels[px]);

                                        if (refine != NumRefineRounds - 1)
                                            epRefiner.ContributeUnweighted(floatPixels[px], index);

                                        MInt16 reconstructed[4];

                                        indexSelector.Reconstruct(index, reconstructed);

                                        shapeError = shapeError + BCCommon::ComputeErrorLDR<4>(flags, reconstructed, pixels[px], channelWeights);

                                        indexes[pxi] = index;
                                    }

                                    ParallelMath::FloatCompFlag shapeErrorBetter;
                                    ParallelMath::Int16CompFlag shapeErrorBetter16;

                                    shapeErrorBetter = ParallelMath::Less(shapeError, temps.shapeBestError[shapeCollapsedEvalIndex]);
                                    shapeErrorBetter16 = ParallelMath::FloatFlagToInt16(shapeErrorBetter);

                                    if (ParallelMath::AnySet(shapeErrorBetter16))
                                    {
                                        ParallelMath::ConditionalSet(temps.shapeBestError[shapeCollapsedEvalIndex], shapeErrorBetter, shapeError);
                                        for (int epi = 0; epi < 2; epi++)
                                            for (int ch = 0; ch < 4; ch++)
                                                ParallelMath::ConditionalSet(temps.shapeBestEP[shapeCollapsedEvalIndex][epi][ch], shapeErrorBetter16, ep[epi][ch]);

                                        for (int pxi = 0; pxi < shapeLength; pxi++)
                                            ParallelMath::ConditionalSet(temps.fragmentBestIndexes[shapeStart + pxi], shapeErrorBetter16, indexes[pxi]);
                                    }

                                    if (refine != NumRefineRounds - 1)
                                        epRefiner.GetRefinedEndpointsLDR(ep);
                                } // refine
                            } // p
                        } // tweak
                    } // shapeIter

                    for (uint16_t partition = 0; partition < numPartitions; partition++)
                    {
                        const int *partitionShapes;
                        if (numSubsets == 1)
                            partitionShapes = BC7Data::g_shapes1[partition];
                        else if (numSubsets == 2)
                            partitionShapes = BC7Data::g_shapes2[partition];
                        else
                        {
                            assert(numSubsets == 3);
                            partitionShapes = BC7Data::g_shapes3[partition];
                        }

                        MFloat totalError = ParallelMath::MakeFloatZero();
                        for (int subset = 0; subset < numSubsets; subset++)
                            totalError = totalError + temps.shapeBestError[shapeCollapseList[partitionShapes[subset]]];


                        ParallelMath::FloatCompFlag errorBetter = ParallelMath::Less(totalError, work.m_error);
                        ParallelMath::Int16CompFlag errorBetter16 = ParallelMath::FloatFlagToInt16(errorBetter);

                        if (ParallelMath::AnySet(errorBetter16))
                        {
                            for (int subset = 0; subset < numSubsets; subset++)
                            {
                                int shape = partitionShapes[subset];
                                int shapeStart = BC7Data::g_shapeRanges[shape][0];
                                int shapeLength = BC7Data::g_shapeRanges[shape][1];
                                int shapeCollapsedEvalIndex = shapeCollapseList[shape];

                                for (int epi = 0; epi < 2; epi++)
                                    for (int ch = 0; ch < 4; ch++)
                                        ParallelMath::ConditionalSet(work.m_ep[subset][epi][ch], errorBetter16, temps.shapeBestEP[shapeCollapsedEvalIndex][epi][ch]);

                                for (int pxi = 0; pxi < shapeLength; pxi++)
                                {
                                    int px = BC7Data::g_fragments[shapeStart + pxi];
                                    ParallelMath::ConditionalSet(work.m_indexes[px], errorBetter16, temps.fragmentBestIndexes[shapeStart + pxi]);
                                }
                            }

                            work.m_error = ParallelMath::Min(totalError, work.m_error);
                            ParallelMath::ConditionalSet(work.m_mode, errorBetter16, ParallelMath::MakeUInt16(mode));
                            ParallelMath::ConditionalSet(work.m_partition, errorBetter16, ParallelMath::MakeUInt16(partition));
                        }
                    }
                }
            }

            static void TryDualPlane(uint32_t flags, const MInt16 pixels[16][4], const MFloat floatPixels[16][4], const float channelWeights[4], WorkInfo& work)
            {
                // TODO: These error calculations are not optimal for weight-by-alpha, but this routine needs to be mostly rewritten for that.
                // The alpha/color solutions are co-dependent in that case, but a good way to solve it would probably be to
                // solve the alpha channel first, then solve the RGB channels, which in turn breaks down into two cases:
                // - Separate alpha channel, then weighted RGB
                // - Alpha+2 other channels, then the independent channel

                if (flags & CVTT_FLAGS_BC7_FORCE_MODE6)
                    return; // Mode 6 is not a dual-plane mode, skip it

                for (uint16_t mode = 4; mode <= 5; mode++)
                {
                    for (uint16_t rotation = 0; rotation < 4; rotation++)
                    {
                        int alphaChannel = (rotation + 3) & 3;
                        int redChannel = (rotation == 1) ? 3 : 0;
                        int greenChannel = (rotation == 2) ? 3 : 1;
                        int blueChannel = (rotation == 3) ? 3 : 2;

                        MInt16 rotatedRGB[16][3];
                        MFloat floatRotatedRGB[16][3];

                        for (int px = 0; px < 16; px++)
                        {
                            rotatedRGB[px][0] = pixels[px][redChannel];
                            rotatedRGB[px][1] = pixels[px][greenChannel];
                            rotatedRGB[px][2] = pixels[px][blueChannel];

                            for (int ch = 0; ch < 3; ch++)
                                floatRotatedRGB[px][ch] = ParallelMath::UInt16ToFloat(rotatedRGB[px][ch]);
                        }

                        uint16_t maxIndexSelector = (mode == 4) ? 2 : 1;

                        float rotatedRGBWeights[3] = { channelWeights[redChannel], channelWeights[greenChannel], channelWeights[blueChannel] };
                        float rotatedAlphaWeight[1] = { channelWeights[alphaChannel] };

                        float uniformWeight[1] = { 1.0f };   // Since the alpha channel is independent, there's no need to bother with weights when doing refinement or selection, only error

                        MFloat preWeightedRotatedRGB[16][3];
                        BCCommon::PreWeightPixels<3>(preWeightedRotatedRGB, rotatedRGB, rotatedRGBWeights);

                        for (uint16_t indexSelector = 0; indexSelector < maxIndexSelector; indexSelector++)
                        {
                            EndpointSelector<3, 8> rgbSelector;

                            for (int epPass = 0; epPass < NumEndpointSelectorPasses; epPass++)
                            {
                                for (int px = 0; px < 16; px++)
                                    rgbSelector.ContributePass(preWeightedRotatedRGB[px], epPass, ParallelMath::MakeFloat(1.0f));

                                rgbSelector.FinishPass(epPass);
                            }

                            MInt16 alphaRange[2];

                            alphaRange[0] = alphaRange[1] = pixels[0][alphaChannel];
                            for (int px = 1; px < 16; px++)
                            {
                                alphaRange[0] = ParallelMath::MinU8(pixels[px][alphaChannel], alphaRange[0]);
                                alphaRange[1] = ParallelMath::MaxU8(pixels[px][alphaChannel], alphaRange[1]);
                            }

                            int rgbPrec = 0;
                            int alphaPrec = 0;

                            if (mode == 4)
                            {
                                rgbPrec = indexSelector ? 3 : 2;
                                alphaPrec = indexSelector ? 2 : 3;
                            }
                            else
                                rgbPrec = alphaPrec = 2;

                            UnfinishedEndpoints<3> unfinishedRGB = rgbSelector.GetEndpoints(rotatedRGBWeights);

                            MFloat bestRGBError = ParallelMath::MakeFloat(FLT_MAX);
                            MFloat bestAlphaError = ParallelMath::MakeFloat(FLT_MAX);

                            MInt16 bestRGBIndexes[16];
                            MInt16 bestAlphaIndexes[16];
                            MInt16 bestEP[2][4];

                            for (int px = 0; px < 16; px++)
                                bestRGBIndexes[px] = bestAlphaIndexes[px] = ParallelMath::MakeUInt16(0);

                            for (int tweak = 0; tweak < NumTweakRounds; tweak++)
                            {
                                MInt16 rgbEP[2][3];
                                MInt16 alphaEP[2];

                                unfinishedRGB.FinishLDR(tweak, 1 << rgbPrec, rgbEP[0], rgbEP[1]);

                                TweakAlpha(alphaRange, tweak, 1 << alphaPrec, alphaEP);

                                for (int refine = 0; refine < NumRefineRounds; refine++)
                                {
                                    if (mode == 4)
                                        CompressEndpoints4(rgbEP, alphaEP);
                                    else
                                        CompressEndpoints5(rgbEP, alphaEP);


                                    IndexSelector<1> alphaIndexSelector;
                                    IndexSelector<3> rgbIndexSelector;

                                    {
                                        MInt16 alphaEPTemp[2][1] = { { alphaEP[0] },{ alphaEP[1] } };
                                        alphaIndexSelector.Init<false>(uniformWeight, alphaEPTemp, 1 << alphaPrec);
                                    }
                                    rgbIndexSelector.Init<false>(rotatedRGBWeights, rgbEP, 1 << rgbPrec);

                                    EndpointRefiner<3> rgbRefiner;
                                    EndpointRefiner<1> alphaRefiner;

                                    rgbRefiner.Init(1 << rgbPrec, rotatedRGBWeights);
                                    alphaRefiner.Init(1 << alphaPrec, uniformWeight);

                                    MFloat errorRGB = ParallelMath::MakeFloatZero();
                                    MFloat errorA = ParallelMath::MakeFloatZero();

                                    MInt16 rgbIndexes[16];
                                    MInt16 alphaIndexes[16];

                                    for (int px = 0; px < 16; px++)
                                    {
                                        MInt16 rgbIndex = rgbIndexSelector.SelectIndex(floatRotatedRGB[px]);
                                        MInt16 alphaIndex = alphaIndexSelector.SelectIndex(floatPixels[px] + alphaChannel);

                                        if (refine != NumRefineRounds - 1)
                                        {
                                            rgbRefiner.ContributeUnweighted(floatRotatedRGB[px], rgbIndex);
                                            alphaRefiner.ContributeUnweighted(floatPixels[px] + alphaChannel, alphaIndex);
                                        }

                                        MInt16 reconstructedRGB[3];
                                        MInt16 reconstructedAlpha[1];

                                        rgbIndexSelector.Reconstruct(rgbIndex, reconstructedRGB);
                                        alphaIndexSelector.Reconstruct(alphaIndex, reconstructedAlpha);

                                        errorRGB = errorRGB + BCCommon::ComputeErrorLDR<3>(flags, reconstructedRGB, rotatedRGB[px], rotatedRGBWeights);

                                        errorA = errorA + BCCommon::ComputeErrorLDR<1>(flags, reconstructedAlpha, pixels[px] + alphaChannel, rotatedAlphaWeight);

                                        rgbIndexes[px] = rgbIndex;
                                        alphaIndexes[px] = alphaIndex;
                                    }

                                    ParallelMath::FloatCompFlag rgbBetter = ParallelMath::Less(errorRGB, bestRGBError);
                                    ParallelMath::FloatCompFlag alphaBetter = ParallelMath::Less(errorA, bestAlphaError);

                                    ParallelMath::Int16CompFlag rgbBetterInt16 = ParallelMath::FloatFlagToInt16(rgbBetter);
                                    ParallelMath::Int16CompFlag alphaBetterInt16 = ParallelMath::FloatFlagToInt16(alphaBetter);

                                    bestRGBError = ParallelMath::Min(errorRGB, bestRGBError);
                                    bestAlphaError = ParallelMath::Min(errorA, bestAlphaError);

                                    for (int px = 0; px < 16; px++)
                                    {
                                        ParallelMath::ConditionalSet(bestRGBIndexes[px], rgbBetterInt16, rgbIndexes[px]);
                                        ParallelMath::ConditionalSet(bestAlphaIndexes[px], alphaBetterInt16, alphaIndexes[px]);
                                    }

                                    for (int ep = 0; ep < 2; ep++)
                                    {
                                        for (int ch = 0; ch < 3; ch++)
                                            ParallelMath::ConditionalSet(bestEP[ep][ch], rgbBetterInt16, rgbEP[ep][ch]);
                                        ParallelMath::ConditionalSet(bestEP[ep][3], alphaBetterInt16, alphaEP[ep]);
                                    }

                                    if (refine != NumRefineRounds - 1)
                                    {
                                        rgbRefiner.GetRefinedEndpointsLDR(rgbEP);

                                        MInt16 alphaEPTemp[2][1];
                                        alphaRefiner.GetRefinedEndpointsLDR(alphaEPTemp);

                                        for (int i = 0; i < 2; i++)
                                            alphaEP[i] = alphaEPTemp[i][0];
                                    }
                                }	// refine
                            } // tweak

                            MFloat combinedError = bestRGBError + bestAlphaError;

                            ParallelMath::FloatCompFlag errorBetter = ParallelMath::Less(combinedError, work.m_error);
                            ParallelMath::Int16CompFlag errorBetter16 = ParallelMath::FloatFlagToInt16(errorBetter);

                            work.m_error = ParallelMath::Min(combinedError, work.m_error);

                            ParallelMath::ConditionalSet(work.m_mode, errorBetter16, ParallelMath::MakeUInt16(mode));
                            ParallelMath::ConditionalSet(work.m_isr.m_rotation, errorBetter16, ParallelMath::MakeUInt16(rotation));
                            ParallelMath::ConditionalSet(work.m_isr.m_indexSelector, errorBetter16, ParallelMath::MakeUInt16(indexSelector));

                            for (int px = 0; px < 16; px++)
                            {
                                ParallelMath::ConditionalSet(work.m_indexes[px], errorBetter16, indexSelector ? bestAlphaIndexes[px] : bestRGBIndexes[px]);
                                ParallelMath::ConditionalSet(work.m_indexes2[px], errorBetter16, indexSelector ? bestRGBIndexes[px] : bestAlphaIndexes[px]);
                            }

                            for (int ep = 0; ep < 2; ep++)
                                for (int ch = 0; ch < 4; ch++)
                                    ParallelMath::ConditionalSet(work.m_ep[0][ep][ch], errorBetter16, bestEP[ep][ch]);
                        }
                    }
                }
            }

            template<class T>
            static void Swap(T& a, T& b)
            {
                T temp = a;
                a = b;
                b = temp;
            }

            static void Pack(uint32_t flags, const InputBlock* inputs, uint8_t* packedBlocks, const float channelWeights[4])
            {
                MInt16 pixels[16][4];
                MFloat floatPixels[16][4];

                for (int px = 0; px < 16; px++)
                {
                    MInt32 packedPx;
                    ParallelMath::ReadPackedInputs(inputs, px, packedPx);

                    for (int ch = 0; ch < 4; ch++)
                        ParallelMath::UnpackChannel(packedPx, ch, pixels[px][ch]);
                }

                for (int px = 0; px < 16; px++)
                {
                    for (int ch = 0; ch < 4; ch++)
                        floatPixels[px][ch] = ParallelMath::UInt16ToFloat(pixels[px][ch]);
                }

                WorkInfo work;
                memset(&work, 0, sizeof(work));

                work.m_error = ParallelMath::MakeFloat(FLT_MAX);

                TrySinglePlane(flags, pixels, floatPixels, channelWeights, work);
                TryDualPlane(flags, pixels, floatPixels, channelWeights, work);

                for (int block = 0; block < ParallelMath::ParallelSize; block++)
                {
                    PackingVector pv;
                    pv.Init();

                    uint16_t mode = ParallelMath::ExtractUInt16(work.m_mode, block);
                    uint16_t partition = ParallelMath::ExtractUInt16(work.m_partition, block);
                    uint16_t indexSelector = ParallelMath::ExtractUInt16(work.m_isr.m_indexSelector, block);

                    const BC7Data::BC7ModeInfo& modeInfo = BC7Data::g_modes[mode];

                    uint16_t indexes[16];
                    uint16_t indexes2[16];
                    uint16_t endPoints[3][2][4];

                    for (int i = 0; i < 16; i++)
                    {
                        indexes[i] = ParallelMath::ExtractUInt16(work.m_indexes[i], block);
                        if (modeInfo.m_alphaMode == BC7Data::AlphaMode_Separate)
                            indexes2[i] = ParallelMath::ExtractUInt16(work.m_indexes2[i], block);
                    }

                    for (int subset = 0; subset < 3; subset++)
                    {
                        for (int ep = 0; ep < 2; ep++)
                        {
                            for (int ch = 0; ch < 4; ch++)
                                endPoints[subset][ep][ch] = ParallelMath::ExtractUInt16(work.m_ep[subset][ep][ch], block);
                        }
                    }

                    int fixups[3] = { 0, 0, 0 };

                    if (modeInfo.m_alphaMode == BC7Data::AlphaMode_Separate)
                    {
                        bool flipRGB = ((indexes[0] & (1 << (modeInfo.m_indexBits - 1))) != 0);
                        bool flipAlpha = ((indexes2[0] & (1 << (modeInfo.m_alphaIndexBits - 1))) != 0);

                        if (flipRGB)
                        {
                            uint16_t highIndex = (1 << modeInfo.m_indexBits) - 1;
                            for (int px = 0; px < 16; px++)
                                indexes[px] = highIndex - indexes[px];
                        }

                        if (flipAlpha)
                        {
                            uint16_t highIndex = (1 << modeInfo.m_alphaIndexBits) - 1;
                            for (int px = 0; px < 16; px++)
                                indexes2[px] = highIndex - indexes2[px];
                        }

                        if (indexSelector)
                            Swap(flipRGB, flipAlpha);

                        if (flipRGB)
                        {
                            for (int ch = 0; ch < 3; ch++)
                                Swap(endPoints[0][0][ch], endPoints[0][1][ch]);
                        }
                        if (flipAlpha)
                            Swap(endPoints[0][0][3], endPoints[0][1][3]);

                    }
                    else
                    {
                        if (modeInfo.m_numSubsets == 2)
                            fixups[1] = BC7Data::g_fixupIndexes2[partition];
                        else if (modeInfo.m_numSubsets == 3)
                        {
                            fixups[1] = BC7Data::g_fixupIndexes3[partition][0];
                            fixups[2] = BC7Data::g_fixupIndexes3[partition][1];
                        }

                        bool flip[3] = { false, false, false };
                        for (int subset = 0; subset < modeInfo.m_numSubsets; subset++)
                            flip[subset] = ((indexes[fixups[subset]] & (1 << (modeInfo.m_indexBits - 1))) != 0);

                        if (flip[0] || flip[1] || flip[2])
                        {
                            uint16_t highIndex = (1 << modeInfo.m_indexBits) - 1;
                            for (int px = 0; px < 16; px++)
                            {
                                int subset = 0;
                                if (modeInfo.m_numSubsets == 2)
                                    subset = (BC7Data::g_partitionMap[partition] >> px) & 1;
                                else if (modeInfo.m_numSubsets == 3)
                                    subset = (BC7Data::g_partitionMap2[partition] >> (px * 2)) & 3;

                                if (flip[subset])
                                    indexes[px] = highIndex - indexes[px];
                            }

                            int maxCH = (modeInfo.m_alphaMode == BC7Data::AlphaMode_Combined) ? 4 : 3;
                            for (int subset = 0; subset < modeInfo.m_numSubsets; subset++)
                            {
                                if (flip[subset])
                                    for (int ch = 0; ch < maxCH; ch++)
                                        Swap(endPoints[subset][0][ch], endPoints[subset][1][ch]);
                            }
                        }
                    }

                    pv.Pack(static_cast<uint8_t>(1 << mode), mode + 1);

                    if (modeInfo.m_partitionBits)
                        pv.Pack(partition, modeInfo.m_partitionBits);

                    if (modeInfo.m_alphaMode == BC7Data::AlphaMode_Separate)
                    {
                        uint16_t rotation = ParallelMath::ExtractUInt16(work.m_isr.m_rotation, block);
                        pv.Pack(rotation, 2);
                    }

                    if (modeInfo.m_hasIndexSelector)
                        pv.Pack(indexSelector, 1);

                    // Encode RGB
                    for (int ch = 0; ch < 3; ch++)
                    {
                        for (int subset = 0; subset < modeInfo.m_numSubsets; subset++)
                        {
                            for (int ep = 0; ep < 2; ep++)
                            {
                                uint16_t epPart = endPoints[subset][ep][ch];
                                epPart >>= (8 - modeInfo.m_rgbBits);

                                pv.Pack(epPart, modeInfo.m_rgbBits);
                            }
                        }
                    }

                    // Encode alpha
                    if (modeInfo.m_alphaMode != BC7Data::AlphaMode_None)
                    {
                        for (int subset = 0; subset < modeInfo.m_numSubsets; subset++)
                        {
                            for (int ep = 0; ep < 2; ep++)
                            {
                                uint16_t epPart = endPoints[subset][ep][3];
                                epPart >>= (8 - modeInfo.m_alphaBits);

                                pv.Pack(epPart, modeInfo.m_alphaBits);
                            }
                        }
                    }

                    // Encode parity bits
                    if (modeInfo.m_pBitMode == BC7Data::PBitMode_PerSubset)
                    {
                        for (int subset = 0; subset < modeInfo.m_numSubsets; subset++)
                        {
                            uint16_t epPart = endPoints[subset][0][0];
                            epPart >>= (7 - modeInfo.m_rgbBits);
                            epPart &= 1;

                            pv.Pack(epPart, 1);
                        }
                    }
                    else if (modeInfo.m_pBitMode == BC7Data::PBitMode_PerEndpoint)
                    {
                        for (int subset = 0; subset < modeInfo.m_numSubsets; subset++)
                        {
                            for (int ep = 0; ep < 2; ep++)
                            {
                                uint16_t epPart = endPoints[subset][ep][0];
                                epPart >>= (7 - modeInfo.m_rgbBits);
                                epPart &= 1;

                                pv.Pack(epPart, 1);
                            }
                        }
                    }

                    // Encode indexes
                    for (int px = 0; px < 16; px++)
                    {
                        int bits = modeInfo.m_indexBits;
                        if ((px == 0) || (px == fixups[1]) || (px == fixups[2]))
                            bits--;

                        pv.Pack(indexes[px], bits);
                    }

                    // Encode secondary indexes
                    if (modeInfo.m_alphaMode == BC7Data::AlphaMode_Separate)
                    {
                        for (int px = 0; px < 16; px++)
                        {
                            int bits = modeInfo.m_alphaIndexBits;
                            if (px == 0)
                                bits--;

                            pv.Pack(indexes2[px], bits);
                        }
                    }

                    pv.Flush(packedBlocks);

                    packedBlocks += 16;
                }
            }
        };

        class BC6HComputer
        {
        public:
            typedef ParallelMath::Float MFloat;
            typedef ParallelMath::Int16 MInt16;
            typedef ParallelMath::Int32 MInt32;
            typedef ParallelMath::Int64 MInt64;

            static const int NumTweakRounds = 4;
            static const int NumRefineRounds = 2;

            static MInt16 QuantizeSingleEndpointElement(const MInt16 elem, int precision, bool isSigned, const ParallelMath::RoundUpForScope* ru)
            {
                if (isSigned)
                {
                    // Expand to full range
                    ParallelMath::Int16CompFlag isNegative = ParallelMath::Less(elem, ParallelMath::MakeUInt16(0));
                    MInt16 absElem = ParallelMath::Select(isNegative, MInt16(ParallelMath::MakeSInt16(0) - elem), elem);

                    MInt16 expandedAbsElem = ParallelMath::FloatToSInt16(ParallelMath::Min(ParallelMath::SInt16ToFloat(absElem) * 32.0f / 31.0f, ParallelMath::MakeFloat(32767.0f)), ru);

                    ParallelMath::Int16 signBits = ParallelMath::Select(isNegative, ParallelMath::MakeSInt16(static_cast<uint16_t>(1 << (precision - 1))), ParallelMath::MakeSInt16(0));
                    return (signBits | ParallelMath::UnsignedRightShift(expandedAbsElem, 16 - precision));
                }
                else
                {
                    // Expand to full range
                    MInt16 expandedElem = ParallelMath::FloatToSInt16(ParallelMath::Min(ParallelMath::SInt16ToFloat(elem) * 64.0f / 31.0f, ParallelMath::MakeFloat(65535.0f)), ru);
                    return ParallelMath::UnsignedRightShift(expandedElem, 16 - precision);
                }
            }

            static void UnquantizeSingleEndpointElement(MInt16 comp, int precision, bool isSigned, MInt16 &outUnquantized, MInt16 &outUnquantizedFinished)
            {
                if (isSigned)
                {
                    MInt16 zero = ParallelMath::MakeUInt16(0);
                    MInt16 maxComp = ParallelMath::MakeSInt16(static_cast<int16_t>((1 << (precision - 1)) - 1));

                    ParallelMath::Int16CompFlag s = ParallelMath::Less(comp, zero);
                    ParallelMath::ConditionalSet(comp, s, MInt16(zero - comp));

                    if (precision < 16)
                    {
                        ParallelMath::Int16CompFlag isZero = ParallelMath::Equal(comp, zero);
                        ParallelMath::Int16CompFlag isMax = ParallelMath::LessOrEqual(maxComp, comp);

                        MInt16 unq = ParallelMath::TruncateInt32To16(ParallelMath::SignedRightShift((ParallelMath::SInt16ToInt32(comp) << 15) + ParallelMath::MakeSInt32(0x4000), precision - 1));
                        ParallelMath::ConditionalSet(unq, isZero, zero);
                        ParallelMath::ConditionalSet(unq, isMax, ParallelMath::MakeUInt16(0x7fff));

                        comp = unq;
                    }

                    outUnquantized = ParallelMath::Select(s, MInt16(zero - comp), comp);

                    comp = ParallelMath::TruncateInt32To16(ParallelMath::SignedRightShift(ParallelMath::MultiplyS16(comp, ParallelMath::MakeSInt16(31)), 5));

                    outUnquantizedFinished = ParallelMath::Select(s, MInt16(comp | ParallelMath::MakeUInt16(0x8000)), comp);
                }
                else
                {
                    if (precision < 15)
                    {
                        MInt16 zero = ParallelMath::MakeUInt16(0);
                        MInt16 maxComp = ParallelMath::MakeSInt16(static_cast<int16_t>((1 << precision) - 1));

                        ParallelMath::Int16CompFlag isZero = ParallelMath::Equal(comp, zero);
                        ParallelMath::Int16CompFlag isMax = ParallelMath::LessOrEqual(maxComp, comp);

                        MInt16 unq = ParallelMath::TruncateInt32To16(ParallelMath::UnsignedRightShift((ParallelMath::SInt16ToInt32(comp) << 16) + ParallelMath::MakeSInt32(0x8000), precision));

                        ParallelMath::ConditionalSet(unq, isZero, zero);
                        ParallelMath::ConditionalSet(unq, isMax, ParallelMath::MakeUInt16(0xffff));

                        comp = unq;
                    }

                    outUnquantized = comp;
                    outUnquantizedFinished = ParallelMath::TruncateInt32To16(ParallelMath::UnsignedRightShift(ParallelMath::MultiplyU16(comp, ParallelMath::MakeUInt16(31)), 6));
                }
            }

            static void QuantizeEndpoints(const MInt16 endPoints[2][3], const MFloat floatPixels[16][3], MInt16 quantizedEndPoints[2][3], MInt16 indexes[16], IndexSelector<3> &indexSelector, int partitionMask, int subset, int fixupIndex, int precision, bool isSigned, int indexRange, const float *channelWeights)
            {
                ParallelMath::RoundUpForScope ru;

                MInt16 unquantizedEP[2][3];
                MInt16 finishedUnquantizedEP[2][3];

                for (int epi = 0; epi < 2; epi++)
                {
                    for (int ch = 0; ch < 3; ch++)
                    {
                        MInt16 qee = QuantizeSingleEndpointElement(endPoints[epi][ch], precision, isSigned, &ru);
                        UnquantizeSingleEndpointElement(qee, precision, isSigned, unquantizedEP[epi][ch], finishedUnquantizedEP[epi][ch]);
                        quantizedEndPoints[epi][ch] = qee;
                    }
                }

                if (isSigned)
                    indexSelector.Init<true>(channelWeights, unquantizedEP, finishedUnquantizedEP, indexRange);
                else
                    indexSelector.Init<false>(channelWeights, unquantizedEP, finishedUnquantizedEP, indexRange);

                MInt16 halfRange = ParallelMath::MakeUInt16(static_cast<uint16_t>(indexRange / 2));

                MInt16 index = indexSelector.SelectIndex(floatPixels[fixupIndex]);

                ParallelMath::Int16CompFlag invert = ParallelMath::LessOrEqual(halfRange, index);

                if (ParallelMath::AnySet(invert))
                {
                    ParallelMath::ConditionalSet(index, invert, MInt16(ParallelMath::MakeUInt16(static_cast<uint16_t>(indexRange - 1)) - index));

                    indexSelector.Invert(invert);

                    for (int ch = 0; ch < 3; ch++)
                    {
                        MInt16 firstEP = quantizedEndPoints[0][ch];
                        MInt16 secondEP = quantizedEndPoints[1][ch];

                        quantizedEndPoints[0][ch] = ParallelMath::Select(invert, secondEP, firstEP);
                        quantizedEndPoints[1][ch] = ParallelMath::Select(invert, firstEP, secondEP);
                    }
                }

                indexes[fixupIndex] = index;
            }

            static void EvaluatePartitionedLegality(const MInt16 ep0[2][3], const MInt16 ep1[2][3], int aPrec, const int bPrec[3], bool isTransformed, MInt16 outEncodedEPs[2][2][3], ParallelMath::Int16CompFlag& outIsLegal)
            {
                ParallelMath::Int16CompFlag allLegal = ParallelMath::Equal(ParallelMath::MakeUInt16(0), ParallelMath::MakeUInt16(0));

                for (int ch = 0; ch < 3; ch++)
                {
                    outEncodedEPs[0][0][ch] = ep0[0][ch];
                    outEncodedEPs[0][1][ch] = ep0[1][ch];
                    outEncodedEPs[1][0][ch] = ep1[0][ch];
                    outEncodedEPs[1][1][ch] = ep1[1][ch];

                    if (isTransformed)
                    {
                        for (int subset = 0; subset < 2; subset++)
                        {
                            for (int epi = 0; epi < 2; epi++)
                            {
                                if (epi == 0 && subset == 0)
                                    continue;

                                MInt16 original = outEncodedEPs[subset][epi][ch];
                                outEncodedEPs[subset][epi][ch] = ParallelMath::TruncateToPrecision(outEncodedEPs[subset][epi][ch] - outEncodedEPs[0][0][ch], bPrec[ch], true);

                                MInt16 reconstructed = outEncodedEPs[subset][epi][ch] + outEncodedEPs[0][0][ch];
                                allLegal = allLegal & ParallelMath::Equal(reconstructed, original);
                            }
                        }
                    }

                    if (!ParallelMath::AnySet(allLegal))
                        break;
                }

                outIsLegal = allLegal;
            }

            static void EvaluateSingleLegality(const MInt16 ep[2][3], int aPrec, const int bPrec[3], bool isTransformed, MInt16 outEncodedEPs[2][3], ParallelMath::Int16CompFlag& outIsLegal)
            {
                ParallelMath::Int16CompFlag allLegal = ParallelMath::Equal(ParallelMath::MakeUInt16(0), ParallelMath::MakeUInt16(0));

                for (int ch = 0; ch < 3; ch++)
                {
                    outEncodedEPs[0][ch] = ep[0][ch];
                    outEncodedEPs[1][ch] = ep[1][ch];

                    if (isTransformed)
                    {
                        MInt16 original = outEncodedEPs[1][ch];
                        outEncodedEPs[1][ch] = ParallelMath::TruncateToPrecision(outEncodedEPs[1][ch] - outEncodedEPs[0][ch], bPrec[ch], true);

                        MInt16 reconstructed = outEncodedEPs[1][ch] + outEncodedEPs[0][ch];
                        allLegal = allLegal & ParallelMath::Equal(reconstructed, original);
                    }
                }

                outIsLegal = allLegal;
            }

            static void Pack(uint32_t flags, const InputBlock16* inputs, uint8_t* packedBlocks, const float channelWeights[4], bool isSigned)
            {
                ParallelMath::RoundTowardZeroForScope rtz;

                MInt16 pixels[16][3];
                MFloat floatPixels[16][3];

                for (int px = 0; px < 16; px++)
                {
                    for (int ch = 0; ch < 3; ch++)
                    {
                        ParallelMath::ConvertHDRInputs(inputs, px, ch, pixels[px][ch]);

                        if (isSigned)
                            floatPixels[px][ch] = ParallelMath::SInt16ToFloat(pixels[px][ch]);
                        else
                            floatPixels[px][ch] = ParallelMath::UInt16ToFloat(pixels[px][ch]);
                    }
                }

                MFloat preWeightedPixels[16][3];

                BCCommon::PreWeightPixels<3>(preWeightedPixels, pixels, channelWeights);

                MInt16 bestEndPoints[2][2][3];
                MInt16 bestIndexes[16];
                MFloat bestError = ParallelMath::MakeFloat(FLT_MAX);
                MInt16 bestMode = ParallelMath::MakeUInt16(0);
                MInt16 bestPartition = ParallelMath::MakeUInt16(0);

                for (int px = 0; px < 16; px++)
                    bestIndexes[px] = ParallelMath::MakeUInt16(0);

                for (int subset = 0; subset < 2; subset++)
                    for (int epi = 0; epi < 2; epi++)
                        for (int ch = 0; ch < 3; ch++)
                            bestEndPoints[subset][epi][ch] = ParallelMath::MakeUInt16(0);

                UnfinishedEndpoints<3> partitionedUFEP[32][2];
                UnfinishedEndpoints<3> singleUFEP;

                // Generate UFEP for partitions
                for (int p = 0; p < 32; p++)
                {
                    int partitionMask = BC7Data::g_partitionMap[p];

                    EndpointSelector<3, 8> epSelectors[2];

                    for (int pass = 0; pass < NumEndpointSelectorPasses; pass++)
                    {
                        for (int px = 0; px < 16; px++)
                        {
                            int subset = (partitionMask >> px) & 1;
                            epSelectors[subset].ContributePass(preWeightedPixels[px], pass, ParallelMath::MakeFloat(1.0f));
                        }

                        for (int subset = 0; subset < 2; subset++)
                            epSelectors[subset].FinishPass(pass);
                    }

                    for (int subset = 0; subset < 2; subset++)
                        partitionedUFEP[p][subset] = epSelectors[subset].GetEndpoints(channelWeights);
                }

                // Generate UFEP for single
                {
                    EndpointSelector<3, 8> epSelector;

                    for (int pass = 0; pass < NumEndpointSelectorPasses; pass++)
                    {
                        for (int px = 0; px < 16; px++)
                            epSelector.ContributePass(preWeightedPixels[px], pass, ParallelMath::MakeFloat(1.0f));

                        epSelector.FinishPass(pass);
                    }

                    singleUFEP = epSelector.GetEndpoints(channelWeights);
                }

                for (int partitionedInt = 0; partitionedInt < 2; partitionedInt++)
                {
                    bool partitioned = (partitionedInt == 1);

                    for (int aPrec = BC7Data::g_maxHDRPrecision; aPrec >= 0; aPrec--)
                    {
                        if (!BC7Data::g_hdrModesExistForPrecision[partitionedInt][aPrec])
                            continue;

                        int numPartitions = partitioned ? 32 : 1;
                        int numSubsets = partitioned ? 2 : 1;
                        int indexBits = partitioned ? 3 : 4;
                        int indexRange = (1 << indexBits);

                        for (int p = 0; p < numPartitions; p++)
                        {
                            int partitionMask = partitioned ? BC7Data::g_partitionMap[p] : 0;

                            const int NumMetaRounds = NumTweakRounds * NumRefineRounds;

                            MInt16 metaEndPointsQuantized[NumMetaRounds][2][2][3];
                            MInt16 metaIndexes[NumMetaRounds][16];
                            MFloat metaError[NumMetaRounds][2];

                            for (int tweak = 0; tweak < NumTweakRounds; tweak++)
                            {
                                EndpointRefiner<3> refiners[2];

                                for (int refinePass = 0; refinePass < NumRefineRounds; refinePass++)
                                {
                                    int metaRound = tweak * NumRefineRounds + refinePass;

                                    MInt16(&mrQuantizedEndPoints)[2][2][3] = metaEndPointsQuantized[metaRound];
                                    MInt16(&mrIndexes)[16] = metaIndexes[metaRound];

                                    for (int subset = 0; subset < numSubsets; subset++)
                                    {
                                        MInt16 endPointsColorSpace[2][3];

                                        if (refinePass == 0)
                                        {
                                            UnfinishedEndpoints<3> ufep = partitioned ? partitionedUFEP[p][subset] : singleUFEP;

                                            if (isSigned)
                                                ufep.FinishHDRSigned(tweak, indexRange, endPointsColorSpace[0], endPointsColorSpace[1]);
                                            else
                                                ufep.FinishHDRUnsigned(tweak, indexRange, endPointsColorSpace[0], endPointsColorSpace[1]);
                                        }
                                        else
                                            refiners[subset].GetRefinedEndpointsHDR(endPointsColorSpace, isSigned);

                                        refiners[subset].Init(indexRange, channelWeights);

                                        int fixupIndex = (subset == 0) ? 0 : BC7Data::g_fixupIndexes2[p];

                                        IndexSelector<3> indexSelector;
                                        QuantizeEndpoints(endPointsColorSpace, floatPixels, mrQuantizedEndPoints[subset], mrIndexes, indexSelector, partitionMask, subset, fixupIndex, aPrec, isSigned, indexRange, channelWeights);

                                        MFloat subsetError = ParallelMath::MakeFloatZero();

                                        {
                                            ParallelMath::RoundTowardNearestForScope rtn;
                                            for (int px = 0; px < 16; px++)
                                            {
                                                if (subset != ((partitionMask >> px) & 1))
                                                    continue;

                                                MInt16 index;
                                                if (px == fixupIndex)
                                                    index = mrIndexes[px];
                                                else
                                                {
                                                    index = indexSelector.SelectIndex(floatPixels[px], &rtn);
                                                    mrIndexes[px] = index;
                                                }

                                                MInt16 reconstructed[3];
                                                indexSelector.ReconstructHDR(mrIndexes[px], reconstructed, isSigned);

                                                if (isSigned)
                                                    subsetError = subsetError + BCCommon::ComputeErrorHDR<3, true>(flags, reconstructed, pixels[px], channelWeights);
                                                else
                                                    subsetError = subsetError + BCCommon::ComputeErrorHDR<3, false>(flags, reconstructed, pixels[px], channelWeights);

                                                if (refinePass != NumRefineRounds - 1)
                                                    refiners[subset].ContributeUnweighted(floatPixels[px], index);
                                            }
                                        }

                                        metaError[metaRound][subset] = subsetError;
                                    }
                                }
                            }

                            // Now we have a bunch of attempts, but not all of them will fit in the delta coding scheme
                            int numMeta1 = partitioned ? NumMetaRounds : 1;
                            for (int meta0 = 0; meta0 < NumMetaRounds; meta0++)
                            {
                                for (int meta1 = 0; meta1 < numMeta1; meta1++)
                                {
                                    MFloat combinedError = metaError[meta0][0];
                                    if (partitioned)
                                        combinedError = combinedError + metaError[meta1][1];

                                    ParallelMath::FloatCompFlag errorBetter = ParallelMath::Less(combinedError, bestError);
                                    if (!ParallelMath::AnySet(errorBetter))
                                        continue;

                                    ParallelMath::Int16CompFlag needsCommit = ParallelMath::FloatFlagToInt16(errorBetter);

                                    // Figure out if this is encodable
                                    for (int mode = 0; mode < BC7Data::g_numHDRModes; mode++)
                                    {
                                        const BC7Data::BC6HModeInfo &modeInfo = BC7Data::g_hdrModes[mode];

                                        if (modeInfo.m_partitioned != partitioned || modeInfo.m_aPrec != aPrec)
                                            continue;

                                        ParallelMath::Int16 encodedEPs[2][2][3];
                                        ParallelMath::Int16CompFlag isLegal;
                                        if (partitioned)
                                            EvaluatePartitionedLegality(metaEndPointsQuantized[meta0][0], metaEndPointsQuantized[meta1][1], aPrec, modeInfo.m_bPrec, modeInfo.m_transformed, encodedEPs, isLegal);
                                        else
                                            EvaluateSingleLegality(metaEndPointsQuantized[meta0][0], aPrec, modeInfo.m_bPrec, modeInfo.m_transformed, encodedEPs[0], isLegal);

                                        ParallelMath::Int16CompFlag isLegalAndBetter = (ParallelMath::FloatFlagToInt16(errorBetter) & isLegal);
                                        if (!ParallelMath::AnySet(isLegalAndBetter))
                                            continue;

                                        ParallelMath::FloatCompFlag isLegalAndBetterFloat = ParallelMath::Int16FlagToFloat(isLegalAndBetter);

                                        ParallelMath::ConditionalSet(bestError, isLegalAndBetterFloat, combinedError);
                                        ParallelMath::ConditionalSet(bestMode, isLegalAndBetter, ParallelMath::MakeUInt16(static_cast<uint16_t>(mode)));
                                        ParallelMath::ConditionalSet(bestPartition, isLegalAndBetter, ParallelMath::MakeUInt16(static_cast<uint16_t>(p)));

                                        for (int subset = 0; subset < numSubsets; subset++)
                                        {
                                            for (int epi = 0; epi < 2; epi++)
                                            {
                                                for (int ch = 0; ch < 3; ch++)
                                                    ParallelMath::ConditionalSet(bestEndPoints[subset][epi][ch], isLegalAndBetter, encodedEPs[subset][epi][ch]);
                                            }
                                        }

                                        for (int px = 0; px < 16; px++)
                                        {
                                            int subset = ((partitionMask >> px) & 1);
                                            if (subset == 0)
                                                ParallelMath::ConditionalSet(bestIndexes[px], isLegalAndBetter, metaIndexes[meta0][px]);
                                            else
                                                ParallelMath::ConditionalSet(bestIndexes[px], isLegalAndBetter, metaIndexes[meta1][px]);
                                        }

                                        needsCommit = ParallelMath::AndNot(needsCommit, isLegalAndBetter);
                                        if (!ParallelMath::AnySet(needsCommit))
                                            break;
                                    }
                                }
                            }
                        }
                    }
                }

                // At this point, everything should be set
                for (int block = 0; block < ParallelMath::ParallelSize; block++)
                {
                    uint16_t mode = ParallelMath::ExtractUInt16(bestMode, block);
                    uint16_t partition = ParallelMath::ExtractUInt16(bestPartition, block);
                    int32_t eps[2][2][3];
                    uint16_t indexes[16];

                    const BC7Data::BC6HModeInfo& modeInfo = BC7Data::g_hdrModes[mode];

                    const BC6HData::ModeDescriptor* desc = BC6HData::g_modeDescriptors[mode];

                    const size_t headerBits = modeInfo.m_partitioned ? 82 : 65;

                    for (int subset = 0; subset < 2; subset++)
                    {
                        for (int epi = 0; epi < 2; epi++)
                        {
                            for (int ch = 0; ch < 3; ch++)
                                eps[subset][epi][ch] = ParallelMath::ExtractUInt16(bestEndPoints[subset][epi][ch], block);
                        }
                    }

                    for (int px = 0; px < 16; px++)
                        indexes[px] = ParallelMath::ExtractUInt16(bestIndexes[px], block);

                    uint16_t modeID = modeInfo.m_modeID;

                    PackingVector pv;
                    pv.Init();

                    for (size_t i = 0; i < headerBits; i++)
                    {
                        int32_t codedValue = 0;
                        switch (desc[i].m_eField)
                        {
                        case BC6HData::M:  codedValue = modeID; break;
                        case BC6HData::D:  codedValue = partition; break;
                        case BC6HData::RW: codedValue = eps[0][0][0]; break;
                        case BC6HData::RX: codedValue = eps[0][1][0]; break;
                        case BC6HData::RY: codedValue = eps[1][0][0]; break;
                        case BC6HData::RZ: codedValue = eps[1][1][0]; break;
                        case BC6HData::GW: codedValue = eps[0][0][1]; break;
                        case BC6HData::GX: codedValue = eps[0][1][1]; break;
                        case BC6HData::GY: codedValue = eps[1][0][1]; break;
                        case BC6HData::GZ: codedValue = eps[1][1][1]; break;
                        case BC6HData::BW: codedValue = eps[0][0][2]; break;
                        case BC6HData::BX: codedValue = eps[0][1][2]; break;
                        case BC6HData::BY: codedValue = eps[1][0][2]; break;
                        case BC6HData::BZ: codedValue = eps[1][1][2]; break;
                        default: assert(false); break;
                        }

                        pv.Pack(static_cast<uint16_t>((codedValue >> desc[i].m_uBit) & 1), 1);
                    }

                    int fixupIndex1 = 0;
                    int indexBits = 4;
                    if (modeInfo.m_partitioned)
                    {
                        fixupIndex1 = BC7Data::g_fixupIndexes2[partition];
                        indexBits = 3;
                    }

                    for (int px = 0; px < 16; px++)
                    {
                        uint16_t index = ParallelMath::ExtractUInt16(bestIndexes[px], block);
                        if (px == 0 || px == fixupIndex1)
                            pv.Pack(index, indexBits - 1);
                        else
                            pv.Pack(index, indexBits);
                    }

                    pv.Flush(packedBlocks + 16 * block);
                }
            }
        };

        class S3TCComputer
        {
        public:
            typedef ParallelMath::Float MFloat;
            typedef ParallelMath::Int16 MInt16;
            typedef ParallelMath::Int32 MInt32;

            static const int NumRGBRefineRounds = 2;
            static const int NumAlphaRefineRounds = 8;

            static void Init(MFloat& error)
            {
                error = ParallelMath::MakeFloat(FLT_MAX);
            }

            static void QuantizeTo6Bits(MInt16& v)
            {
                MInt16 reduced = ParallelMath::UnsignedRightShift(v * ParallelMath::MakeUInt16(253) + ParallelMath::MakeUInt16(512), 10);
                v = (reduced << 2) | ParallelMath::UnsignedRightShift(reduced, 4);
            }

            static void QuantizeTo5Bits(MInt16& v)
            {
                MInt16 reduced = ParallelMath::UnsignedRightShift(v * ParallelMath::MakeUInt16(249) + ParallelMath::MakeUInt16(1024), 11);
                v = (reduced << 3) | ParallelMath::UnsignedRightShift(reduced, 2);
            }

            static void QuantizeTo565(MInt16 endPoint[3])
            {
                QuantizeTo5Bits(endPoint[0]);
                QuantizeTo6Bits(endPoint[1]);
                QuantizeTo5Bits(endPoint[2]);
            }

            static void TestEndpoints(uint32_t flags, const MInt16 pixels[16][4], const MFloat floatPixels[16][4], const MInt16 unquantizedEndPoints[2][3], int range, const float* channelWeights,
                MFloat &bestError, MInt16 bestEndpoints[2][3], MInt16 bestIndexes[16], MInt16 &bestRange, EndpointRefiner<3> *refiner)
            {
                MInt16 endPoints[2][3];

                for (int ep = 0; ep < 2; ep++)
                    for (int ch = 0; ch < 3; ch++)
                        endPoints[ep][ch] = unquantizedEndPoints[ep][ch];

                QuantizeTo565(endPoints[0]);
                QuantizeTo565(endPoints[1]);

                IndexSelector<3> selector;
                selector.Init<false>(channelWeights, endPoints, range);

                MInt16 indexes[16];

                MFloat error = ParallelMath::MakeFloatZero();
                for (int px = 0; px < 16; px++)
                {
                    MInt16 index = selector.SelectIndex(floatPixels[px]);
                    indexes[px] = index;

                    if (refiner)
                        refiner->ContributeUnweighted(floatPixels[px], index);

                    MInt16 reconstructed[3];
                    selector.Reconstruct(index, reconstructed);

                    error = error + BCCommon::ComputeErrorLDR<3>(flags, reconstructed, pixels[px], channelWeights);
                }

                ParallelMath::FloatCompFlag better = ParallelMath::Less(error, bestError);

                if (ParallelMath::AnySet(better))
                {
                    ParallelMath::Int16CompFlag betterInt16 = ParallelMath::FloatFlagToInt16(better);

                    ParallelMath::ConditionalSet(bestError, better, error);

                    for (int ep = 0; ep < 2; ep++)
                        for (int ch = 0; ch < 3; ch++)
                            ParallelMath::ConditionalSet(bestEndpoints[ep][ch], betterInt16, endPoints[ep][ch]);

                    for (int px = 0; px < 16; px++)
                        ParallelMath::ConditionalSet(bestIndexes[px], betterInt16, indexes[px]);

                    ParallelMath::ConditionalSet(bestRange, betterInt16, ParallelMath::MakeUInt16(static_cast<uint16_t>(range)));
                }
            }

            static void TestCounts(uint32_t flags, const int *counts, int nCounts, MInt16 numElements, const MInt16 pixels[16][4], const MFloat floatPixels[16][4], bool alphaTest,
                const MFloat floatSortedInputs[16][4], const float *channelWeights, MFloat &bestError, MInt16 bestEndpoints[2][3], MInt16 bestIndexes[16], MInt16 &bestRange)
            {
                UNREFERENCED_PARAMETER(alphaTest);
                UNREFERENCED_PARAMETER(flags);

                EndpointRefiner<3> refiner;

                refiner.Init(nCounts, channelWeights);

                bool escape = false;
                int e = 0;
                for (int i = 0; i < nCounts; i++)
                {
                    for (int n = 0; n < counts[i]; n++)
                    {
                        ParallelMath::Int16CompFlag valid = ParallelMath::Less(ParallelMath::MakeUInt16(static_cast<uint16_t>(n)), numElements);
                        if (!ParallelMath::AnySet(valid))
                        {
                            escape = true;
                            break;
                        }

                        if (ParallelMath::AllSet(valid))
                            refiner.ContributeUnweighted(floatSortedInputs[e++], ParallelMath::MakeUInt16(static_cast<uint16_t>(i)));
                        else
                        {
                            MFloat weight = ParallelMath::Select(ParallelMath::Int16FlagToFloat(valid), ParallelMath::MakeFloat(1.0f), ParallelMath::MakeFloat(0.0f));
                            refiner.Contribute(floatSortedInputs[e++], ParallelMath::MakeUInt16(static_cast<uint16_t>(i)), weight);
                        }
                    }

                    if (escape)
                        break;
                }

                MInt16 endPoints[2][3];
                refiner.GetRefinedEndpointsLDR(endPoints);

                TestEndpoints(flags, pixels, floatPixels, endPoints, nCounts, channelWeights, bestError, bestEndpoints, bestIndexes, bestRange, nullptr);
            }

            static void PackExplicitAlpha(uint32_t flags, const InputBlock* inputs, int inputChannel, uint8_t* packedBlocks, size_t packedBlockStride)
            {
                UNREFERENCED_PARAMETER(flags);

                float weights[1] = { 1.0f };

                MInt16 pixels[16];
                MFloat floatPixels[16];

                for (int px = 0; px < 16; px++)
                {
                    MInt32 packedPx;
                    ParallelMath::ReadPackedInputs(inputs, px, packedPx);

                    ParallelMath::UnpackChannel(packedPx, inputChannel, pixels[px]);
                    floatPixels[px] = ParallelMath::UInt16ToFloat(pixels[px]);
                }

                MInt16 ep[2][1] = { { ParallelMath::MakeUInt16(0) }, { ParallelMath::MakeUInt16(255) } };

                IndexSelector<1> selector;
                selector.Init<false>(weights, ep, 16);

                MInt16 indexes[16];

                for (int px = 0; px < 16; px++)
                    indexes[px] = selector.SelectIndex(&floatPixels[px]);

                for (int block = 0; block < ParallelMath::ParallelSize; block++)
                {
                    for (int px = 0; px < 16; px += 8)
                    {
                        int index0 = ParallelMath::ExtractUInt16(indexes[px], block);
                        int index1 = ParallelMath::ExtractUInt16(indexes[px], block);

                        packedBlocks[px / 2] = static_cast<uint8_t>(index0 | (index1 << 4));
                    }

                    packedBlocks += packedBlockStride;
                }
            }

            static void PackInterpolatedAlpha(uint32_t flags, const InputBlock* inputs, int inputChannel, uint8_t* packedBlocks, size_t packedBlockStride, bool isSigned)
            {
                float weights[1] = { 1.0f };

                MInt16 pixels[16];
                MFloat floatPixels[16];

                MInt16 highTerminal = isSigned ? ParallelMath::MakeUInt16(254) : ParallelMath::MakeUInt16(255);
                MInt16 highTerminalMinusOne = highTerminal - ParallelMath::MakeUInt16(1);

                for (int px = 0; px < 16; px++)
                {
                    MInt32 packedPx;
                    ParallelMath::ReadPackedInputs(inputs, px, packedPx);

                    ParallelMath::UnpackChannel(packedPx, inputChannel, pixels[px]);

                    if (isSigned)
                        pixels[px] = ParallelMath::MinU8(pixels[px], highTerminal);

                    floatPixels[px] = ParallelMath::UInt16ToFloat(pixels[px]);
                }

                MInt16 sortedPixels[16];
                for (int px = 0; px < 16; px++)
                    sortedPixels[px] = pixels[px];

                for (int sortEnd = 15; sortEnd > 0; sortEnd--)
                {
                    for (int sortOffset = 0; sortOffset < sortEnd; sortOffset++)
                    {
                        MInt16 a = sortedPixels[sortOffset];
                        MInt16 b = sortedPixels[sortOffset + 1];

                        sortedPixels[sortOffset] = ParallelMath::MinU8(a, b);
                        sortedPixels[sortOffset + 1] = ParallelMath::MaxU8(a, b);
                    }
                }

                MInt16 zero = ParallelMath::MakeUInt16(0);
                MInt16 one = ParallelMath::MakeUInt16(1);

                MInt16 bestIsFullRange = zero;
                MFloat bestError = ParallelMath::MakeFloat(FLT_MAX);
                MInt16 bestEP[2] = { zero, zero };
                MInt16 bestIndexes[16] = {
                    zero, zero, zero, zero,
                    zero, zero, zero, zero,
                    zero, zero, zero, zero,
                    zero, zero, zero, zero
                };

                // Full-precision
                {
                    MInt16 minEP = sortedPixels[0];
                    MInt16 maxEP = sortedPixels[15];

                    MFloat base[1] = { ParallelMath::UInt16ToFloat(minEP) };
                    MFloat offset[1] = { ParallelMath::UInt16ToFloat(maxEP - minEP) };

                    UnfinishedEndpoints<1> ufep = UnfinishedEndpoints<1>(base, offset);

                    for (int tweak = 0; tweak < BCCommon::TweakRoundsForRange(8); tweak++)
                    {
                        MInt16 ep[2][1];

                        ufep.FinishLDR(tweak, 8, ep[0], ep[1]);

                        for (int refinePass = 0; refinePass < NumAlphaRefineRounds; refinePass++)
                        {
                            EndpointRefiner<1> refiner;
                            refiner.Init(8, weights);

                            if (isSigned)
                                for (int epi = 0; epi < 2; epi++)
                                    ep[epi][0] = ParallelMath::MinU8(ep[epi][0], highTerminal);

                            IndexSelector<1> indexSelector;
                            indexSelector.Init<false>(weights, ep, 8);

                            MInt16 indexes[16];
                            MFloat error = ParallelMath::MakeFloatZero();

                            for (int px = 0; px < 16; px++)
                            {
                                MInt16 index = indexSelector.SelectIndex(&floatPixels[px]);

                                MInt16 reconstructedPixel;

                                indexSelector.Reconstruct(index, &reconstructedPixel);
                                error = error + BCCommon::ComputeErrorLDR<1>(flags, &reconstructedPixel, &pixels[px], weights);

                                if (refinePass != NumAlphaRefineRounds - 1)
                                    refiner.ContributeUnweighted(&floatPixels[px], index);

                                indexes[px] = index;
                            }

                            ParallelMath::FloatCompFlag errorBetter = ParallelMath::Less(error, bestError);
                            ParallelMath::Int16CompFlag errorBetter16 = ParallelMath::FloatFlagToInt16(errorBetter);

                            if (ParallelMath::AnySet(errorBetter16))
                            {
                                bestError = ParallelMath::Min(error, bestError);
                                ParallelMath::ConditionalSet(bestIsFullRange, errorBetter16, one);
                                for (int px = 0; px < 16; px++)
                                    ParallelMath::ConditionalSet(bestIndexes[px], errorBetter16, indexes[px]);

                                for (int epi = 0; epi < 2; epi++)
                                    ParallelMath::ConditionalSet(bestEP[epi], errorBetter16, ep[epi][0]);
                            }

                            if (refinePass != NumAlphaRefineRounds - 1)
                                refiner.GetRefinedEndpointsLDR(ep);
                        }
                    }
                }

                // Reduced precision with special endpoints
                {
                    MInt16 mostAnchoredIndexes = ParallelMath::MakeUInt16(0);
                    MInt16 bestHeuristicMin = sortedPixels[0];
                    MInt16 bestHeuristicMax = sortedPixels[15];

                    ParallelMath::Int16CompFlag canTryClipping;

                    // In reduced precision, we want try putting endpoints at the reserved indexes at the ends.
                    // The heuristic we use is to assign indexes to the end as long as they aren't off by more than half of the index range.
                    // This will usually not find anything, but it's cheap to check.

                    {
                        MInt16 largestPossibleRange = bestHeuristicMax - bestHeuristicMin;
                        MInt16 lowestPossibleClearance = ParallelMath::MinU8(bestHeuristicMin, static_cast<MInt16>(highTerminal - bestHeuristicMax));

                        MInt16 lowestPossibleClearanceTimes10 = (lowestPossibleClearance << 2) + (lowestPossibleClearance << 4);
                        canTryClipping = ParallelMath::LessOrEqual(lowestPossibleClearanceTimes10, largestPossibleRange);
                    }

                    if (ParallelMath::AnySet(canTryClipping))
                    {
                        MInt16 lowClearances[16];
                        MInt16 highClearances[16];
                        MInt16 bestSkipCount = ParallelMath::MakeUInt16(0);

                        lowClearances[0] = highClearances[0] = ParallelMath::MakeUInt16(0);

                        for (int px = 1; px < 16; px++)
                        {
                            lowClearances[px] = sortedPixels[px - 1];
                            highClearances[px] = highTerminal - sortedPixels[16 - px];
                        }

                        for (uint16_t firstIndex = 0; firstIndex < 16; firstIndex++)
                        {
                            uint16_t numSkippedLow = firstIndex;

                            MInt16 lowClearance = lowClearances[firstIndex];
                            MInt16 hMin = sortedPixels[firstIndex];

                            for (uint16_t lastIndex = firstIndex; lastIndex < 16; lastIndex++)
                            {
                                uint16_t numSkippedHigh = 15 - lastIndex;
                                uint16_t numSkipped = numSkippedLow + numSkippedHigh;

                                MInt16 numSkippedV = ParallelMath::MakeUInt16(numSkipped);

                                ParallelMath::Int16CompFlag areMoreSkipped = ParallelMath::Less(bestSkipCount, numSkippedV);

                                if (!ParallelMath::AnySet(areMoreSkipped))
                                    continue;

                                MInt16 clearance = ParallelMath::MaxU8(highClearances[numSkippedHigh], lowClearance);
                                MInt16 clearanceTimes10 = (clearance << 2) + (clearance << 4);

                                MInt16 range = sortedPixels[lastIndex] - sortedPixels[firstIndex];

                                ParallelMath::Int16CompFlag isBetter = (areMoreSkipped & ParallelMath::LessOrEqual(clearanceTimes10, range));
                                ParallelMath::ConditionalSet(bestHeuristicMin, isBetter, sortedPixels[firstIndex]);
                                ParallelMath::ConditionalSet(bestHeuristicMax, isBetter, sortedPixels[lastIndex]);
                            }
                        }
                    }

                    MInt16 bestSimpleMin = one;
                    MInt16 bestSimpleMax = highTerminalMinusOne;

                    for (int px = 0; px < 16; px++)
                    {
                        ParallelMath::ConditionalSet(bestSimpleMin, ParallelMath::Less(zero, sortedPixels[15 - px]), sortedPixels[15 - px]);
                        ParallelMath::ConditionalSet(bestSimpleMax, ParallelMath::Less(sortedPixels[px], highTerminal), sortedPixels[px]);
                    }

                    MInt16 minEPs[2] = { bestSimpleMin, bestHeuristicMin };
                    MInt16 maxEPs[2] = { bestSimpleMax, bestHeuristicMax };

                    int minEPRange = 2;
                    if (ParallelMath::AllSet(ParallelMath::Equal(minEPs[0], minEPs[1])))
                        minEPRange = 1;

                    int maxEPRange = 2;
                    if (ParallelMath::AllSet(ParallelMath::Equal(maxEPs[0], maxEPs[1])))
                        maxEPRange = 1;

                    for (int minEPIndex = 0; minEPIndex < minEPRange; minEPIndex++)
                    {
                        for (int maxEPIndex = 0; maxEPIndex < maxEPRange; maxEPIndex++)
                        {
                            MFloat base[1] = { ParallelMath::UInt16ToFloat(minEPs[minEPIndex]) };
                            MFloat offset[1] = { ParallelMath::UInt16ToFloat(maxEPs[maxEPIndex] - minEPs[minEPIndex]) };

                            UnfinishedEndpoints<1> ufep = UnfinishedEndpoints<1>(base, offset);

                            for (int tweak = 0; tweak < BCCommon::TweakRoundsForRange(6); tweak++)
                            {
                                MInt16 ep[2][1];

                                ufep.FinishLDR(tweak, 8, ep[0], ep[1]);

                                for (int refinePass = 0; refinePass < NumAlphaRefineRounds; refinePass++)
                                {
                                    EndpointRefiner<1> refiner;
                                    refiner.Init(6, weights);

                                    if (isSigned)
                                        for (int epi = 0; epi < 2; epi++)
                                            ep[epi][0] = ParallelMath::MinU8(ep[epi][0], highTerminal);

                                    IndexSelector<1> indexSelector;
                                    indexSelector.Init<false>(weights, ep, 6);

                                    MInt16 indexes[16];
                                    MFloat error = ParallelMath::MakeFloatZero();

                                    for (int px = 0; px < 16; px++)
                                    {
                                        MInt16 selectedIndex = indexSelector.SelectIndex(&floatPixels[px]);

                                        MInt16 reconstructedPixel;

                                        indexSelector.Reconstruct(selectedIndex, &reconstructedPixel);

                                        MFloat zeroError = BCCommon::ComputeErrorLDR<1>(flags, &zero, &pixels[px], weights);
                                        MFloat highTerminalError = BCCommon::ComputeErrorLDR<1>(flags, &highTerminal, &pixels[px], weights);
                                        MFloat selectedIndexError = BCCommon::ComputeErrorLDR<1>(flags, &reconstructedPixel, &pixels[px], weights);

                                        MFloat bestPixelError = zeroError;
                                        MInt16 index = ParallelMath::MakeUInt16(6);

                                        ParallelMath::ConditionalSet(index, ParallelMath::FloatFlagToInt16(ParallelMath::Less(highTerminalError, bestPixelError)), ParallelMath::MakeUInt16(7));
                                        bestPixelError = ParallelMath::Min(bestPixelError, highTerminalError);

                                        ParallelMath::FloatCompFlag selectedIndexBetter = ParallelMath::Less(selectedIndexError, bestPixelError);

                                        if (ParallelMath::AllSet(selectedIndexBetter))
                                        {
                                            if (refinePass != NumAlphaRefineRounds - 1)
                                                refiner.ContributeUnweighted(&floatPixels[px], selectedIndex);
                                        }
                                        else
                                        {
                                            MFloat refineWeight = ParallelMath::Select(selectedIndexBetter, ParallelMath::MakeFloat(1.0f), ParallelMath::MakeFloatZero());

                                            if (refinePass != NumAlphaRefineRounds - 1)
                                                refiner.Contribute(&floatPixels[px], selectedIndex, refineWeight);
                                        }

                                        ParallelMath::ConditionalSet(index, ParallelMath::FloatFlagToInt16(selectedIndexBetter), selectedIndex);
                                        bestPixelError = ParallelMath::Min(bestPixelError, selectedIndexError);

                                        error = error + bestPixelError;

                                        indexes[px] = index;
                                    }

                                    ParallelMath::FloatCompFlag errorBetter = ParallelMath::Less(error, bestError);
                                    ParallelMath::Int16CompFlag errorBetter16 = ParallelMath::FloatFlagToInt16(errorBetter);

                                    if (ParallelMath::AnySet(errorBetter16))
                                    {
                                        bestError = ParallelMath::Min(error, bestError);
                                        ParallelMath::ConditionalSet(bestIsFullRange, errorBetter16, zero);
                                        for (int px = 0; px < 16; px++)
                                            ParallelMath::ConditionalSet(bestIndexes[px], errorBetter16, indexes[px]);

                                        for (int epi = 0; epi < 2; epi++)
                                            ParallelMath::ConditionalSet(bestEP[epi], errorBetter16, ep[epi][0]);
                                    }

                                    if (refinePass != NumAlphaRefineRounds - 1)
                                        refiner.GetRefinedEndpointsLDR(ep);
                                }
                            }
                        }
                    }
                }

                for (int block = 0; block < ParallelMath::ParallelSize; block++)
                {
                    int ep0 = ParallelMath::ExtractUInt16(bestEP[0], block);
                    int ep1 = ParallelMath::ExtractUInt16(bestEP[1], block);
                    int isFullRange = ParallelMath::ExtractUInt16(bestIsFullRange, block);

                    if (isSigned)
                    {
                        ep0 -= 127;
                        ep1 -= 127;

                        assert(ep0 >= -127 && ep0 <= 127);
                        assert(ep1 >= -127 && ep1 <= 127);
                    }


                    bool swapEndpoints = (isFullRange != 0) != (ep0 > ep1);

                    if (swapEndpoints)
                        std::swap(ep0, ep1);

                    uint16_t dumpBits = 0;
                    int dumpBitsOffset = 0;
                    int dumpByteOffset = 2;
                    packedBlocks[0] = static_cast<uint8_t>(ep0 & 0xff);
                    packedBlocks[1] = static_cast<uint8_t>(ep1 & 0xff);

                    int maxValue = (isFullRange != 0) ? 7 : 5;

                    for (int px = 0; px < 16; px++)
                    {
                        int index = ParallelMath::ExtractUInt16(bestIndexes[px], block);

                        if (swapEndpoints && index <= maxValue)
                            index = maxValue - index;

                        if (index != 0)
                        {
                            if (index == maxValue)
                                index = 1;
                            else if (index < maxValue)
                                index++;
                        }

                        assert(index >= 0 && index < 8);

                        dumpBits |= static_cast<uint16_t>(index << dumpBitsOffset);
                        dumpBitsOffset += 3;

                        if (dumpBitsOffset >= 8)
                        {
                            assert(dumpByteOffset < 8);
                            packedBlocks[dumpByteOffset] = static_cast<uint8_t>(dumpBits & 0xff);
                            dumpBits >>= 8;
                            dumpBitsOffset -= 8;
                            dumpByteOffset++;
                        }
                    }

                    assert(dumpBitsOffset == 0);
                    assert(dumpByteOffset == 8);

                    packedBlocks += packedBlockStride;
                }
            }

            static void PackRGB(uint32_t flags, const InputBlock* inputs, uint8_t* packedBlocks, size_t packedBlockStride, const float channelWeights[4], bool alphaTest, float alphaThreshold, bool exhaustive)
            {
                EndpointSelector<3, 8> endpointSelector;

                MInt16 pixels[16][4];
                MFloat floatPixels[16][4];

                MFloat preWeightedPixels[16][4];

                for (int px = 0; px < 16; px++)
                {
                    MInt32 packedPx;
                    ParallelMath::ReadPackedInputs(inputs, px, packedPx);

                    for (int ch = 0; ch < 4; ch++)
                        ParallelMath::UnpackChannel(packedPx, ch, pixels[px][ch]);
                }

                for (int px = 0; px < 16; px++)
                {
                    for (int ch = 0; ch < 4; ch++)
                        floatPixels[px][ch] = ParallelMath::UInt16ToFloat(pixels[px][ch]);
                }

                if (alphaTest)
                {
                    MInt16 threshold = ParallelMath::MakeUInt16(static_cast<uint16_t>(floorf(alphaThreshold * 255.0f + 0.5f)));

                    for (int px = 0; px < 16; px++)
                    {
                        ParallelMath::Int16CompFlag belowThreshold = ParallelMath::Less(pixels[px][3], threshold);
                        pixels[px][3] = ParallelMath::Select(belowThreshold, ParallelMath::MakeUInt16(0), ParallelMath::MakeUInt16(255));
                    }
                }

                BCCommon::PreWeightPixels<4>(preWeightedPixels, pixels, channelWeights);

                MInt16 minAlpha = ParallelMath::MakeUInt16(255);

                for (int px = 0; px < 16; px++)
                    minAlpha = ParallelMath::MinU8(minAlpha, pixels[px][3]);

                MFloat pixelWeights[16];
                for (int px = 0; px < 16; px++)
                {
                    pixelWeights[px] = ParallelMath::MakeFloat(1.0f);
                    if (alphaTest)
                    {
                        ParallelMath::Int16CompFlag isTransparent = ParallelMath::Less(pixels[px][3], ParallelMath::MakeUInt16(255));

                        ParallelMath::ConditionalSet(pixelWeights[px], ParallelMath::Int16FlagToFloat(isTransparent), ParallelMath::MakeFloatZero());
                    }
                }

                for (int pass = 0; pass < NumEndpointSelectorPasses; pass++)
                {
                    for (int px = 0; px < 16; px++)
                        endpointSelector.ContributePass(preWeightedPixels[px], pass, pixelWeights[px]);

                    endpointSelector.FinishPass(pass);
                }

                UnfinishedEndpoints<3> ufep = endpointSelector.GetEndpoints(channelWeights);

                MInt16 bestEndpoints[2][3];
                MInt16 bestIndexes[16];
                MInt16 bestRange = ParallelMath::MakeUInt16(0);
                MFloat bestError = ParallelMath::MakeFloat(FLT_MAX);

                for (int px = 0; px < 16; px++)
                    bestIndexes[px] = ParallelMath::MakeUInt16(0);

                for (int ep = 0; ep < 2; ep++)
                    for (int ch = 0; ch < 3; ch++)
                        bestEndpoints[ep][ch] = ParallelMath::MakeUInt16(0);

                if (exhaustive)
                {
                    MInt16 sortBins[16];

                    {
                        // Compute an 11-bit index, change it to signed, stuff it in the high bits of the sort bins,
                        // and pack the original indexes into the low bits.

                        MInt16 sortEP[2][3];
                        ufep.FinishLDR(0, 11, sortEP[0], sortEP[1]);

                        IndexSelector<3> sortSelector;
                        sortSelector.Init<false>(channelWeights, sortEP, 1 << 11);

                        for (uint16_t px = 0; px < 16; px++)
                        {
                            MInt16 sortBin = (sortSelector.SelectIndex(floatPixels[px]) << 4);

                            if (alphaTest)
                            {
                                ParallelMath::Int16CompFlag isTransparent = ParallelMath::Less(pixels[px][3], ParallelMath::MakeUInt16(255));

                                ParallelMath::ConditionalSet(sortBin, isTransparent, ParallelMath::MakeUInt16(0xfff0));
                            }

                            sortBin = sortBin + ParallelMath::MakeUInt16(px);

                            sortBins[px] = sortBin;
                        }
                    }

                    // Sort bins
                    for (int sortEnd = 1; sortEnd < 16; sortEnd++)
                    {
                        for (int sortLoc = sortEnd; sortLoc > 0; sortLoc--)
                        {
                            MInt16 a = sortBins[sortLoc];
                            MInt16 b = sortBins[sortLoc - 1];

                            sortBins[sortLoc] = ParallelMath::MaxU8(a, b);
                            sortBins[sortLoc - 1] = ParallelMath::MinU8(a, b);
                        }
                    }

                    MInt16 firstElement = ParallelMath::MakeUInt16(0);
                    for (uint16_t e = 0; e < 16; e++)
                    {
                        ParallelMath::Int16CompFlag isInvalid = ParallelMath::Less(sortBins[e], ParallelMath::MakeUInt16(0));
                        ParallelMath::ConditionalSet(firstElement, isInvalid, ParallelMath::MakeUInt16(e + 1));
                        if (!ParallelMath::AnySet(isInvalid))
                            break;
                    }

                    MInt16 numElements = ParallelMath::MakeUInt16(16) - firstElement;

                    MInt16 sortedInputs[16][4];
                    MFloat floatSortedInputs[16][4];

                    for (int e = 0; e < 16; e++)
                    {
                        for (int ch = 0; ch < 4; ch++)
                            sortedInputs[e][ch] = ParallelMath::MakeUInt16(0);
                    }

                    for (int block = 0; block < ParallelMath::ParallelSize; block++)
                    {
                        for (int e = ParallelMath::ExtractUInt16(firstElement, block); e < 16; e++)
                        {
                            uint16_t sortBin = ParallelMath::ExtractUInt16(sortBins[e], block);
                            int originalIndex = (sortBin & 15);

                            for (int ch = 0; ch < 4; ch++)
                                ParallelMath::PutUInt16(sortedInputs[15 - e][ch], block, ParallelMath::ExtractUInt16(pixels[originalIndex][ch], block));
                        }
                    }

                    for (int e = 0; e < 16; e++)
                    {
                        for (int ch = 0; ch < 4; ch++)
                            floatSortedInputs[e][ch] = ParallelMath::UInt16ToFloat(sortedInputs[e][ch]);
                    }

                    for (int n0 = 0; n0 <= 15; n0++)
                    {
                        int remainingFor1 = 16 - n0;

                        for (int n1 = 0; n1 <= remainingFor1; n1++)
                        {
                            int remainingFor2 = 16 - n1 - n0;

                            for (int n2 = 0; n2 <= remainingFor2; n2++)
                            {
                                int n3 = 16 - n2 - n1 - n0;

                                int counts[4] = { n0, n1, n2, n3 };

                                TestCounts(flags, counts, 4, numElements, pixels, floatPixels, alphaTest, floatSortedInputs, channelWeights, bestError, bestEndpoints, bestIndexes, bestRange);
                            }
                        }
                    }

                    if (alphaTest)
                    {
                        for (int n0 = 0; n0 <= 15; n0++)
                        {
                            int remainingFor1 = 16 - n0;

                            for (int n1 = 0; n1 <= remainingFor1; n1++)
                            {
                                int n2 = 16 - n1 - n0;

                                int counts[3] = { n0, n1, n2 };

                                TestCounts(flags, counts, 3, numElements, pixels, floatPixels, alphaTest, floatSortedInputs, channelWeights, bestError, bestEndpoints, bestIndexes, bestRange);
                            }
                        }
                    }
                }
                else
                {
                    int minRange = alphaTest ? 3 : 4;

                    for (int range = minRange; range <= 4; range++)
                    {
                        int tweakRounds = BCCommon::TweakRoundsForRange(range);
                        for (int tweak = 0; tweak < tweakRounds; tweak++)
                        {
                            MInt16 endPoints[2][3];

                            ufep.FinishLDR(tweak, range, endPoints[0], endPoints[1]);

                            for (int refine = 0; refine < NumRGBRefineRounds; refine++)
                            {
                                EndpointRefiner<3> refiner;
                                refiner.Init(range, channelWeights);

                                TestEndpoints(flags, pixels, floatPixels, endPoints, range, channelWeights, bestError, bestEndpoints, bestIndexes, bestRange, &refiner);

                                if (refine != NumRGBRefineRounds - 1)
                                    refiner.GetRefinedEndpointsLDR(endPoints);
                            }
                        }
                    }
                }

                for (int block = 0; block < ParallelMath::ParallelSize; block++)
                {
                    uint16_t range = ParallelMath::ExtractUInt16(bestRange, block);
                    assert(range == 3 || range == 4);

                    uint16_t compressedEP[2];
                    for (int ep = 0; ep < 2; ep++)
                    {
                        uint16_t endPoint[3];
                        for (int ch = 0; ch < 3; ch++)
                            endPoint[ch] = ParallelMath::ExtractUInt16(bestEndpoints[ep][ch], block);

                        int compressed = (endPoint[0] & 0xf8) << 8;
                        compressed |= (endPoint[1] & 0xfc) << 3;
                        compressed |= (endPoint[2] & 0xf8) >> 3;

                        compressedEP[ep] = static_cast<uint16_t>(compressed);
                    }

                    int indexOrder[4];

                    if (range == 4)
                    {
                        if (compressedEP[0] <= compressedEP[1])
                        {
                            std::swap(compressedEP[0], compressedEP[1]);
                            indexOrder[0] = 1;
                            indexOrder[1] = 3;
                            indexOrder[2] = 2;
                            indexOrder[3] = 0;
                        }
                        else
                        {
                            indexOrder[0] = 0;
                            indexOrder[1] = 2;
                            indexOrder[2] = 3;
                            indexOrder[3] = 1;
                        }
                    }
                    else
                    {
                        assert(range == 3);

                        if (compressedEP[0] > compressedEP[1])
                        {
                            std::swap(compressedEP[0], compressedEP[1]);
                            indexOrder[0] = 1;
                            indexOrder[1] = 2;
                            indexOrder[2] = 0;
                        }
                        else
                        {
                            indexOrder[0] = 0;
                            indexOrder[1] = 2;
                            indexOrder[2] = 1;
                        }
                        indexOrder[3] = 3;
                    }

                    packedBlocks[0] = static_cast<uint8_t>(compressedEP[0] & 0xff);
                    packedBlocks[1] = static_cast<uint8_t>((compressedEP[0] >> 8) & 0xff);
                    packedBlocks[2] = static_cast<uint8_t>(compressedEP[1] & 0xff);
                    packedBlocks[3] = static_cast<uint8_t>((compressedEP[1] >> 8) & 0xff);

                    for (int i = 0; i < 16; i += 4)
                    {
                        int packedIndexes = 0;
                        for (int subi = 0; subi < 4; subi++)
                        {
                            uint16_t index = ParallelMath::ExtractUInt16(bestIndexes[i + subi], block);
                            packedIndexes |= (indexOrder[index] << (subi * 2));
                        }

                        packedBlocks[4 + i / 4] = static_cast<uint8_t>(packedIndexes);
                    }

                    packedBlocks += packedBlockStride;
                }
            }
        };
    }

    static void PrepareInputBlock(InputBlock inputBlocks[NUM_PARALLEL_BLOCKS], const uint8_t *&pColor)
    {
        for (size_t block = 0; block < ParallelMath::ParallelSize; block++)
        {
            InputBlock& inputBlock = inputBlocks[block];

            for (size_t i = 0; i < NUM_PIXELS_PER_BLOCK; ++i)
            {
                int32_t packedPixel = 0;
                for (size_t ch = 0; ch < 4; ch++)
                {
					int32_t convertedValue = pColor[ch];
                    packedPixel |= (convertedValue << (ch * 8));
                }

                inputBlock.m_pixels[i] = packedPixel;
                pColor += 4;
            }
        }
    }

    static void PrepareInputBlock(InputBlock16 inputBlocks[NUM_PARALLEL_BLOCKS], const int16_t *&pColor)
    {
		for (size_t block = 0; block < ParallelMath::ParallelSize; block++)
		{
			InputBlock16& inputBlock = inputBlocks[block];

			for (size_t i = 0; i < NUM_PIXELS_PER_BLOCK; ++i)
			{
				int32_t packedPixel = 0;
				for (size_t ch = 0; ch < 4; ch++)
				{
					int32_t convertedValue = (pColor[ch] & 0xffff);
					packedPixel |= (convertedValue << (ch * 16));
				}

				inputBlock.m_pixels[i] = packedPixel;
				pColor += 4;
			}
		}
    }

    // Signed input blocks are converted into unsigned space, with the maximum value being 254
    static void PrepareSignedInputBlock(InputBlock inputBlocks[NUM_PARALLEL_BLOCKS], const int8_t *&pColor)
    {
        for (size_t block = 0; block < ParallelMath::ParallelSize; block++)
        {
            InputBlock& inputBlock = inputBlocks[block];

            for (size_t i = 0; i < NUM_PIXELS_PER_BLOCK; ++i)
            {
                int32_t packedPixel = 0;
                for (size_t ch = 0; ch < 4; ch++)
                {
					int32_t convertedValue = std::min(254, std::max(0, pColor[ch] + 127));
                    packedPixel |= (convertedValue << (ch * 8));
                }

                inputBlock.m_pixels[i] = packedPixel;
                pColor++;
            }
        }
    }

    static void FillWeights(const TexCompressOptions &options, float channelWeights[4])
    {
        if (options.flags & CVTT_FLAGS_UNIFORM)
            channelWeights[0] = channelWeights[1] = channelWeights[2] = channelWeights[3] = 1.0f;
        else
        {
            channelWeights[0] = options.redWeight;
            channelWeights[1] = options.greenWeight;
            channelWeights[2] = options.blueWeight;
            channelWeights[3] = options.alphaWeight;
        }
    }

    void EncodeBC7(uint8_t *pBC, const uint8_t *pColor, const TexCompressOptions &options)
    {
        assert(pColor);
        assert(pBC);

        for (size_t blockBase = 0; blockBase < NUM_PARALLEL_BLOCKS; blockBase += ParallelMath::ParallelSize)
        {
            InputBlock inputBlocks[NUM_PARALLEL_BLOCKS];

            PrepareInputBlock(inputBlocks, pColor);

            float channelWeights[4];
            FillWeights(options, channelWeights);

            BC7Computer::Pack(options.flags, inputBlocks, pBC, channelWeights);

            pBC += ParallelMath::ParallelSize * 16;
        }
    }

    void EncodeBC6HU(uint8_t *pBC, const int16_t *pColor, const TexCompressOptions &options)
    {
        assert(pColor);
        assert(pBC);

        for (size_t blockBase = 0; blockBase < NUM_PARALLEL_BLOCKS; blockBase += ParallelMath::ParallelSize)
        {
            InputBlock16 inputBlocks[NUM_PARALLEL_BLOCKS];

            PrepareInputBlock(inputBlocks, pColor);

            float channelWeights[4];
            FillWeights(options, channelWeights);

            BC6HComputer::Pack(options.flags, inputBlocks, pBC + (blockBase * 16), channelWeights, false);
        }
    }

    void EncodeBC6HS(uint8_t *pBC, const int16_t *pColor, const TexCompressOptions &options)
    {
        assert(pColor);
        assert(pBC);

        for (size_t blockBase = 0; blockBase < NUM_PARALLEL_BLOCKS; blockBase += ParallelMath::ParallelSize)
        {
            InputBlock16 inputBlocks[NUM_PARALLEL_BLOCKS];

            PrepareInputBlock(inputBlocks, pColor);

            float channelWeights[4];
            FillWeights(options, channelWeights);

            BC6HComputer::Pack(options.flags, inputBlocks, pBC + (blockBase * 16), channelWeights, true);
        }
    }

    void EncodeBC1(uint8_t *pBC, const uint8_t *pColor, const TexCompressOptions &options)
    {
        assert(pColor);
        assert(pBC);

        for (size_t blockBase = 0; blockBase < NUM_PARALLEL_BLOCKS; blockBase += ParallelMath::ParallelSize)
        {
            InputBlock inputBlocks[NUM_PARALLEL_BLOCKS];

            PrepareInputBlock(inputBlocks, pColor);

            float channelWeights[4];
            FillWeights(options, channelWeights);

            S3TCComputer::PackRGB(options.flags, inputBlocks, pBC, 8, channelWeights, true, options.alphaThreshold, true);

            pBC += ParallelMath::ParallelSize * 8;
        }
    }

    void EncodeBC2(uint8_t *pBC, const uint8_t *pColor, const TexCompressOptions &options)
    {
        assert(pColor);
        assert(pBC);

        for (size_t blockBase = 0; blockBase < NUM_PARALLEL_BLOCKS; blockBase += ParallelMath::ParallelSize)
        {
            InputBlock inputBlocks[NUM_PARALLEL_BLOCKS];

            PrepareInputBlock(inputBlocks, pColor);

            float channelWeights[4];
            FillWeights(options, channelWeights);

            S3TCComputer::PackRGB(options.flags, inputBlocks, pBC + 8, 16, channelWeights, false, 1.0f, true);
            S3TCComputer::PackExplicitAlpha(options.flags, inputBlocks, 3, pBC, 16);

            pBC += ParallelMath::ParallelSize * 16;
        }
    }

    void EncodeBC3(uint8_t *pBC, const uint8_t *pColor, const TexCompressOptions &options)
    {
        assert(pColor);
        assert(pBC);

        for (size_t blockBase = 0; blockBase < NUM_PARALLEL_BLOCKS; blockBase += ParallelMath::ParallelSize)
        {
            InputBlock inputBlocks[NUM_PARALLEL_BLOCKS];

            PrepareInputBlock(inputBlocks, pColor);

            float channelWeights[4];
            FillWeights(options, channelWeights);

            S3TCComputer::PackRGB(options.flags, inputBlocks, pBC + 8, 16, channelWeights, false, 1.0f, true);
            S3TCComputer::PackInterpolatedAlpha(options.flags, inputBlocks, 3, pBC, 16, false);

            pBC += ParallelMath::ParallelSize * 16;
        }
    }

    void EncodeBC4U(uint8_t *pBC, const uint8_t *pColor, const TexCompressOptions &options)
    {
        assert(pColor);
        assert(pBC);

        for (size_t blockBase = 0; blockBase < NUM_PARALLEL_BLOCKS; blockBase += ParallelMath::ParallelSize)
        {
            InputBlock inputBlocks[NUM_PARALLEL_BLOCKS];

            PrepareInputBlock(inputBlocks, pColor);

            S3TCComputer::PackInterpolatedAlpha(options.flags, inputBlocks, 0, pBC, 8, false);

            pBC += ParallelMath::ParallelSize * 8;
        }
    }

    void EncodeBC4S(uint8_t *pBC, const int8_t *pColor, const TexCompressOptions &options)
    {
        assert(pColor);
        assert(pBC);

        for (size_t blockBase = 0; blockBase < NUM_PARALLEL_BLOCKS; blockBase += ParallelMath::ParallelSize)
        {
            InputBlock inputBlocks[NUM_PARALLEL_BLOCKS];

            PrepareSignedInputBlock(inputBlocks, pColor);

            S3TCComputer::PackInterpolatedAlpha(options.flags, inputBlocks, 0, pBC, 8, true);

            pBC += ParallelMath::ParallelSize * 8;
        }
    }

    void EncodeBC5U(uint8_t *pBC, const uint8_t *pColor, const TexCompressOptions &options)
    {
        assert(pColor);
        assert(pBC);

        for (size_t blockBase = 0; blockBase < NUM_PARALLEL_BLOCKS; blockBase += ParallelMath::ParallelSize)
        {
            InputBlock inputBlocks[NUM_PARALLEL_BLOCKS];

            PrepareInputBlock(inputBlocks, pColor);

            S3TCComputer::PackInterpolatedAlpha(options.flags, inputBlocks, 0, pBC, 16, false);
            S3TCComputer::PackInterpolatedAlpha(options.flags, inputBlocks, 1, pBC + 8, 16, false);

            pBC += ParallelMath::ParallelSize * 16;
        }
    }

    void EncodeBC5S(uint8_t *pBC, const int8_t *pColor, const TexCompressOptions &options)
    {
        assert(pColor);
        assert(pBC);

        for (size_t blockBase = 0; blockBase < NUM_PARALLEL_BLOCKS; blockBase += ParallelMath::ParallelSize)
        {
            InputBlock inputBlocks[NUM_PARALLEL_BLOCKS];

            PrepareSignedInputBlock(inputBlocks, pColor);

            S3TCComputer::PackInterpolatedAlpha(options.flags, inputBlocks, 0, pBC, 16, true);
            S3TCComputer::PackInterpolatedAlpha(options.flags, inputBlocks, 1, pBC + 8, 16, true);

            pBC += ParallelMath::ParallelSize * 16;
        }
    }
}
