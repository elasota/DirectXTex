/*
    Based on codec from Convection Texture Tools
    Copyright (c) 2018 Eric Lasota

    Permission is hereby granted, free of charge, to any person obtaining
    a copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to
    permit persons to whom the Software is furnished to do so, subject
    to the following conditions:

    The above copyright notice and this permission notice shall be included
    in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

    -------------------------------------------------------------------------------------

    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the MIT License.

    http://go.microsoft.com/fwlink/?LinkId=248926
*/
#include "directxtexp.h"

#include "BC.h"

using namespace DirectX;
using namespace DirectX::PackedVector;

namespace BC7Data
{
    enum AlphaMode
    {
        AlphaMode_Combined,
        AlphaMode_Separate,
        AlphaMode_None,
    };

    enum PBitMode
    {
        PBitMode_PerEndpoint,
        PBitMode_PerSubset,
        PBitMode_None
    };

    struct BC7ModeInfo
    {
        PBitMode m_pBitMode;
        AlphaMode m_alphaMode;
        int m_rgbBits;
        int m_alphaBits;
        int m_partitionBits;
        int m_numSubsets;
        int m_indexBits;
        int m_alphaIndexBits;
        bool m_hasIndexSelector;
    };

    BC7ModeInfo g_modes[] =
    {
        { PBitMode_PerEndpoint, AlphaMode_None, 4, 0, 4, 3, 3, 0, false },     // 0
        { PBitMode_PerSubset, AlphaMode_None, 6, 0, 6, 2, 3, 0, false },       // 1
        { PBitMode_None, AlphaMode_None, 5, 0, 6, 3, 2, 0, false },            // 2
        { PBitMode_PerEndpoint, AlphaMode_None, 7, 0, 6, 2, 2, 0, false },     // 3 (Mode reference has an error, P-bit is really per-endpoint)

        { PBitMode_None, AlphaMode_Separate, 5, 6, 0, 1, 2, 3, true },         // 4
        { PBitMode_None, AlphaMode_Separate, 7, 8, 0, 1, 2, 2, false },        // 5
        { PBitMode_PerEndpoint, AlphaMode_Combined, 7, 7, 0, 1, 4, 0, false }, // 6
        { PBitMode_PerEndpoint, AlphaMode_Combined, 5, 5, 6, 2, 2, 0, false }  // 7
    };

    static uint16_t g_partitionMap[64] =
    {
        0xCCCC, 0x8888, 0xEEEE, 0xECC8,
        0xC880, 0xFEEC, 0xFEC8, 0xEC80,
        0xC800, 0xFFEC, 0xFE80, 0xE800,
        0xFFE8, 0xFF00, 0xFFF0, 0xF000,
        0xF710, 0x008E, 0x7100, 0x08CE,
        0x008C, 0x7310, 0x3100, 0x8CCE,
        0x088C, 0x3110, 0x6666, 0x366C,
        0x17E8, 0x0FF0, 0x718E, 0x399C,
        0xaaaa, 0xf0f0, 0x5a5a, 0x33cc,
        0x3c3c, 0x55aa, 0x9696, 0xa55a,
        0x73ce, 0x13c8, 0x324c, 0x3bdc,
        0x6996, 0xc33c, 0x9966, 0x660,
        0x272, 0x4e4, 0x4e40, 0x2720,
        0xc936, 0x936c, 0x39c6, 0x639c,
        0x9336, 0x9cc6, 0x817e, 0xe718,
        0xccf0, 0xfcc, 0x7744, 0xee22,
    };

    static uint32_t g_partitionMap2[64] =
    {
        0xaa685050, 0x6a5a5040, 0x5a5a4200, 0x5450a0a8,
        0xa5a50000, 0xa0a05050, 0x5555a0a0, 0x5a5a5050,
        0xaa550000, 0xaa555500, 0xaaaa5500, 0x90909090,
        0x94949494, 0xa4a4a4a4, 0xa9a59450, 0x2a0a4250,
        0xa5945040, 0x0a425054, 0xa5a5a500, 0x55a0a0a0,
        0xa8a85454, 0x6a6a4040, 0xa4a45000, 0x1a1a0500,
        0x0050a4a4, 0xaaa59090, 0x14696914, 0x69691400,
        0xa08585a0, 0xaa821414, 0x50a4a450, 0x6a5a0200,
        0xa9a58000, 0x5090a0a8, 0xa8a09050, 0x24242424,
        0x00aa5500, 0x24924924, 0x24499224, 0x50a50a50,
        0x500aa550, 0xaaaa4444, 0x66660000, 0xa5a0a5a0,
        0x50a050a0, 0x69286928, 0x44aaaa44, 0x66666600,
        0xaa444444, 0x54a854a8, 0x95809580, 0x96969600,
        0xa85454a8, 0x80959580, 0xaa141414, 0x96960000,
        0xaaaa1414, 0xa05050a0, 0xa0a5a5a0, 0x96000000,
        0x40804080, 0xa9a8a9a8, 0xaaaaaa44, 0x2a4a5254,
    };

    static int g_fixupIndexes2[64] =
    {
        15,15,15,15,
        15,15,15,15,
        15,15,15,15,
        15,15,15,15,
        15, 2, 8, 2,
        2, 8, 8,15,
        2, 8, 2, 2,
        8, 8, 2, 2,

        15,15, 6, 8,
        2, 8,15,15,
        2, 8, 2, 2,
        2,15,15, 6,
        6, 2, 6, 8,
        15,15, 2, 2,
        15,15,15,15,
        15, 2, 2,15,
    };

    static int g_fixupIndexes3[64][2] =
    {
        { 3,15 },{ 3, 8 },{ 15, 8 },{ 15, 3 },
        { 8,15 },{ 3,15 },{ 15, 3 },{ 15, 8 },
        { 8,15 },{ 8,15 },{ 6,15 },{ 6,15 },
        { 6,15 },{ 5,15 },{ 3,15 },{ 3, 8 },
        { 3,15 },{ 3, 8 },{ 8,15 },{ 15, 3 },
        { 3,15 },{ 3, 8 },{ 6,15 },{ 10, 8 },
        { 5, 3 },{ 8,15 },{ 8, 6 },{ 6,10 },
        { 8,15 },{ 5,15 },{ 15,10 },{ 15, 8 },

        { 8,15 },{ 15, 3 },{ 3,15 },{ 5,10 },
        { 6,10 },{ 10, 8 },{ 8, 9 },{ 15,10 },
        { 15, 6 },{ 3,15 },{ 15, 8 },{ 5,15 },
        { 15, 3 },{ 15, 6 },{ 15, 6 },{ 15, 8 },
        { 3,15 },{ 15, 3 },{ 5,15 },{ 5,15 },
        { 5,15 },{ 8,15 },{ 5,15 },{ 10,15 },
        { 5,15 },{ 10,15 },{ 8,15 },{ 13,15 },
        { 15, 3 },{ 12,15 },{ 3,15 },{ 3, 8 },
    };

    static const unsigned char g_fragments[] =
    {
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,  // 0, 16
        0, 1, 2, 3,  // 16, 4
        0, 1, 4,  // 20, 3
        0, 1, 2, 4,  // 23, 4
        2, 3, 7,  // 27, 3
        1, 2, 3, 7,  // 30, 4
        0, 1, 2, 3, 4, 5, 6, 7,  // 34, 8
        0, 1, 4, 8,  // 42, 4
        0, 1, 2, 4, 5, 8,  // 46, 6
        0, 1, 2, 3, 4, 5, 6, 8,  // 52, 8
        1, 4, 5, 6, 9,  // 60, 5
        2, 5, 6, 7, 10,  // 65, 5
        5, 6, 9, 10,  // 70, 4
        2, 3, 7, 11,  // 74, 4
        1, 2, 3, 6, 7, 11,  // 78, 6
        0, 1, 2, 3, 5, 6, 7, 11,  // 84, 8
        0, 1, 2, 3, 8, 9, 10, 11,  // 92, 8
        2, 3, 6, 7, 8, 9, 10, 11,  // 100, 8
        4, 5, 6, 7, 8, 9, 10, 11,  // 108, 8
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,  // 116, 12
        0, 4, 8, 12,  // 128, 4
        0, 2, 3, 4, 6, 7, 8, 12,  // 132, 8
        0, 1, 2, 4, 5, 8, 9, 12,  // 140, 8
        0, 1, 2, 3, 4, 5, 6, 8, 9, 12,  // 148, 10
        3, 6, 7, 8, 9, 12,  // 158, 6
        3, 5, 6, 7, 8, 9, 10, 12,  // 164, 8
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12,  // 172, 12
        0, 1, 2, 5, 6, 7, 11, 12,  // 184, 8
        5, 8, 9, 10, 13,  // 192, 5
        8, 12, 13,  // 197, 3
        4, 8, 12, 13,  // 200, 4
        2, 3, 6, 9, 12, 13,  // 204, 6
        0, 1, 2, 3, 8, 9, 12, 13,  // 210, 8
        0, 1, 4, 5, 8, 9, 12, 13,  // 218, 8
        2, 3, 6, 7, 8, 9, 12, 13,  // 226, 8
        2, 3, 5, 6, 9, 10, 12, 13,  // 234, 8
        0, 3, 6, 7, 9, 10, 12, 13,  // 242, 8
        0, 1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 13,  // 250, 12
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 13,  // 262, 13
        2, 3, 4, 7, 8, 11, 12, 13,  // 275, 8
        1, 2, 6, 7, 8, 11, 12, 13,  // 283, 8
        2, 3, 4, 6, 7, 8, 9, 11, 12, 13,  // 291, 10
        2, 3, 4, 5, 10, 11, 12, 13,  // 301, 8
        0, 1, 6, 7, 10, 11, 12, 13,  // 309, 8
        6, 9, 10, 11, 14,  // 317, 5
        0, 2, 4, 6, 8, 10, 12, 14,  // 322, 8
        1, 3, 5, 7, 8, 10, 12, 14,  // 330, 8
        1, 3, 4, 6, 9, 11, 12, 14,  // 338, 8
        0, 2, 5, 7, 9, 11, 12, 14,  // 346, 8
        0, 3, 4, 5, 8, 9, 13, 14,  // 354, 8
        2, 3, 4, 7, 8, 9, 13, 14,  // 362, 8
        1, 2, 5, 6, 9, 10, 13, 14,  // 370, 8
        0, 3, 4, 7, 9, 10, 13, 14,  // 378, 8
        0, 3, 5, 6, 8, 11, 13, 14,  // 386, 8
        1, 2, 4, 7, 8, 11, 13, 14,  // 394, 8
        0, 1, 4, 7, 10, 11, 13, 14,  // 402, 8
        0, 3, 6, 7, 10, 11, 13, 14,  // 410, 8
        8, 12, 13, 14,  // 418, 4
        1, 2, 3, 7, 8, 12, 13, 14,  // 422, 8
        4, 8, 9, 12, 13, 14,  // 430, 6
        0, 4, 5, 8, 9, 12, 13, 14,  // 436, 8
        1, 2, 3, 6, 7, 8, 9, 12, 13, 14,  // 444, 10
        2, 6, 8, 9, 10, 12, 13, 14,  // 454, 8
        0, 1, 2, 4, 5, 6, 8, 9, 10, 12, 13, 14,  // 462, 12
        0, 7, 9, 10, 11, 12, 13, 14,  // 474, 8
        1, 2, 3, 4, 5, 6, 8, 15,  // 482, 8
        3, 7, 11, 15,  // 490, 4
        0, 1, 3, 4, 5, 7, 11, 15,  // 494, 8
        0, 4, 5, 10, 11, 15,  // 502, 6
        1, 2, 3, 6, 7, 10, 11, 15,  // 508, 8
        0, 1, 2, 3, 5, 6, 7, 10, 11, 15,  // 516, 10
        0, 4, 5, 6, 9, 10, 11, 15,  // 526, 8
        0, 1, 2, 3, 4, 5, 6, 7, 9, 10, 11, 15,  // 534, 12
        1, 2, 4, 5, 8, 9, 12, 15,  // 546, 8
        2, 3, 5, 6, 8, 9, 12, 15,  // 554, 8
        0, 3, 5, 6, 9, 10, 12, 15,  // 562, 8
        1, 2, 4, 7, 9, 10, 12, 15,  // 570, 8
        1, 2, 5, 6, 8, 11, 12, 15,  // 578, 8
        0, 3, 4, 7, 8, 11, 12, 15,  // 586, 8
        0, 1, 5, 6, 10, 11, 12, 15,  // 594, 8
        1, 2, 6, 7, 10, 11, 12, 15,  // 602, 8
        1, 3, 4, 6, 8, 10, 13, 15,  // 610, 8
        0, 2, 5, 7, 8, 10, 13, 15,  // 618, 8
        0, 2, 4, 6, 9, 11, 13, 15,  // 626, 8
        1, 3, 5, 7, 9, 11, 13, 15,  // 634, 8
        0, 1, 2, 3, 4, 5, 7, 8, 12, 13, 15,  // 642, 11
        2, 3, 4, 5, 8, 9, 14, 15,  // 653, 8
        0, 1, 6, 7, 8, 9, 14, 15,  // 661, 8
        0, 1, 5, 10, 14, 15,  // 669, 6
        0, 3, 4, 5, 9, 10, 14, 15,  // 675, 8
        0, 1, 5, 6, 9, 10, 14, 15,  // 683, 8
        11, 14, 15,  // 691, 3
        7, 11, 14, 15,  // 694, 4
        1, 2, 4, 5, 8, 11, 14, 15,  // 698, 8
        0, 1, 4, 7, 8, 11, 14, 15,  // 706, 8
        0, 1, 4, 5, 10, 11, 14, 15,  // 714, 8
        2, 3, 6, 7, 10, 11, 14, 15,  // 722, 8
        4, 5, 6, 7, 10, 11, 14, 15,  // 730, 8
        0, 1, 4, 5, 7, 8, 10, 11, 14, 15,  // 738, 10
        0, 1, 2, 3, 5, 6, 7, 9, 10, 11, 14, 15,  // 748, 12
        0, 1, 2, 3, 4, 5, 6, 7, 9, 10, 11, 14, 15,  // 760, 13
        0, 1, 2, 3, 4, 6, 7, 11, 12, 14, 15,  // 773, 11
        3, 4, 8, 9, 10, 13, 14, 15,  // 784, 8
        11, 13, 14, 15,  // 792, 4
        0, 1, 2, 4, 11, 13, 14, 15,  // 796, 8
        0, 1, 2, 4, 5, 10, 11, 13, 14, 15,  // 804, 10
        7, 10, 11, 13, 14, 15,  // 814, 6
        3, 6, 7, 10, 11, 13, 14, 15,  // 820, 8
        1, 5, 9, 10, 11, 13, 14, 15,  // 828, 8
        1, 2, 3, 5, 6, 7, 9, 10, 11, 13, 14, 15,  // 836, 12
        12, 13, 14, 15,  // 848, 4
        0, 1, 2, 3, 12, 13, 14, 15,  // 852, 8
        0, 1, 4, 5, 12, 13, 14, 15,  // 860, 8
        4, 5, 6, 7, 12, 13, 14, 15,  // 868, 8
        4, 8, 9, 10, 12, 13, 14, 15,  // 876, 8
        0, 4, 5, 8, 9, 10, 12, 13, 14, 15,  // 884, 10
        0, 1, 4, 5, 6, 8, 9, 10, 12, 13, 14, 15,  // 894, 12
        0, 1, 2, 3, 4, 7, 8, 11, 12, 13, 14, 15,  // 906, 12
        0, 1, 3, 4, 8, 9, 11, 12, 13, 14, 15,  // 918, 11
        0, 2, 3, 7, 8, 10, 11, 12, 13, 14, 15,  // 929, 11
        7, 9, 10, 11, 12, 13, 14, 15,  // 940, 8
        3, 6, 7, 9, 10, 11, 12, 13, 14, 15,  // 948, 10
        2, 3, 5, 6, 7, 9, 10, 11, 12, 13, 14, 15,  // 958, 12
        8, 9, 10, 11, 12, 13, 14, 15,  // 970, 8
        0, 4, 5, 6, 8, 9, 10, 11, 12, 13, 14, 15,  // 978, 12
        0, 1, 4, 5, 6, 8, 9, 10, 11, 12, 13, 14, 15,  // 990, 13
        3, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,  // 1003, 12
        2, 3, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,  // 1015, 13
        4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,  // 1028, 12
        0, 2,  // 1040, 2
        1, 3,  // 1042, 2
        0, 1, 4, 5,  // 1044, 4
        0, 1, 2, 4, 5,  // 1048, 5
        2, 3, 6,  // 1053, 3
        0, 2, 4, 6,  // 1056, 4
        1, 2, 5, 6,  // 1060, 4
        0, 1, 2, 3, 5, 6,  // 1064, 6
        0, 1, 2, 4, 5, 6,  // 1070, 6
        0, 1, 2, 3, 4, 5, 6,  // 1076, 7
        0, 3, 4, 7,  // 1083, 4
        0, 1, 2, 3, 4, 7,  // 1087, 6
        1, 3, 5, 7,  // 1093, 4
        2, 3, 6, 7,  // 1097, 4
        1, 2, 3, 6, 7,  // 1101, 5
        1, 2, 3, 5, 6, 7,  // 1106, 6
        0, 1, 2, 3, 5, 6, 7,  // 1112, 7
        4, 5, 6, 7,  // 1119, 4
        0, 8,  // 1123, 2
        0, 1, 4, 5, 8,  // 1125, 5
        0, 1, 8, 9,  // 1130, 4
        4, 5, 8, 9,  // 1134, 4
        0, 1, 4, 5, 8, 9,  // 1138, 6
        2, 6, 8, 9,  // 1144, 4
        6, 7, 8, 9,  // 1148, 4
        0, 2, 4, 6, 8, 10,  // 1152, 6
        1, 2, 5, 6, 9, 10,  // 1158, 6
        0, 3, 4, 7, 9, 10,  // 1164, 6
        0, 1, 2, 8, 9, 10,  // 1170, 6
        4, 5, 6, 8, 9, 10,  // 1176, 6
        3, 11,  // 1182, 2
        2, 3, 6, 7, 11,  // 1184, 5
        0, 3, 8, 11,  // 1189, 4
        0, 3, 4, 7, 8, 11,  // 1193, 6
        1, 3, 5, 7, 9, 11,  // 1199, 6
        2, 3, 10, 11,  // 1205, 4
        1, 5, 10, 11,  // 1209, 4
        4, 5, 10, 11,  // 1213, 4
        6, 7, 10, 11,  // 1217, 4
        2, 3, 6, 7, 10, 11,  // 1221, 6
        1, 2, 3, 9, 10, 11,  // 1227, 6
        5, 6, 7, 9, 10, 11,  // 1233, 6
        8, 9, 10, 11,  // 1239, 4
        4, 12,  // 1243, 2
        0, 1, 2, 3, 4, 5, 8, 12,  // 1245, 8
        8, 9, 12,  // 1253, 3
        0, 4, 5, 8, 9, 12,  // 1256, 6
        0, 1, 4, 5, 8, 9, 12,  // 1262, 7
        2, 3, 5, 6, 8, 9, 12,  // 1269, 7
        1, 5, 9, 13,  // 1276, 4
        6, 7, 9, 13,  // 1280, 4
        1, 4, 7, 10, 13,  // 1284, 5
        1, 6, 8, 11, 13,  // 1289, 5
        0, 1, 12, 13,  // 1294, 4
        4, 5, 12, 13,  // 1298, 4
        0, 1, 6, 7, 12, 13,  // 1302, 6
        0, 1, 4, 8, 12, 13,  // 1308, 6
        8, 9, 12, 13,  // 1314, 4
        4, 8, 9, 12, 13,  // 1318, 5
        4, 5, 8, 9, 12, 13,  // 1323, 6
        0, 4, 5, 8, 9, 12, 13,  // 1329, 7
        0, 1, 6, 10, 12, 13,  // 1336, 6
        3, 6, 7, 9, 10, 12, 13,  // 1342, 7
        0, 1, 10, 11, 12, 13,  // 1349, 6
        2, 4, 7, 9, 14,  // 1355, 5
        4, 5, 10, 14,  // 1360, 4
        2, 6, 10, 14,  // 1364, 4
        2, 5, 8, 11, 14,  // 1368, 5
        0, 2, 12, 14,  // 1373, 4
        8, 10, 12, 14,  // 1377, 4
        4, 6, 8, 10, 12, 14,  // 1381, 6
        13, 14,  // 1387, 2
        9, 10, 13, 14,  // 1389, 4
        5, 6, 9, 10, 13, 14,  // 1393, 6
        0, 1, 2, 12, 13, 14,  // 1399, 6
        4, 5, 6, 12, 13, 14,  // 1405, 6
        8, 9, 12, 13, 14,  // 1411, 5
        8, 9, 10, 12, 13, 14,  // 1416, 6
        7, 15,  // 1422, 2
        0, 5, 10, 15,  // 1424, 4
        0, 1, 2, 3, 6, 7, 11, 15,  // 1428, 8
        10, 11, 15,  // 1436, 3
        0, 1, 5, 6, 10, 11, 15,  // 1439, 7
        3, 6, 7, 10, 11, 15,  // 1446, 6
        12, 15,  // 1452, 2
        0, 3, 12, 15,  // 1454, 4
        4, 7, 12, 15,  // 1458, 4
        0, 3, 6, 9, 12, 15,  // 1462, 6
        0, 3, 5, 10, 12, 15,  // 1468, 6
        8, 11, 12, 15,  // 1474, 4
        5, 6, 8, 11, 12, 15,  // 1478, 6
        4, 7, 8, 11, 12, 15,  // 1484, 6
        1, 3, 13, 15,  // 1490, 4
        9, 11, 13, 15,  // 1494, 4
        5, 7, 9, 11, 13, 15,  // 1498, 6
        2, 3, 14, 15,  // 1504, 4
        2, 3, 4, 5, 14, 15,  // 1508, 6
        6, 7, 14, 15,  // 1514, 4
        2, 3, 5, 9, 14, 15,  // 1518, 6
        2, 3, 8, 9, 14, 15,  // 1524, 6
        10, 14, 15,  // 1530, 3
        0, 4, 5, 9, 10, 14, 15,  // 1533, 7
        2, 3, 7, 11, 14, 15,  // 1540, 6
        10, 11, 14, 15,  // 1546, 4
        7, 10, 11, 14, 15,  // 1550, 5
        6, 7, 10, 11, 14, 15,  // 1555, 6
        1, 2, 3, 13, 14, 15,  // 1561, 6
        5, 6, 7, 13, 14, 15,  // 1567, 6
        10, 11, 13, 14, 15,  // 1573, 5
        9, 10, 11, 13, 14, 15,  // 1578, 6
        0, 4, 8, 9, 12, 13, 14, 15,  // 1584, 8
        9, 10, 12, 13, 14, 15,  // 1592, 6
        8, 11, 12, 13, 14, 15,  // 1598, 6
        3, 7, 10, 11, 12, 13, 14, 15,  // 1604, 8
    };
    static const int g_shapeRanges[][2] =
    {
        { 0, 16 },{ 16, 4 },{ 20, 3 },{ 23, 4 },{ 27, 3 },{ 30, 4 },{ 34, 8 },{ 42, 4 },{ 46, 6 },{ 52, 8 },{ 60, 5 },
    { 65, 5 },{ 70, 4 },{ 74, 4 },{ 78, 6 },{ 84, 8 },{ 92, 8 },{ 100, 8 },{ 108, 8 },{ 116, 12 },{ 128, 4 },{ 132, 8 },
    { 140, 8 },{ 148, 10 },{ 158, 6 },{ 164, 8 },{ 172, 12 },{ 184, 8 },{ 192, 5 },{ 197, 3 },{ 200, 4 },{ 204, 6 },{ 210, 8 },
    { 218, 8 },{ 226, 8 },{ 234, 8 },{ 242, 8 },{ 250, 12 },{ 262, 13 },{ 275, 8 },{ 283, 8 },{ 291, 10 },{ 301, 8 },{ 309, 8 },
    { 317, 5 },{ 322, 8 },{ 330, 8 },{ 338, 8 },{ 346, 8 },{ 354, 8 },{ 362, 8 },{ 370, 8 },{ 378, 8 },{ 386, 8 },{ 394, 8 },
    { 402, 8 },{ 410, 8 },{ 418, 4 },{ 422, 8 },{ 430, 6 },{ 436, 8 },{ 444, 10 },{ 454, 8 },{ 462, 12 },{ 474, 8 },{ 482, 8 },
    { 490, 4 },{ 494, 8 },{ 502, 6 },{ 508, 8 },{ 516, 10 },{ 526, 8 },{ 534, 12 },{ 546, 8 },{ 554, 8 },{ 562, 8 },{ 570, 8 },
    { 578, 8 },{ 586, 8 },{ 594, 8 },{ 602, 8 },{ 610, 8 },{ 618, 8 },{ 626, 8 },{ 634, 8 },{ 642, 11 },{ 653, 8 },{ 661, 8 },
    { 669, 6 },{ 675, 8 },{ 683, 8 },{ 691, 3 },{ 694, 4 },{ 698, 8 },{ 706, 8 },{ 714, 8 },{ 722, 8 },{ 730, 8 },{ 738, 10 },
    { 748, 12 },{ 760, 13 },{ 773, 11 },{ 784, 8 },{ 792, 4 },{ 796, 8 },{ 804, 10 },{ 814, 6 },{ 820, 8 },{ 828, 8 },{ 836, 12 },
    { 848, 4 },{ 852, 8 },{ 860, 8 },{ 868, 8 },{ 876, 8 },{ 884, 10 },{ 894, 12 },{ 906, 12 },{ 918, 11 },{ 929, 11 },{ 940, 8 },
    { 948, 10 },{ 958, 12 },{ 970, 8 },{ 978, 12 },{ 990, 13 },{ 1003, 12 },{ 1015, 13 },{ 1028, 12 },{ 1040, 2 },{ 1042, 2 },{ 1044, 4 },
    { 1048, 5 },{ 1053, 3 },{ 1056, 4 },{ 1060, 4 },{ 1064, 6 },{ 1070, 6 },{ 1076, 7 },{ 1083, 4 },{ 1087, 6 },{ 1093, 4 },{ 1097, 4 },
    { 1101, 5 },{ 1106, 6 },{ 1112, 7 },{ 1119, 4 },{ 1123, 2 },{ 1125, 5 },{ 1130, 4 },{ 1134, 4 },{ 1138, 6 },{ 1144, 4 },{ 1148, 4 },
    { 1152, 6 },{ 1158, 6 },{ 1164, 6 },{ 1170, 6 },{ 1176, 6 },{ 1182, 2 },{ 1184, 5 },{ 1189, 4 },{ 1193, 6 },{ 1199, 6 },{ 1205, 4 },
    { 1209, 4 },{ 1213, 4 },{ 1217, 4 },{ 1221, 6 },{ 1227, 6 },{ 1233, 6 },{ 1239, 4 },{ 1243, 2 },{ 1245, 8 },{ 1253, 3 },{ 1256, 6 },
    { 1262, 7 },{ 1269, 7 },{ 1276, 4 },{ 1280, 4 },{ 1284, 5 },{ 1289, 5 },{ 1294, 4 },{ 1298, 4 },{ 1302, 6 },{ 1308, 6 },{ 1314, 4 },
    { 1318, 5 },{ 1323, 6 },{ 1329, 7 },{ 1336, 6 },{ 1342, 7 },{ 1349, 6 },{ 1355, 5 },{ 1360, 4 },{ 1364, 4 },{ 1368, 5 },{ 1373, 4 },
    { 1377, 4 },{ 1381, 6 },{ 1387, 2 },{ 1389, 4 },{ 1393, 6 },{ 1399, 6 },{ 1405, 6 },{ 1411, 5 },{ 1416, 6 },{ 1422, 2 },{ 1424, 4 },
    { 1428, 8 },{ 1436, 3 },{ 1439, 7 },{ 1446, 6 },{ 1452, 2 },{ 1454, 4 },{ 1458, 4 },{ 1462, 6 },{ 1468, 6 },{ 1474, 4 },{ 1478, 6 },
    { 1484, 6 },{ 1490, 4 },{ 1494, 4 },{ 1498, 6 },{ 1504, 4 },{ 1508, 6 },{ 1514, 4 },{ 1518, 6 },{ 1524, 6 },{ 1530, 3 },{ 1533, 7 },
    { 1540, 6 },{ 1546, 4 },{ 1550, 5 },{ 1555, 6 },{ 1561, 6 },{ 1567, 6 },{ 1573, 5 },{ 1578, 6 },{ 1584, 8 },{ 1592, 6 },{ 1598, 6 },
    { 1604, 8 },
    };
    static const int g_shapes1[][2] =
    {
        { 0, 16 }
    };
    static const int g_shapes2[64][2] =
    {
        { 33, 96 },{ 63, 66 },{ 20, 109 },{ 22, 107 },{ 37, 92 },{ 7, 122 },{ 8, 121 },{ 23, 106 },
        { 38, 91 },{ 2, 127 },{ 9, 120 },{ 26, 103 },{ 3, 126 },{ 6, 123 },{ 1, 128 },{ 19, 110 },
        { 15, 114 },{ 124, 5 },{ 72, 57 },{ 115, 14 },{ 125, 4 },{ 70, 59 },{ 100, 29 },{ 60, 69 },
        { 116, 13 },{ 99, 30 },{ 78, 51 },{ 94, 35 },{ 104, 25 },{ 111, 18 },{ 71, 58 },{ 90, 39 },
        { 45, 84 },{ 16, 113 },{ 82, 47 },{ 95, 34 },{ 87, 42 },{ 83, 46 },{ 53, 76 },{ 48, 81 },
        { 68, 61 },{ 105, 24 },{ 98, 31 },{ 88, 41 },{ 75, 54 },{ 43, 86 },{ 52, 77 },{ 117, 12 },
        { 119, 10 },{ 118, 11 },{ 85, 44 },{ 101, 28 },{ 36, 93 },{ 55, 74 },{ 89, 40 },{ 79, 50 },
        { 56, 73 },{ 49, 80 },{ 64, 65 },{ 27, 102 },{ 32, 97 },{ 112, 17 },{ 67, 62 },{ 21, 108 },
    };
    static const int g_shapes3[64][3] =
    {
        { 148, 160, 240 },{ 132, 212, 205 },{ 136, 233, 187 },{ 175, 237, 143 },{ 6, 186, 232 },{ 33, 142, 232 },{ 131, 123, 142 },{ 131, 96, 186 },
        { 6, 171, 110 },{ 1, 18, 110 },{ 1, 146, 123 },{ 33, 195, 66 },{ 20, 51, 66 },{ 20, 178, 96 },{ 2, 177, 106 },{ 211, 4, 59 },
        { 8, 191, 91 },{ 230, 14, 29 },{ 1, 188, 234 },{ 151, 110, 168 },{ 20, 144, 238 },{ 137, 66, 206 },{ 173, 179, 232 },{ 209, 194, 186 },
        { 239, 165, 142 },{ 131, 152, 242 },{ 214, 54, 12 },{ 140, 219, 201 },{ 190, 150, 231 },{ 156, 135, 241 },{ 185, 227, 167 },{ 145, 210, 59 },
        { 138, 174, 106 },{ 189, 229, 14 },{ 176, 133, 106 },{ 78, 178, 195 },{ 111, 146, 171 },{ 216, 180, 196 },{ 217, 181, 193 },{ 184, 228, 166 },
        { 192, 225, 153 },{ 134, 141, 123 },{ 6, 222, 198 },{ 149, 183, 96 },{ 33, 226, 164 },{ 161, 215, 51 },{ 197, 221, 18 },{ 1, 223, 199 },
        { 154, 163, 110 },{ 20, 236, 169 },{ 157, 204, 66 },{ 1, 202, 220 },{ 20, 170, 235 },{ 203, 158, 66 },{ 162, 155, 110 },{ 6, 201, 218 },
        { 139, 135, 123 },{ 33, 167, 224 },{ 182, 150, 96 },{ 19, 200, 213 },{ 63, 207, 159 },{ 147, 172, 109 },{ 129, 130, 128 },{ 208, 14, 59 },
    };

    static const int g_shapeList1[] =
    {
        0,
    };

    static const int g_shapeList1Collapse[] =
    {
        0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1,
    };
    static const int g_shapeList2[] =
    {
        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
        12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,
        23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33,
        34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44,
        45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55,
        56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66,
        67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77,
        78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88,
        89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,
        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110,
        111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121,
        122, 123, 124, 125, 126, 127, 128,
    };
    static const int g_shapeList2Collapse[] =
    {
        -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
        10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
        21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
        32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42,
        43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53,
        54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64,
        65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75,
        76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86,
        87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97,
        98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108,
        109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,
        120, 121, 122, 123, 124, 125, 126, 127, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1,
    };

    static const int g_shapeList12[] =
    {
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
        11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
        22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,
        33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
        44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54,
        55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65,
        66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76,
        77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87,
        88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98,
        99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109,
        110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120,
        121, 122, 123, 124, 125, 126, 127, 128,
    };

    static const int g_shapeList12Collapse[] =
    {
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
        11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
        22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,
        33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
        44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54,
        55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65,
        66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76,
        77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87,
        88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98,
        99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109,
        110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120,
        121, 122, 123, 124, 125, 126, 127, 128, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1,
    };

    static const int g_shapeList3[] =
    {
        1, 2, 4, 6, 8, 12, 14, 18, 19, 20, 29,
        33, 51, 54, 59, 63, 66, 78, 91, 96, 106, 109,
        110, 111, 123, 128, 129, 130, 131, 132, 133, 134, 135,
        136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146,
        147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157,
        158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168,
        169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179,
        180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190,
        191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201,
        202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212,
        213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,
        224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234,
        235, 236, 237, 238, 239, 240, 241, 242,
    };

    static const int g_shapeList3Collapse[] =
    {
        -1, 0, 1, -1, 2, -1, 3, -1, 4, -1, -1,
        -1, 5, -1, 6, -1, -1, -1, 7, 8, 9, -1,
        -1, -1, -1, -1, -1, -1, -1, 10, -1, -1, -1,
        11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, 12, -1, -1, 13,
        -1, -1, -1, -1, 14, -1, -1, -1, 15, -1, -1,
        16, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, 17, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, 18, -1, -1, -1, -1, 19, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, 20, -1, -1, 21,
        22, 23, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, 24, -1, -1, -1, -1, 25, 26, 27, 28,
        29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,
        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50,
        51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61,
        62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72,
        73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83,
        84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94,
        95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105,
        106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116,
        117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127,
        128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138,
        139,
    };

    static const int g_shapeList3Short[] =
    {
        1, 2, 4, 6, 18, 20, 33, 51, 59, 66, 96,
        106, 110, 123, 131, 132, 136, 142, 143, 146, 148, 160,
        171, 175, 177, 178, 186, 187, 195, 205, 211, 212, 232,
        233, 237, 240,
    };

    static const int g_shapeList3ShortCollapse[] =
    {
        -1, 0, 1, -1, 2, -1, 3, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, 4, -1, 5, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, 7, -1, -1, -1,
        -1, -1, -1, -1, 8, -1, -1, -1, -1, -1, -1,
        9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, 10, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, 11, -1, -1, -1,
        12, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, 13, -1, -1, -1, -1, -1, -1, -1, 14,
        15, -1, -1, -1, 16, -1, -1, -1, -1, -1, 17,
        18, -1, -1, 19, -1, 20, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, 21, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, 22, -1, -1, -1, 23,
        -1, 24, 25, -1, -1, -1, -1, -1, -1, -1, 26,
        27, -1, -1, -1, -1, -1, -1, -1, 28, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, 29, -1, -1, -1,
        -1, -1, 30, 31, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, 32, 33, -1, -1, -1, 34, -1, -1, 35, -1,
        -1,
    };

    static const int g_shapeListAll[] =
    {
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
        11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
        22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,
        33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
        44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54,
        55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65,
        66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76,
        77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87,
        88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98,
        99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109,
        110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120,
        121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131,
        132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142,
        143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153,
        154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164,
        165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,
        176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186,
        187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197,
        198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208,
        209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219,
        220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230,
        231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241,
        242,
    };

    static const int g_numShapes1 = sizeof(g_shapeList1) / sizeof(g_shapeList1[0]);
    static const int g_numShapes2 = sizeof(g_shapeList2) / sizeof(g_shapeList2[0]);
    static const int g_numShapes12 = sizeof(g_shapeList12) / sizeof(g_shapeList12[0]);
    static const int g_numShapes3 = sizeof(g_shapeList3) / sizeof(g_shapeList3[0]);
    static const int g_numShapes3Short = sizeof(g_shapeList3Short) / sizeof(g_shapeList3Short[0]);
    static const int g_numShapesAll = sizeof(g_shapeListAll) / sizeof(g_shapeListAll[0]);
    static const int g_numFragments = sizeof(g_fragments) / sizeof(g_fragments[0]);

    static const int g_maxFragmentsPerMode = (g_numShapes2 > g_numShapes3) ? g_numShapes2 : g_numShapes3;
}

namespace
{
    struct InputBlock
    {
        int32_t m_pixels[16];
    };

#if (defined(_M_IX86_FP) && _M_IX86_FP >= 2) || defined(_M_X64)
    // SSE2 version

    struct ParallelMath
    {
        static const int ParallelSize = 8;

        struct Int16
        {
            __m128i m_value;

            inline Int16 operator+(int16_t other) const
            {
                Int16 result;
                result.m_value = _mm_add_epi16(m_value, _mm_set1_epi16(other));
                return result;
            }

            inline Int16 operator+(Int16 other) const
            {
                Int16 result;
                result.m_value = _mm_add_epi16(m_value, other.m_value);
                return result;
            }

            inline Int16 operator|(Int16 other) const
            {
                Int16 result;
                result.m_value = _mm_or_si128(m_value, other.m_value);
                return result;
            }

            inline Int16 operator-(Int16 other) const
            {
                Int16 result;
                result.m_value = _mm_sub_epi16(m_value, other.m_value);
                return result;
            }

            inline Int16 operator*(const Int16& other) const
            {
                Int16 result;
                result.m_value = _mm_mullo_epi16(m_value, other.m_value);
                return result;
            }

            inline Int16 operator<<(int bits) const
            {
                Int16 result;
                result.m_value = _mm_slli_epi16(m_value, bits);
                return result;
            }
        };

        struct Int32
        {
            __m128i m_values[2];
        };

        struct Float
        {
            __m128 m_values[2];

            inline Float operator+(const Float& other) const
            {
                Float result;
                result.m_values[0] = _mm_add_ps(m_values[0], other.m_values[0]);
                result.m_values[1] = _mm_add_ps(m_values[1], other.m_values[1]);
                return result;
            }

            inline Float operator-(const Float& other) const
            {
                Float result;
                result.m_values[0] = _mm_sub_ps(m_values[0], other.m_values[0]);
                result.m_values[1] = _mm_sub_ps(m_values[1], other.m_values[1]);
                return result;
            }

            inline Float operator*(const Float& other) const
            {
                Float result;
                result.m_values[0] = _mm_mul_ps(m_values[0], other.m_values[0]);
                result.m_values[1] = _mm_mul_ps(m_values[1], other.m_values[1]);
                return result;
            }

            inline Float operator*(float other) const
            {
                Float result;
                result.m_values[0] = _mm_mul_ps(m_values[0], _mm_set1_ps(other));
                result.m_values[1] = _mm_mul_ps(m_values[1], _mm_set1_ps(other));
                return result;
            }

            inline Float operator/(const Float& other) const
            {
                Float result;
                result.m_values[0] = _mm_div_ps(m_values[0], other.m_values[0]);
                result.m_values[1] = _mm_div_ps(m_values[1], other.m_values[1]);
                return result;
            }

            inline Float operator/(float other) const
            {
                Float result;
                result.m_values[0] = _mm_div_ps(m_values[0], _mm_set1_ps(other));
                result.m_values[1] = _mm_div_ps(m_values[1], _mm_set1_ps(other));
                return result;
            }
        };

        struct Int16CompFlag
        {
            __m128i m_value;

            inline Int16CompFlag operator&(const Int16CompFlag& other) const
            {
                Int16CompFlag result;
                result.m_value = _mm_and_si128(m_value, other.m_value);
                return result;
            }

            inline Int16CompFlag operator|(const Int16CompFlag& other) const
            {
                Int16CompFlag result;
                result.m_value = _mm_or_si128(m_value, other.m_value);
                return result;
            }
        };

        struct FloatCompFlag
        {
            __m128 m_values[2];
        };

        static Float Select(FloatCompFlag flag, Float a, Float b)
        {
            Float result;
            for (int i = 0; i < 2; i++)
                result.m_values[i] = _mm_or_ps(_mm_and_ps(flag.m_values[i], a.m_values[i]), _mm_andnot_ps(flag.m_values[i], b.m_values[i]));
            return result;
        }

        static Int16 Select(Int16CompFlag flag, Int16 a, Int16 b)
        {
            Int16 result;
            result.m_value = _mm_or_si128(_mm_and_si128(flag.m_value, a.m_value), _mm_andnot_si128(flag.m_value, b.m_value));
            return result;
        }

        static Int16 SelectIfNonZero(Int16CompFlag flag, Int16 v)
        {
            Int16 result;
            result.m_value = _mm_and_si128(flag.m_value, v.m_value);
            return result;
        }

        static void ConditionalSet(Int16& dest, Int16CompFlag flag, const Int16 src)
        {
            dest.m_value = _mm_or_si128(_mm_andnot_si128(flag.m_value, dest.m_value), _mm_and_si128(flag.m_value, src.m_value));
        }

        static void NotConditionalSet(Int16& dest, Int16CompFlag flag, const Int16 src)
        {
            dest.m_value = _mm_or_si128(_mm_and_si128(flag.m_value, dest.m_value), _mm_andnot_si128(flag.m_value, src.m_value));
        }

        static void ConditionalSet(Float& dest, FloatCompFlag flag, const Float src)
        {
            for (int i = 0; i < 2; i++)
                dest.m_values[i] = _mm_or_ps(_mm_andnot_ps(flag.m_values[i], dest.m_values[i]), _mm_and_ps(flag.m_values[i], src.m_values[i]));
        }

        static void NotConditionalSet(Float& dest, FloatCompFlag flag, const Float src)
        {
            for (int i = 0; i < 2; i++)
                dest.m_values[i] = _mm_or_ps(_mm_and_ps(flag.m_values[i], dest.m_values[i]), _mm_andnot_ps(flag.m_values[i], src.m_values[i]));
        }

        static void MakeSafeDenominator(Float& v)
        {
            ConditionalSet(v, Equal(v, MakeFloatZero()), MakeFloat(1.0f));
        }

        static Int16 Min(Int16 a, Int16 b)
        {
            Int16 result;
            result.m_value = _mm_min_epi16(a.m_value, b.m_value);
            return result;
        }

        static Float Min(Float a, Float b)
        {
            Float result;
            for (int i = 0; i < 2; i++)
                result.m_values[i] = _mm_min_ps(a.m_values[i], b.m_values[i]);
            return result;
        }

        static Int16 Max(Int16 a, Int16 b)
        {
            Int16 result;
            result.m_value = _mm_max_epi16(a.m_value, b.m_value);
            return result;
        }

        static Float Max(Float a, Float b)
        {
            Float result;
            for (int i = 0; i < 2; i++)
                result.m_values[i] = _mm_max_ps(a.m_values[i], b.m_values[i]);
            return result;
        }

        static Float Clamp(Float v, float min, float max)
        {
            Float result;
            for (int i = 0; i < 2; i++)
                result.m_values[i] = _mm_max_ps(_mm_min_ps(v.m_values[i], _mm_set1_ps(max)), _mm_set1_ps(min));
            return result;
        }

        static Float Reciprocal(Float v)
        {
            Float result;
            for (int i = 0; i < 2; i++)
                result.m_values[i] = _mm_rcp_ps(v.m_values[i]);
            return result;
        }

        static void ReadPackedInputs(const InputBlock* inputBlocks, int pxOffset, Int32& outPackedPx)
        {
            for (int i = 0; i < 4; i++)
                reinterpret_cast<int32_t*>(&outPackedPx.m_values[0])[i] = inputBlocks[i].m_pixels[pxOffset];
            for (int i = 0; i < 4; i++)
                reinterpret_cast<int32_t*>(&outPackedPx.m_values[1])[i] = inputBlocks[i + 4].m_pixels[pxOffset];
        }

        static void UnpackChannel(Int32 inputPx, int ch, Int16& chOut)
        {
            __m128i ch0 = _mm_srli_epi32(inputPx.m_values[0], ch * 8);
            __m128i ch1 = _mm_srli_epi32(inputPx.m_values[1], ch * 8);
            ch0 = _mm_and_si128(ch0, _mm_set1_epi32(0xff));
            ch1 = _mm_and_si128(ch1, _mm_set1_epi32(0xff));

            chOut.m_value = _mm_packs_epi32(ch0, ch1);
        }

        static Float MakeFloat(float v)
        {
            Float f;
            f.m_values[0] = f.m_values[1] = _mm_set1_ps(v);
            return f;
        }

        static Float MakeFloatZero()
        {
            Float f;
            f.m_values[0] = f.m_values[1] = _mm_setzero_ps();
            return f;
        }

        static Int16 MakeUInt16(uint16_t v)
        {
            Int16 result;
            result.m_value = _mm_set1_epi16(static_cast<short>(v));
            return result;
        }

        static uint16_t ExtractUInt16(const Int16& v, int offset)
        {
            return reinterpret_cast<const uint16_t*>(&v)[offset];
        }

        static void PutUInt16(Int16 &dest, int offset, uint16_t v)
        {
            reinterpret_cast<uint16_t*>(&dest)[offset] = v;
        }

        static float ExtractFloat(const Float& v, int offset)
        {
            return reinterpret_cast<const float*>(&v)[offset];
        }

        static void PutFloat(Float &dest, int offset, float v)
        {
            reinterpret_cast<float*>(&dest)[offset] = v;
        }

        static Int16CompFlag Less(Int16 a, Int16 b)
        {
            Int16CompFlag result;
            result.m_value = _mm_cmplt_epi16(a.m_value, b.m_value);
            return result;
        }

        static Int16CompFlag LessOrEqual(Int16 a, Int16 b)
        {
            Int16CompFlag result;
            result.m_value = _mm_cmpgt_epi16(b.m_value, a.m_value);
            return result;
        }

        static FloatCompFlag Less(Float a, Float b)
        {
            FloatCompFlag result;
            for (int i = 0; i < 2; i++)
                result.m_values[i] = _mm_cmplt_ps(a.m_values[i], b.m_values[i]);
            return result;
        }

        static FloatCompFlag LessOrEqual(Float a, Float b)
        {
            FloatCompFlag result;
            for (int i = 0; i < 2; i++)
                result.m_values[i] = _mm_cmple_ps(a.m_values[i], b.m_values[i]);
            return result;
        }

        static Int16CompFlag Equal(Int16 a, Int16 b)
        {
            Int16CompFlag result;
            result.m_value = _mm_cmpeq_epi16(a.m_value, b.m_value);
            return result;
        }

        static FloatCompFlag Equal(Float a, Float b)
        {
            FloatCompFlag result;
            for (int i = 0; i < 2; i++)
                result.m_values[i] = _mm_cmpeq_ps(a.m_values[i], b.m_values[i]);
            return result;
        }

        static Float UInt16ToFloat(Int16 v)
        {
            Float result;
            result.m_values[0] = _mm_cvtepi32_ps(_mm_unpacklo_epi16(v.m_value, _mm_setzero_si128()));
            result.m_values[1] = _mm_cvtepi32_ps(_mm_unpackhi_epi16(v.m_value, _mm_setzero_si128()));
            return result;
        }

        static Int16CompFlag FloatFlagToInt16(FloatCompFlag v)
        {
            __m128i lo = _mm_castps_si128(v.m_values[0]);
            __m128i hi = _mm_castps_si128(v.m_values[1]);

            Int16CompFlag result;
            result.m_value = _mm_packs_epi32(lo, hi);
            return result;
        }

        static FloatCompFlag Int16FlagToFloat(Int16CompFlag v)
        {
            
            __m128i lo = _mm_unpacklo_epi16(v.m_value, v.m_value);
            __m128i hi = _mm_unpackhi_epi16(v.m_value, v.m_value);

            FloatCompFlag result;
            result.m_values[0] = _mm_castsi128_ps(lo);
            result.m_values[1] = _mm_castsi128_ps(hi);
            return result;
        }

        static Int16 FloatToUInt16(Float v)
        {
            __m128 half = _mm_set1_ps(0.5f);
            __m128i lo = _mm_cvttps_epi32(_mm_add_ps(v.m_values[0], half));
            __m128i hi = _mm_cvttps_epi32(_mm_add_ps(v.m_values[1], half));

            Int16 result;
            result.m_value = _mm_packs_epi32(lo, hi);
            return result;
        }

        static Float Sqrt(Float f)
        {
            Float result;
            for (int i = 0; i < 2; i++)
                result.m_values[i] = _mm_sqrt_ps(f.m_values[i]);
            return result;
        }

        static Int16 SqDiff(Int16 a, Int16 b)
        {
            __m128i diff = _mm_sub_epi16(a.m_value, b.m_value);

            Int16 result;
            result.m_value = _mm_mullo_epi16(diff, diff);
            return result;
        }

        static Int16 UnsignedRightShift(Int16 v, int bits)
        {
            Int16 result;
            result.m_value = _mm_srli_epi16(v.m_value, bits);
            return result;
        }

        static bool AnySet(Int16CompFlag v)
        {
            return _mm_movemask_epi8(v.m_value) != 0;
        }

        static bool AllSet(Int16CompFlag v)
        {
            return _mm_movemask_epi8(v.m_value) == 0xffff;
        }

        static bool AnySet(FloatCompFlag v)
        {
            return _mm_movemask_ps(v.m_values[0]) != 0 || _mm_movemask_ps(v.m_values[1]) != 0;
        }

        static bool AllSet(FloatCompFlag v)
        {
            return _mm_movemask_ps(v.m_values[0]) == 0xf && _mm_movemask_ps(v.m_values[1]) == 0xf;
        }
    };

#else
    // Scalar version

    struct ParallelMath
    {
        static const int ParallelSize = 1;

        typedef float Float;
        typedef int16_t Int16;
        typedef int32_t Int32;
        typedef bool Int16CompFlag;
        typedef bool FloatCompFlag;

        template<class T>
        inline static void ConditionalSet(T& dest, bool flag, const T src)
        {
            if (flag)
                dest = src;
        }

        template<class T>
        inline static void NotConditionalSet(T& dest, bool flag, const T src)
        {
            if (!flag)
                dest = src;
        }

        static void MakeSafeDenominator(float& v)
        {
            if (v == 0.f)
                v = 1.0f;
        }

        template<class T>
        inline static T Select(bool flag, T a, T b)
        {
            return flag ? a : b;
        }

        template<class T>
        inline static T SelectIfNonZero(bool flag, T v)
        {
            return flag ? v : static_cast<T>(0);
        }

        template<class T>
        inline static T Min(T a, T b)
        {
            if (a < b)
                return a;
            return b;
        }

        template<class T>
        inline static T Max(T a, T b)
        {
            if (a > b)
                return a;
            return b;
        }

        template<class T>
        inline static T Clamp(T v, T min, T max)
        {
            return Max(Min(v, max), min);
        }

        inline static void ReadPackedInputs(const InputBlock* inputBlocks, int pxOffset, Int32& outPackedPx)
        {
            outPackedPx = inputBlocks[0].m_pixels[pxOffset];
        }

        inline static void UnpackChannel(Int32 inputPx, int ch, Int16& chOut)
        {
            chOut = static_cast<uint16_t>((inputPx >> (ch * 8)) & 0xff);
        }

        inline static float MakeFloat(float v)
        {
            return v;
        }

        inline static float MakeFloatZero()
        {
            return 0.f;
        }

        inline static int16_t MakeUInt16(int16_t v)
        {
            return v;
        }

        inline static int16_t ExtractUInt16(int16_t v, int offset)
        {
            (void)offset;
            return v;
        }

        static void PutUInt16(Int16 &dest, int offset, uint16_t v)
        {
            (void)offset;
            dest = v;
        }

        inline static float ExtractFloat(float v, int offset)
        {
            (void)offset;
            return v;
        }

        inline static void PutFloat(float &dest, int offset, float v)
        {
            dest = v;
        }

        template<class T>
        inline static bool Less(T a, T b)
        {
            return a < b;
        }

        template<class T>
        inline static bool Equal(T a, T b)
        {
            return a == b;
        }

        template<class T>
        inline static bool LessOrEqual(T a, T b)
        {
            return a <= b;
        }

        inline static float UInt16ToFloat(uint16_t v)
        {
            return static_cast<float>(v);
        }

        inline static Int16CompFlag FloatFlagToInt16(FloatCompFlag v)
        {
            return v;
        }

        inline static FloatCompFlag Int16FlagToFloat(Int16CompFlag v)
        {
            return v;
        }

        inline static uint16_t FloatToUInt16(float v)
        {
            return static_cast<uint16_t>(floorf(v + 0.5f));
        }

        inline static float Sqrt(float f)
        {
            return sqrtf(f);
        }

        inline static uint16_t SqDiff(uint16_t a, uint16_t b)
        {
            int diff = static_cast<int>(a) - static_cast<int>(b);
            return static_cast<uint16_t>(diff * diff);
        }

        inline static bool AnySet(bool b)
        {
            return b;
        }

        inline static bool AllSet(bool b)
        {
            return b;
        }

        inline static int16_t UnsignedRightShift(int16_t v, int bits)
        {
            uint32_t i = static_cast<uint32_t>(v) & 0xffff;
            return static_cast<int16_t>(i >> bits);
        }

        inline static float Reciprocal(float f)
        {
            return 1.0f / f;
        }
    };

#endif

    struct PackingVector
    {
        uint32_t m_vector[4];
        int m_offset;

        void Init()
        {
            for (int i = 0; i < 4; i++)
                m_vector[i] = 0;

            m_offset = 0;
        }

        inline void Pack(uint16_t value, int bits)
        {
            int vOffset = m_offset >> 5;
            int bitOffset = m_offset & 0x1f;

            m_vector[vOffset] |= (static_cast<uint32_t>(value) << bitOffset) & static_cast<uint32_t>(0xffffffff);

            int overflowBits = bitOffset + bits - 32;
            if (overflowBits > 0)
                m_vector[vOffset + 1] |= (static_cast<uint32_t>(value) >> (bits - overflowBits));

            m_offset += bits;
        }

        inline void Flush(uint8_t* output)
        {
            assert(m_offset == 128);

            for (int v = 0; v < 4; v++)
            {
                uint32_t chunk = m_vector[v];
                for (int b = 0; b < 4; b++)
                    output[v * 4 + b] = static_cast<uint8_t>((chunk >> (b * 8)) & 0xff);
            }
        }
    };

    void ComputeTweakFactors2(int tweak, int range, float* outFactors)
    {
        int totalUnits = range - 1;
        int minOutsideUnits = ((tweak >> 1) & 1);
        int maxOutsideUnits = (tweak & 1);
        int insideUnits = totalUnits - minOutsideUnits - maxOutsideUnits;

        outFactors[0] = -static_cast<float>(minOutsideUnits) / static_cast<float>(insideUnits);
        outFactors[1] = static_cast<float>(maxOutsideUnits) / static_cast<float>(insideUnits) + 1.0f;
    }

    template<int TVectorSize>
    class UnfinishedEndpoints
    {
    public:
        typedef ParallelMath::Float MFloat;
        typedef ParallelMath::Int16 MInt16;

        UnfinishedEndpoints()
        {
        }

        UnfinishedEndpoints(const MFloat base[TVectorSize], const MFloat offset[TVectorSize])
        {
            for (int ch = 0; ch < TVectorSize; ch++)
                m_base[ch] = base[ch];
            for (int ch = 0; ch < TVectorSize; ch++)
                m_offset[ch] = offset[ch];
        }

        UnfinishedEndpoints(const UnfinishedEndpoints& other)
            : UnfinishedEndpoints(other.m_base, other.m_offset)
        {
        }

        void Finish(int tweak, int range, MInt16* outEP0, MInt16* outEP1)
        {
            float tweakFactors[2];
            ComputeTweakFactors2(tweak, range, tweakFactors);

            for (int ch = 0; ch < TVectorSize; ch++)
            {
                MFloat ep0f = ParallelMath::Clamp(m_base[ch] + m_offset[ch] * tweakFactors[0], 0.0f, 255.0f);
                MFloat ep1f = ParallelMath::Clamp(m_base[ch] + m_offset[ch] * tweakFactors[1], 0.0f, 255.0f);
                outEP0[ch] = ParallelMath::FloatToUInt16(ep0f);
                outEP1[ch] = ParallelMath::FloatToUInt16(ep1f);
            }
        }

        template<int TNewVectorSize>
        UnfinishedEndpoints<TNewVectorSize> ExpandTo(float filler)
        {
            MFloat newBase[TNewVectorSize];
            MFloat newOffset[TNewVectorSize];

            for (int ch = 0; ch < TNewVectorSize && ch < TVectorSize; ch++)
            {
                newBase[ch] = m_base[ch];
                newOffset[ch] = m_offset[ch];
            }

            MFloat fillerV = ParallelMath::MakeFloat(filler);

            for (int ch = TVectorSize; ch < TNewVectorSize; ch++)
            {
                newBase[ch] = fillerV;
                newOffset[ch] = ParallelMath::MakeFloatZero();
            }

            return UnfinishedEndpoints<TNewVectorSize>(newBase, newOffset);
        }

    private:
        MFloat m_base[TVectorSize];
        MFloat m_offset[TVectorSize];
    };

    template<int TMatrixSize>
    class PackedCovarianceMatrix
    {
    public:
        // 0: xx,
        // 1: xy, yy
        // 3: xz, yz, zz 
        // 6: xw, yw, zw, ww
        // ... etc.
        static const int PyramidSize = (TMatrixSize * (TMatrixSize + 1)) / 2;

        typedef ParallelMath::Float MFloat;

        PackedCovarianceMatrix()
        {
            for (int i = 0; i < PyramidSize; i++)
                m_values[i] = ParallelMath::MakeFloatZero();
        }

        void Add(const ParallelMath::Float vec[TMatrixSize], ParallelMath::Float weight)
        {
            int index = 0;
            for (int row = 0; row < TMatrixSize; row++)
            {
                for (int col = 0; col <= row; col++)
                {
                    m_values[index] = m_values[index] + vec[row] * vec[col] * weight;
                    index++;
                }
            }
        }

        void Product(MFloat outVec[TMatrixSize], const MFloat inVec[TMatrixSize])
        {
            for (int row = 0; row < TMatrixSize; row++)
            {
                MFloat sum = ParallelMath::MakeFloatZero();

                int index = (row * (row + 1)) >> 1;
                for (int col = 0; col < TMatrixSize; col++)
                {
                    sum = sum + inVec[col] * m_values[index];
                    if (col >= row)
                        index += col + 1;
                    else
                        index++;
                }

                outVec[row] = sum;
            }
        }

    private:
        ParallelMath::Float m_values[PyramidSize];
    };

    static const int NumEndpointSelectorPasses = 3;

    template<int TVectorSize, int TIterationCount>
    class EndpointSelector
    {
    public:
        typedef ParallelMath::Float MFloat;

        EndpointSelector()
        {
            for (int ch = 0; ch < TVectorSize; ch++)
            {
                m_centroid[ch] = ParallelMath::MakeFloatZero();
                m_direction[ch] = ParallelMath::MakeFloatZero();
            }
            m_weightTotal = ParallelMath::MakeFloatZero();
            m_minDist = ParallelMath::MakeFloat(FLT_MAX);
            m_maxDist = ParallelMath::MakeFloat(-FLT_MAX);
        }

        void ContributePass(const MFloat value[TVectorSize], int pass, MFloat weight)
        {
            if (pass == 0)
                ContributeCentroid(value, weight);
            else if (pass == 1)
                ContributeDirection(value, weight);
            else if (pass == 2)
                ContributeMinMax(value);
        }

        void FinishPass(int pass)
        {
            if (pass == 0)
                FinishCentroid();
            else if (pass == 1)
                FinishDirection();
        }

        UnfinishedEndpoints<TVectorSize> GetEndpoints(const float channelWeights[TVectorSize]) const
        {
            MFloat unweightedBase[TVectorSize];
            MFloat unweightedOffset[TVectorSize];

            for (int ch = 0; ch < TVectorSize; ch++)
            {
                MFloat min = m_centroid[ch] + m_direction[ch] * m_minDist;
                MFloat max = m_centroid[ch] + m_direction[ch] * m_maxDist;

                float safeWeight = channelWeights[ch];
                if (safeWeight == 0.f)
                    safeWeight = 1.0f;

                unweightedBase[ch] = min / channelWeights[ch];
                unweightedOffset[ch] = (max - min) / channelWeights[ch];
            }

            return UnfinishedEndpoints<TVectorSize>(unweightedBase, unweightedOffset);
        }

    private:
        void ContributeCentroid(const MFloat value[TVectorSize], MFloat weight)
        {
            for (int ch = 0; ch < TVectorSize; ch++)
                m_centroid[ch] = m_centroid[ch] + value[ch] * weight;
            m_weightTotal = m_weightTotal + weight;
        }

        void FinishCentroid()
        {
            MFloat denom = m_weightTotal;
            ParallelMath::MakeSafeDenominator(denom);

            for (int ch = 0; ch < TVectorSize; ch++)
                m_centroid[ch] = m_centroid[ch] / denom;
        }

        void ContributeDirection(const MFloat value[TVectorSize], MFloat weight)
        {
            MFloat diff[TVectorSize];
            for (int ch = 0; ch < TVectorSize; ch++)
                diff[ch] = value[ch] - m_centroid[ch];

            m_covarianceMatrix.Add(diff, weight);
        }

        void FinishDirection()
        {
            MFloat approx[TVectorSize];
            for (int ch = 0; ch < TVectorSize; ch++)
                approx[ch] = ParallelMath::MakeFloat(1.0f);

            for (int i = 0; i < TIterationCount; i++)
            {
                MFloat product[TVectorSize];
                m_covarianceMatrix.Product(product, approx);

                MFloat largestComponent = product[0];
                for (int ch = 1; ch < TVectorSize; ch++)
                    largestComponent = ParallelMath::Max(largestComponent, product[ch]);

                // product = largestComponent*newApprox
                ParallelMath::MakeSafeDenominator(largestComponent);
                for (int ch = 0; ch < TVectorSize; ch++)
                    approx[ch] = product[ch] / largestComponent;
            }

            // Normalize
            MFloat approxLen = ParallelMath::MakeFloatZero();
            for (int ch = 0; ch < TVectorSize; ch++)
                approxLen = approxLen + approx[ch] * approx[ch];

            approxLen = ParallelMath::Sqrt(approxLen);

            ParallelMath::MakeSafeDenominator(approxLen);

            for (int ch = 0; ch < TVectorSize; ch++)
                m_direction[ch] = approx[ch] / approxLen;
        }

        void ContributeMinMax(const MFloat value[TVectorSize])
        {
            MFloat dist = ParallelMath::MakeFloatZero();
            for (int ch = 0; ch < TVectorSize; ch++)
                dist = dist + m_direction[ch] * (value[ch] - m_centroid[ch]);

            m_minDist = ParallelMath::Min(m_minDist, dist);
            m_maxDist = ParallelMath::Max(m_maxDist, dist);
        }
        
        ParallelMath::Float m_centroid[TVectorSize];
        ParallelMath::Float m_direction[TVectorSize];
        PackedCovarianceMatrix<TVectorSize> m_covarianceMatrix;
        ParallelMath::Float m_weightTotal;

        ParallelMath::Float m_minDist;
        ParallelMath::Float m_maxDist;
    };

    template<int TVectorSize>
    class IndexSelector
    {
    public:
        typedef ParallelMath::Float MFloat;
        typedef ParallelMath::Int16 MInt16;

        void Init(const float channelWeights[TVectorSize], MInt16 endPoint[2][TVectorSize], int range)
        {
            m_isUniform = true;
            for (int ch = 1; ch < TVectorSize; ch++)
            {
                if (channelWeights[ch] != channelWeights[0])
                    m_isUniform = false;
            }

            // To work with channel weights, we need something where:
            // pxDiff = px - ep[0]
            // epDiff = ep[1] - ep[0]
            //
            // weightedEPDiff = epDiff * channelWeights
            // normalizedWeightedAxis = weightedEPDiff / len(weightedEPDiff)
            // normalizedIndex = dot(pxDiff * channelWeights, normalizedWeightedAxis) / len(weightedEPDiff)
            // index = normalizedIndex * maxValue
            //
            // Equivalent to:
            // axis = channelWeights * maxValue * epDiff * channelWeights / lenSquared(epDiff * channelWeights)
            // index = dot(axis, pxDiff)

            for (int ep = 0; ep < 2; ep++)
                for (int ch = 0; ch < TVectorSize; ch++)
                    m_endPoint[ep][ch] = endPoint[ep][ch];

            m_range = range;
            m_maxValue = static_cast<float>(range - 1);

            MFloat epDiffWeighted[TVectorSize];
            for (int ch = 0; ch < TVectorSize; ch++)
            {
                m_origin[ch] = ParallelMath::UInt16ToFloat(endPoint[0][ch]);

                epDiffWeighted[ch] = (ParallelMath::UInt16ToFloat(endPoint[1][ch]) - m_origin[ch]) * channelWeights[ch];
            }

            MFloat lenSquared = epDiffWeighted[0] * epDiffWeighted[0];
            for (int ch = 1; ch < TVectorSize; ch++)
                lenSquared = lenSquared + epDiffWeighted[ch] * epDiffWeighted[ch];

            ParallelMath::MakeSafeDenominator(lenSquared);

            for (int ch = 0; ch < TVectorSize; ch++)
                m_axis[ch] = epDiffWeighted[ch] * (m_maxValue * channelWeights[ch]) / lenSquared;
        }

        void Reconstruct(MInt16 index, MInt16* pixel)
        {
            MInt16 weightRcp = ParallelMath::MakeUInt16(0);
            if (m_range == 3)
                weightRcp = ParallelMath::MakeUInt16(16384);
            else if (m_range == 4)
                weightRcp = ParallelMath::MakeUInt16(10923);
            else if (m_range == 6)
                weightRcp = ParallelMath::MakeUInt16(6554);
            else if (m_range == 8)
                weightRcp = ParallelMath::MakeUInt16(4681);
            else if (m_range == 16)
                weightRcp = ParallelMath::MakeUInt16(2184);

            MInt16 weight = ParallelMath::UnsignedRightShift(index * weightRcp + 256, 9);

            for (int ch = 0; ch < TVectorSize; ch++)
                pixel[ch] = ParallelMath::UnsignedRightShift(((ParallelMath::MakeUInt16(64) - weight) * m_endPoint[0][ch] + weight * m_endPoint[1][ch] + ParallelMath::MakeUInt16(32)), 6);
        }

        MInt16 SelectIndex(const MInt16* pixel)
        {
            MFloat diff[TVectorSize];
            for (int ch = 0; ch < TVectorSize; ch++)
                diff[ch] = ParallelMath::UInt16ToFloat(pixel[ch]) - m_origin[ch];

            MFloat dist = diff[0] * m_axis[0];
            for (int ch = 1; ch < TVectorSize; ch++)
                dist = dist + diff[ch] * m_axis[ch];

            return ParallelMath::FloatToUInt16(ParallelMath::Clamp(dist, 0.0f, m_maxValue));
        }

    private:
        MInt16 m_endPoint[2][TVectorSize];
        MFloat m_origin[TVectorSize];
        MFloat m_axis[TVectorSize];
        int m_range;
        float m_maxValue;
        bool m_isUniform;
    };

    // Solve for a, b where v = a*t + b
    // This allows endpoints to be mapped to where T=0 and T=1
    // Least squares from totals:
    // a = (tv - t*v/w)/(tt - t*t/w)
    // b = (v - a*t)/w
    template<int TVectorSize>
    class EndpointRefiner
    {
    public:
        typedef ParallelMath::Float MFloat;
        typedef ParallelMath::Int16 MInt16;

        MFloat m_tv[TVectorSize];
        MFloat m_v[TVectorSize];
        MFloat m_tt;
        MFloat m_t;
        MFloat m_w;

        float m_rcpMaxIndex;
        float m_channelWeights[TVectorSize];
        float m_rcpChannelWeights[TVectorSize];

        void Init(int indexRange, const float channelWeights[TVectorSize])
        {
            for (int ch = 0; ch < TVectorSize; ch++)
            {
                m_tv[ch] = ParallelMath::MakeFloatZero();
                m_v[ch] = ParallelMath::MakeFloatZero();
            }
            m_tt = ParallelMath::MakeFloatZero();
            m_t = ParallelMath::MakeFloatZero();
            m_w = ParallelMath::MakeFloatZero();

            m_rcpMaxIndex = 1.0f / static_cast<float>(indexRange - 1);

            for (int ch = 0; ch < TVectorSize; ch++)
            {
                m_channelWeights[ch] = channelWeights[ch];
                m_rcpChannelWeights[ch] = 1.0f;
                if (m_channelWeights[ch] != 0.0f)
                    m_rcpChannelWeights[ch] = 1.0f / channelWeights[ch];
            }
        }

        void Contribute(const MInt16* pixel, MInt16 index, MFloat weight)
        {
            MFloat t = ParallelMath::UInt16ToFloat(index) * m_rcpMaxIndex;

            for (int ch = 0; ch < TVectorSize; ch++)
            {
                MFloat v = ParallelMath::UInt16ToFloat(pixel[ch]) * (weight * m_channelWeights[ch]);

                m_tv[ch] = m_tv[ch] + t * v;
                m_v[ch] = m_v[ch] + v;
            }
            m_tt = m_tt + weight * t * t;
            m_t = m_t + weight * t;
            m_w = m_w + weight;
        }

        void GetRefinedEndpoints(MInt16 endPoint[2][TVectorSize])
        {
            // a = (tv - t*v/w)/(tt - t*t/w)
            // b = (v - a*t)/w
            MFloat w = m_w;

            ParallelMath::MakeSafeDenominator(w);
            MFloat wRcp = ParallelMath::Reciprocal(w);

            MFloat adenom = (m_tt * m_w - m_t * m_t) * wRcp;

            ParallelMath::FloatCompFlag adenomZero = ParallelMath::Equal(adenom, ParallelMath::MakeFloatZero());
            ParallelMath::ConditionalSet(adenom, adenomZero, ParallelMath::MakeFloat(1.0f));

            for (int ch = 0; ch < TVectorSize; ch++)
            {
                /*
                if (adenom == 0.0)
                    p1 = p2 = er.v / er.w;
                else
                {
                    float4 a = (er.tv - er.t*er.v / er.w) / adenom;
                    float4 b = (er.v - a * er.t) / er.w;
                    p1 = b;
                    p2 = a + b;
                }
                */

                MFloat a = (m_tv[ch] - m_t * m_v[ch] * wRcp) / adenom;
                MFloat b = (m_v[ch] - a * m_t) * wRcp;

                MFloat p1 = b;
                MFloat p2 = a + b;

                ParallelMath::ConditionalSet(p1, adenomZero, (m_v[ch] * wRcp));
                ParallelMath::ConditionalSet(p2, adenomZero, p1);

                // Unweight
                float inverseWeight = m_rcpChannelWeights[ch];

                endPoint[0][ch] = ParallelMath::FloatToUInt16(ParallelMath::Clamp(p1 * inverseWeight, 0.f, 255.0f));
                endPoint[1][ch] = ParallelMath::FloatToUInt16(ParallelMath::Clamp(p2 * inverseWeight, 0.f, 255.0f));
            }
        }
    };

    class BCCommon
    {
    public:
        typedef ParallelMath::Int16 MInt16;
        typedef ParallelMath::Int32 MInt32;
        typedef ParallelMath::Float MFloat;

        static int TweakRoundsForRange(int range)
        {
            if (range == 3)
                return 3;
            return 4;
        }

        template<int TVectorSize>
        static MFloat ComputeError(DWORD flags, const MInt16 reconstructed[TVectorSize], const MInt16 original[TVectorSize], const float channelWeights[TVectorSize])
        {
            MFloat error = ParallelMath::MakeFloatZero();
            if (flags & BC_FLAGS_UNIFORM)
            {
                for (int ch = 0; ch < TVectorSize; ch++)
                    error = error + ParallelMath::UInt16ToFloat(ParallelMath::SqDiff(reconstructed[ch], original[ch]));
            }
            else
            {
                for (int ch = 0; ch < TVectorSize; ch++)
                    error = error + ParallelMath::UInt16ToFloat(ParallelMath::SqDiff(reconstructed[ch], original[ch])) * ParallelMath::MakeFloat(channelWeights[ch]);
            }

            return error;
        }

        template<int TChannelCount>
        static void PreWeightPixels(MFloat preWeightedPixels[16][TChannelCount], const MInt16 pixels[16][TChannelCount], const float channelWeights[TChannelCount])
        {
            for (int px = 0; px < 16; px++)
            {
                for (int ch = 0; ch < TChannelCount; ch++)
                    preWeightedPixels[px][ch] = ParallelMath::UInt16ToFloat(pixels[px][ch]) * channelWeights[ch];
            }
        }
    };

    class BC7Computer
    {
    public:
        static const int NumTweakRounds = 4;
        static const int NumRefineRounds = 2;

        typedef ParallelMath::Int16 MInt16;
        typedef ParallelMath::Int32 MInt32;
        typedef ParallelMath::Float MFloat;

        struct WorkInfo
        {
            MInt16 m_mode;
            MFloat m_error;
            MInt16 m_ep[3][2][4];
            MInt16 m_indexes[16];
            MInt16 m_indexes2[16];

            union
            {
                MInt16 m_partition;
                struct IndexSelectorAndRotation
                {
                    MInt16 m_indexSelector;
                    MInt16 m_rotation;
                } m_isr;
            };
        };

        static void TweakAlpha(const MInt16 original[2], int tweak, int range, MInt16 result[2])
        {
            float tf[2];
            ComputeTweakFactors2(tweak, range, tf);

            MFloat base = ParallelMath::UInt16ToFloat(original[0]);
            MFloat offs = ParallelMath::UInt16ToFloat(original[1]) - base;

            result[0] = ParallelMath::FloatToUInt16(ParallelMath::Clamp(base + offs * tf[0], 0.0f, 255.0f));
            result[1] = ParallelMath::FloatToUInt16(ParallelMath::Clamp(base + offs * tf[1], 0.0f, 255.0f));
        }

        static void Quantize(MInt16* color, int bits, int channels)
        {
            float maxColor = static_cast<float>((1 << bits) - 1);

            for (int i = 0; i < channels; i++)
                color[i] = ParallelMath::FloatToUInt16(ParallelMath::Clamp(ParallelMath::UInt16ToFloat(color[i]) * ParallelMath::MakeFloat(1.0f / 255.0f) * maxColor, 0.f, 255.f));
        }

        static void QuantizeP(MInt16* color, int bits, uint16_t p, int channels)
        {
            uint16_t pShift = static_cast<uint16_t>(1 << (7 - bits));
            MInt16 pShiftV = ParallelMath::MakeUInt16(pShift);

            float maxColorF = static_cast<float>(255 - (1 << (7 - bits)));

            float maxQuantized = static_cast<float>((1 << bits) - 1);

            for (int ch = 0; ch < channels; ch++)
            {
                MInt16 clr = color[ch];
                if (p)
                    clr = ParallelMath::Max(clr, pShiftV) - pShiftV;

                MFloat rerangedColor = ParallelMath::UInt16ToFloat(clr) * maxQuantized / maxColorF;

                clr = ParallelMath::FloatToUInt16(ParallelMath::Clamp(rerangedColor, 0.0f, maxQuantized)) << 1;
                if (p)
                    clr = clr | ParallelMath::MakeUInt16(1);

                color[ch] = clr;
            }
        }

        static void Unquantize(MInt16* color, int bits, int channels)
        {
            for (int ch = 0; ch < channels; ch++)
            {
                MInt16 clr = color[ch];
                clr = clr << (8 - bits);
                color[ch] = clr | ParallelMath::UnsignedRightShift(clr, bits);
            }
        }

        static void CompressEndpoints0(MInt16 ep[2][4], uint16_t p[2])
        {
            for (int j = 0; j < 2; j++)
            {
                QuantizeP(ep[j], 4, p[j], 3);
                Unquantize(ep[j], 5, 3);
                ep[j][3] = ParallelMath::MakeUInt16(255);
            }
        }

        static void CompressEndpoints1(MInt16 ep[2][4], uint16_t p)
        {
            for (int j = 0; j < 2; j++)
            {
                QuantizeP(ep[j], 6, p, 3);
                Unquantize(ep[j], 7, 3);
                ep[j][3] = ParallelMath::MakeUInt16(255);
            }
        }

        static void CompressEndpoints2(MInt16 ep[2][4])
        {
            for (int j = 0; j < 2; j++)
            {
                Quantize(ep[j], 5, 3);
                Unquantize(ep[j], 5, 3);
                ep[j][3] = ParallelMath::MakeUInt16(255);
            }
        }

        static void CompressEndpoints3(MInt16 ep[2][4], uint16_t p[2])
        {
            for (int j = 0; j < 2; j++)
                QuantizeP(ep[j], 7, p[j], 3);
        }

        static void CompressEndpoints4(MInt16 epRGB[2][3], MInt16 epA[2])
        {
            for (int j = 0; j < 2; j++)
            {
                Quantize(epRGB[j], 5, 3);
                Unquantize(epRGB[j], 5, 3);

                Quantize(epA + j, 6, 1);
                Unquantize(epA + j, 6, 1);
            }
        }

        static void CompressEndpoints5(MInt16 epRGB[2][3], MInt16 epA[2])
        {
            for (int j = 0; j < 2; j++)
            {
                Quantize(epRGB[j], 7, 3);
                Unquantize(epRGB[j], 7, 3);
            }

            // Alpha is full precision
            (void)epA;
        }

        static void CompressEndpoints6(MInt16 ep[2][4], uint16_t p[2])
        {
            for (int j = 0; j < 2; j++)
                QuantizeP(ep[j], 7, p[j], 4);
        }

        static void CompressEndpoints7(MInt16 ep[2][4], uint16_t p[2])
        {
            for (int j = 0; j < 2; j++)
            {
                QuantizeP(ep[j], 5, p[j], 4);
                Unquantize(ep[j], 6, 4);
            }
        }

        struct SinglePlaneTemporaries
        {
            UnfinishedEndpoints<3> unfinishedRGB[BC7Data::g_numShapesAll];
            UnfinishedEndpoints<4> unfinishedRGBA[BC7Data::g_numShapes12];

            MInt16 fragmentBestIndexes[BC7Data::g_numFragments];
            MInt16 shapeBestEP[BC7Data::g_maxFragmentsPerMode][2][4];
            MFloat shapeBestError[BC7Data::g_maxFragmentsPerMode];
        };

        static void TrySinglePlane(DWORD flags, const MInt16 pixels[16][4], const float channelWeights[4], WorkInfo& work)
        {
            SinglePlaneTemporaries temps;

            MInt16 maxAlpha = ParallelMath::MakeUInt16(0);
            MInt16 minAlpha = ParallelMath::MakeUInt16(255);
            for (int px = 0; px < 16; px++)
            {
                maxAlpha = ParallelMath::Max(maxAlpha, pixels[px][3]);
                minAlpha = ParallelMath::Min(minAlpha, pixels[px][3]);
            }

            bool anyBlockHasAlpha = ParallelMath::AnySet(ParallelMath::Less(maxAlpha, ParallelMath::MakeUInt16(255)));

            // Try RGB modes if any block has a min alpha 251 or higher
            bool allowRGBModes = ParallelMath::AnySet(ParallelMath::Less(ParallelMath::MakeUInt16(250), minAlpha));

            // Try mode 7 if any block has alpha.
            // Mode 7 is almost never selected for RGB blocks because mode 4 has very accurate 7.7.7.1 endpoints
            // and its parity bit doesn't affect alpha, meaning mode 7 can only be better in extremely specific
            // situations, and only by at most 1 unit of error per pixel.
            bool allowMode7 = anyBlockHasAlpha;

            MFloat preWeightedPixels[16][4];

            BCCommon::PreWeightPixels<4>(preWeightedPixels, pixels, channelWeights);

            const int *rgbInitialEPCollapseList = NULL;

            // Get initial RGB endpoints
            if (allowRGBModes)
            {
                const int *shapeList;
                int numShapesToEvaluate;

                if (flags & BC_FLAGS_USE_3SUBSETS)
                {
                    shapeList = BC7Data::g_shapeListAll;
                    rgbInitialEPCollapseList = BC7Data::g_shapeListAll;
                    numShapesToEvaluate = BC7Data::g_numShapesAll;
                }
                else
                {
                    shapeList = BC7Data::g_shapeList12;
                    rgbInitialEPCollapseList = BC7Data::g_shapeList12Collapse;
                    numShapesToEvaluate = BC7Data::g_numShapes12;
                }

                for (int shapeIter = 0; shapeIter < numShapesToEvaluate; shapeIter++)
                {
                    int shape = shapeList[shapeIter];

                    int shapeStart = BC7Data::g_shapeRanges[shape][0];
                    int shapeSize = BC7Data::g_shapeRanges[shape][1];

                    EndpointSelector<3, 8> epSelector;

                    for (int epPass = 0; epPass < NumEndpointSelectorPasses; epPass++)
                    {
                        for (int spx = 0; spx < shapeSize; spx++)
                        {
                            int px = BC7Data::g_fragments[shapeStart + spx];
                            epSelector.ContributePass(preWeightedPixels[px], epPass, ParallelMath::MakeFloat(1.0f));
                        }
                        epSelector.FinishPass(epPass);
                    }
                    temps.unfinishedRGB[shapeIter] = epSelector.GetEndpoints(channelWeights);
                }
            }

            const int *rgbaInitialEPCollapseList = BC7Data::g_shapeList12Collapse;

            // Get initial RGBA endpoints
            {
                const int *shapeList = BC7Data::g_shapeList12;
                int numShapesToEvaluate = BC7Data::g_numShapes12;

                for (int shapeIter = 0; shapeIter < numShapesToEvaluate; shapeIter++)
                {
                    int shape = shapeList[shapeIter];

                    if (anyBlockHasAlpha || !allowRGBModes)
                    {
                        int shapeStart = BC7Data::g_shapeRanges[shape][0];
                        int shapeSize = BC7Data::g_shapeRanges[shape][1];

                        EndpointSelector<4, 8> epSelector;

                        for (int epPass = 0; epPass < NumEndpointSelectorPasses; epPass++)
                        {
                            for (int spx = 0; spx < shapeSize; spx++)
                            {
                                int px = BC7Data::g_fragments[shapeStart + spx];
                                epSelector.ContributePass(preWeightedPixels[px], epPass, ParallelMath::MakeFloat(1.0f));
                            }
                            epSelector.FinishPass(epPass);
                        }
                        temps.unfinishedRGBA[shapeIter] = epSelector.GetEndpoints(channelWeights);
                    }
                    else
                    {
                        temps.unfinishedRGBA[shapeIter] = temps.unfinishedRGB[rgbInitialEPCollapseList[shape]].ExpandTo<4>(255);
                    }
                }
            }

            for (uint16_t mode = 0; mode <= 7; mode++)
            {
                if ((flags & BC_FLAGS_FORCE_BC7_MODE6) && mode != 6)
                    continue;

                if (!(flags & BC_FLAGS_USE_3SUBSETS) && BC7Data::g_modes[mode].m_numSubsets == 3)
                    continue;

                if (mode == 4 || mode == 5)
                    continue;

                if (mode < 4 && !allowRGBModes)
                    continue;

                if (mode == 7 && !allowMode7)
                    continue;

                bool isRGB = (mode < 4);

                unsigned int numPartitions = 1 << BC7Data::g_modes[mode].m_partitionBits;
                int numSubsets = BC7Data::g_modes[mode].m_numSubsets;
                int indexPrec = BC7Data::g_modes[mode].m_indexBits;

                int parityBitMax = 1;
                if (BC7Data::g_modes[mode].m_pBitMode == BC7Data::PBitMode_PerEndpoint)
                    parityBitMax = 4;
                else if (BC7Data::g_modes[mode].m_pBitMode == BC7Data::PBitMode_PerSubset)
                    parityBitMax = 2;

                int numShapes;
                const int *shapeList;
                const int *shapeCollapseList;

                if (numSubsets == 1)
                {
                    numShapes = BC7Data::g_numShapes1;
                    shapeList = BC7Data::g_shapeList1;
                    shapeCollapseList = BC7Data::g_shapeList1Collapse;
                }
                else if (numSubsets == 2)
                {
                    numShapes = BC7Data::g_numShapes2;
                    shapeList = BC7Data::g_shapeList2;
                    shapeCollapseList = BC7Data::g_shapeList2Collapse;
                }
                else
                {
                    assert(numSubsets == 3);
                    if (numPartitions == 16)
                    {
                        numShapes = BC7Data::g_numShapes3Short;
                        shapeList = BC7Data::g_shapeList3Short;
                        shapeCollapseList = BC7Data::g_shapeList3ShortCollapse;
                    }
                    else
                    {
                        assert(numPartitions == 64);
                        numShapes = BC7Data::g_numShapes3;
                        shapeList = BC7Data::g_shapeList3;
                        shapeCollapseList = BC7Data::g_shapeList3Collapse;
                    }
                }

                for (int slot = 0; slot < BC7Data::g_maxFragmentsPerMode; slot++)
                    temps.shapeBestError[slot] = ParallelMath::MakeFloat(FLT_MAX);

                for (int shapeIter = 0; shapeIter < numShapes; shapeIter++)
                {
                    int shape = shapeList[shapeIter];
                    int shapeStart = BC7Data::g_shapeRanges[shape][0];
                    int shapeLength = BC7Data::g_shapeRanges[shape][1];
                    int shapeCollapsedEvalIndex = shapeCollapseList[shape];

                    assert(shapeCollapsedEvalIndex >= 0);

                    for (int tweak = 0; tweak < NumTweakRounds; tweak++)
                    {
                        MInt16 baseEP[2][4];

                        if (isRGB)
                        {
                            temps.unfinishedRGB[rgbInitialEPCollapseList[shape]].Finish(tweak, 1 << indexPrec, baseEP[0], baseEP[1]);
                            baseEP[0][3] = baseEP[1][3] = ParallelMath::MakeUInt16(255);
                        }
                        else
                        {
                            temps.unfinishedRGBA[rgbaInitialEPCollapseList[shape]].Finish(tweak, 1 << indexPrec, baseEP[0], baseEP[1]);
                        }

                        for (int pIter = 0; pIter < parityBitMax; pIter++)
                        {
                            uint16_t p[2];
                            p[0] = (pIter & 1);
                            p[1] = ((pIter >> 1) & 1);

                            MInt16 ep[2][4];

                            for (int epi = 0; epi < 2; epi++)
                                for (int ch = 0; ch < 4; ch++)
                                    ep[epi][ch] = baseEP[epi][ch];

                            for (int refine = 0; refine < NumRefineRounds; refine++)
                            {
                                switch (mode)
                                {
                                case 0:
                                    CompressEndpoints0(ep, p);
                                    break;
                                case 1:
                                    CompressEndpoints1(ep, p[0]);
                                    break;
                                case 2:
                                    CompressEndpoints2(ep);
                                    break;
                                case 3:
                                    CompressEndpoints3(ep, p);
                                    break;
                                case 6:
                                    CompressEndpoints6(ep, p);
                                    break;
                                case 7:
                                    CompressEndpoints7(ep, p);
                                    break;
                                default:
                                    assert(false);
                                    break;
                                };

                                MFloat shapeError = ParallelMath::MakeFloatZero();

                                IndexSelector<4> indexSelector;
                                indexSelector.Init(channelWeights, ep, 1 << indexPrec);

                                EndpointRefiner<4> epRefiner;
                                epRefiner.Init(1 << indexPrec, channelWeights);

                                MInt16 indexes[16];

                                for (int pxi = 0; pxi < shapeLength; pxi++)
                                {
                                    int px = BC7Data::g_fragments[shapeStart + pxi];

                                    MInt16 index = indexSelector.SelectIndex(pixels[px]);

                                    epRefiner.Contribute(pixels[px], index, ParallelMath::MakeFloat(1.0f));

                                    MInt16 reconstructed[4];

                                    indexSelector.Reconstruct(index, reconstructed);

                                    shapeError = shapeError + BCCommon::ComputeError<4>(flags, reconstructed, pixels[px], channelWeights);

                                    indexes[pxi] = index;
                                }

                                ParallelMath::FloatCompFlag shapeErrorBetter;
                                ParallelMath::Int16CompFlag shapeErrorBetter16;

                                bool anyImprovements = false;

                                shapeErrorBetter = ParallelMath::Less(shapeError, temps.shapeBestError[shapeCollapsedEvalIndex]);
                                shapeErrorBetter16 = ParallelMath::FloatFlagToInt16(shapeErrorBetter);

                                if (ParallelMath::AnySet(shapeErrorBetter16))
                                {
                                    ParallelMath::ConditionalSet(temps.shapeBestError[shapeCollapsedEvalIndex], shapeErrorBetter, shapeError);
                                    for (int epi = 0; epi < 2; epi++)
                                        for (int ch = 0; ch < 4; ch++)
                                            ParallelMath::ConditionalSet(temps.shapeBestEP[shapeCollapsedEvalIndex][epi][ch], shapeErrorBetter16, ep[epi][ch]);

                                    for (int pxi = 0; pxi < shapeLength; pxi++)
                                        ParallelMath::ConditionalSet(temps.fragmentBestIndexes[shapeStart + pxi], shapeErrorBetter16, indexes[pxi]);
                                }

                                if (refine != NumRefineRounds - 1)
                                    epRefiner.GetRefinedEndpoints(ep);
                            } // refine
                        } // p
                    } // tweak
                } // shapeIter

                for (uint16_t partition = 0; partition < numPartitions; partition++)
                {
                    const int *partitionShapes;
                    if (numSubsets == 1)
                        partitionShapes = BC7Data::g_shapes1[partition];
                    else if (numSubsets == 2)
                        partitionShapes = BC7Data::g_shapes2[partition];
                    else
                    {
                        assert(numSubsets == 3);
                        partitionShapes = BC7Data::g_shapes3[partition];
                    }

                    MFloat totalError = ParallelMath::MakeFloatZero();
                    for (int subset = 0; subset < numSubsets; subset++)
                        totalError = totalError + temps.shapeBestError[shapeCollapseList[partitionShapes[subset]]];


                    ParallelMath::FloatCompFlag errorBetter = ParallelMath::Less(totalError, work.m_error);
                    ParallelMath::Int16CompFlag errorBetter16 = ParallelMath::FloatFlagToInt16(errorBetter);

                    if (ParallelMath::AnySet(errorBetter16))
                    {
                        for (int subset = 0; subset < numSubsets; subset++)
                        {
                            int shape = partitionShapes[subset];
                            int shapeStart = BC7Data::g_shapeRanges[shape][0];
                            int shapeLength = BC7Data::g_shapeRanges[shape][1];
                            int shapeCollapsedEvalIndex = shapeCollapseList[shape];

                            for (int epi = 0; epi < 2; epi++)
                                for (int ch = 0; ch < 4; ch++)
                                    ParallelMath::ConditionalSet(work.m_ep[subset][epi][ch], errorBetter16, temps.shapeBestEP[shapeCollapsedEvalIndex][epi][ch]);

                            for (int pxi = 0; pxi < shapeLength; pxi++)
                            {
                                int px = BC7Data::g_fragments[shapeStart + pxi];
                                ParallelMath::ConditionalSet(work.m_indexes[px], errorBetter16, temps.fragmentBestIndexes[shapeStart + pxi]);
                            }
                        }

                        work.m_error = ParallelMath::Min(totalError, work.m_error);
                        ParallelMath::ConditionalSet(work.m_mode, errorBetter16, ParallelMath::MakeUInt16(mode));
                        ParallelMath::ConditionalSet(work.m_partition, errorBetter16, ParallelMath::MakeUInt16(partition));
                    }
                }
            }
        }

        static void TryDualPlane(DWORD flags, const MInt16 pixels[16][4], const float channelWeights[4], WorkInfo& work)
        {
            // TODO: These error calculations are not optimal for weight-by-alpha, but this routine needs to be mostly rewritten for that.
            // The alpha/color solutions are co-dependent in that case, but a good way to solve it would probably be to
            // solve the alpha channel first, then solve the RGB channels, which in turn breaks down into two cases:
            // - Separate alpha channel, then weighted RGB
            // - Alpha+2 other channels, then the independent channel

            if (flags & BC_FLAGS_FORCE_BC7_MODE6)
                return; // Mode 6 is not a dual-plane mode, skip it

            for (uint16_t mode = 4; mode <= 5; mode++)
            {
                for (uint16_t rotation = 0; rotation < 4; rotation++)
                {
                    int alphaChannel = (rotation + 3) & 3;
                    int redChannel = (rotation == 1) ? 3 : 0;
                    int greenChannel = (rotation == 2) ? 3 : 1;
                    int blueChannel = (rotation == 3) ? 3 : 2;

                    MInt16 rotatedRGB[16][3];

                    for (int px = 0; px < 16; px++)
                    {
                        rotatedRGB[px][0] = pixels[px][redChannel];
                        rotatedRGB[px][1] = pixels[px][greenChannel];
                        rotatedRGB[px][2] = pixels[px][blueChannel];
                    }

                    uint16_t maxIndexSelector = (mode == 4) ? 2 : 1;

                    float rotatedRGBWeights[3] = { channelWeights[redChannel], channelWeights[greenChannel], channelWeights[blueChannel] };
                    float rotatedAlphaWeight[1] = { channelWeights[alphaChannel] };

                    float uniformWeight[1] = { 1.0f };   // Since the alpha channel is independent, there's no need to bother with weights when doing refinement or selection, only error

                    MFloat preWeightedRotatedRGB[16][3];
                    BCCommon::PreWeightPixels<3>(preWeightedRotatedRGB, rotatedRGB, rotatedRGBWeights);

                    for (uint16_t indexSelector = 0; indexSelector < maxIndexSelector; indexSelector++)
                    {
                        EndpointSelector<3, 8> rgbSelector;

                        for (int epPass = 0; epPass < NumEndpointSelectorPasses; epPass++)
                        {
                            for (int px = 0; px < 16; px++)
                                rgbSelector.ContributePass(preWeightedRotatedRGB[px], epPass, ParallelMath::MakeFloat(1.0f));

                            rgbSelector.FinishPass(epPass);
                        }

                        MInt16 alphaRange[2];

                        alphaRange[0] = alphaRange[1] = pixels[0][alphaChannel];
                        for (int px = 1; px < 16; px++)
                        {
                            alphaRange[0] = ParallelMath::Min(pixels[px][alphaChannel], alphaRange[0]);
                            alphaRange[1] = ParallelMath::Max(pixels[px][alphaChannel], alphaRange[1]);
                        }

                        int rgbPrec = 0;
                        int alphaPrec = 0;

                        if (mode == 4)
                        {
                            rgbPrec = indexSelector ? 3 : 2;
                            alphaPrec = indexSelector ? 2 : 3;
                        }
                        else
                            rgbPrec = alphaPrec = 2;

                        UnfinishedEndpoints<3> unfinishedRGB = rgbSelector.GetEndpoints(rotatedRGBWeights);

                        MFloat bestRGBError = ParallelMath::MakeFloat(FLT_MAX);
                        MFloat bestAlphaError = ParallelMath::MakeFloat(FLT_MAX);

                        MInt16 bestRGBIndexes[16];
                        MInt16 bestAlphaIndexes[16];
                        MInt16 bestEP[2][4];

                        for (int px = 0; px < 16; px++)
                            bestRGBIndexes[px] = bestAlphaIndexes[px] = ParallelMath::MakeUInt16(0);

                        for (int tweak = 0; tweak < NumTweakRounds; tweak++)
                        {
                            MInt16 rgbEP[2][3];
                            MInt16 alphaEP[2];

                            unfinishedRGB.Finish(tweak, 1 << rgbPrec, rgbEP[0], rgbEP[1]);

                            TweakAlpha(alphaRange, tweak, 1 << alphaPrec, alphaEP);

                            for (int refine = 0; refine < NumRefineRounds; refine++)
                            {
                                if (mode == 4)
                                    CompressEndpoints4(rgbEP, alphaEP);
                                else
                                    CompressEndpoints5(rgbEP, alphaEP);


                                IndexSelector<1> alphaIndexSelector;
                                IndexSelector<3> rgbIndexSelector;

                                {
                                    MInt16 alphaEPTemp[2][1] = { { alphaEP[0] },{ alphaEP[1] } };
                                    alphaIndexSelector.Init(uniformWeight, alphaEPTemp, 1 << alphaPrec);
                                }
                                rgbIndexSelector.Init(rotatedRGBWeights, rgbEP, 1 << rgbPrec);

                                EndpointRefiner<3> rgbRefiner;
                                EndpointRefiner<1> alphaRefiner;

                                rgbRefiner.Init(1 << rgbPrec, rotatedRGBWeights);
                                alphaRefiner.Init(1 << alphaPrec, uniformWeight);

                                MFloat errorRGB = ParallelMath::MakeFloatZero();
                                MFloat errorA = ParallelMath::MakeFloatZero();

                                MInt16 rgbIndexes[16];
                                MInt16 alphaIndexes[16];

                                for (int px = 0; px < 16; px++)
                                {
                                    MInt16 rgbIndex = rgbIndexSelector.SelectIndex(rotatedRGB[px]);
                                    MInt16 alphaIndex = alphaIndexSelector.SelectIndex(pixels[px] + alphaChannel);

                                    rgbRefiner.Contribute(rotatedRGB[px], rgbIndex, ParallelMath::MakeFloat(1.0f));
                                    alphaRefiner.Contribute(pixels[px] + alphaChannel, alphaIndex, ParallelMath::MakeFloat(1.0f));

                                    MInt16 reconstructedRGB[3];
                                    MInt16 reconstructedAlpha[1];

                                    rgbIndexSelector.Reconstruct(rgbIndex, reconstructedRGB);
                                    alphaIndexSelector.Reconstruct(alphaIndex, reconstructedAlpha);

                                    errorRGB = errorRGB + BCCommon::ComputeError<3>(flags, reconstructedRGB, rotatedRGB[px], rotatedRGBWeights);

                                    errorA = errorA + BCCommon::ComputeError<1>(flags, reconstructedAlpha, pixels[px] + alphaChannel, rotatedAlphaWeight);

                                    rgbIndexes[px] = rgbIndex;
                                    alphaIndexes[px] = alphaIndex;
                                }

                                ParallelMath::FloatCompFlag rgbBetter = ParallelMath::Less(errorRGB, bestRGBError);
                                ParallelMath::FloatCompFlag alphaBetter = ParallelMath::Less(errorA, bestAlphaError);

                                ParallelMath::Int16CompFlag rgbBetterInt16 = ParallelMath::FloatFlagToInt16(rgbBetter);
                                ParallelMath::Int16CompFlag alphaBetterInt16 = ParallelMath::FloatFlagToInt16(alphaBetter);

                                bestRGBError = ParallelMath::Min(errorRGB, bestRGBError);
                                bestAlphaError = ParallelMath::Min(errorA, bestAlphaError);

                                for (int px = 0; px < 16; px++)
                                {
                                    ParallelMath::ConditionalSet(bestRGBIndexes[px], rgbBetterInt16, rgbIndexes[px]);
                                    ParallelMath::ConditionalSet(bestAlphaIndexes[px], alphaBetterInt16, alphaIndexes[px]);
                                }

                                for (int ep = 0; ep < 2; ep++)
                                {
                                    for (int ch = 0; ch < 3; ch++)
                                        ParallelMath::ConditionalSet(bestEP[ep][ch], rgbBetterInt16, rgbEP[ep][ch]);
                                    ParallelMath::ConditionalSet(bestEP[ep][3], alphaBetterInt16, alphaEP[ep]);
                                }

                                if (refine != NumRefineRounds - 1)
                                {
                                    rgbRefiner.GetRefinedEndpoints(rgbEP);

                                    MInt16 alphaEPTemp[2][1];
                                    alphaRefiner.GetRefinedEndpoints(alphaEPTemp);

                                    for (int i = 0; i < 2; i++)
                                        alphaEP[i] = alphaEPTemp[i][0];
                                }
                            }	// refine
                        } // tweak

                        MFloat combinedError = bestRGBError + bestAlphaError;

                        ParallelMath::FloatCompFlag errorBetter = ParallelMath::Less(combinedError, work.m_error);
                        ParallelMath::Int16CompFlag errorBetter16 = ParallelMath::FloatFlagToInt16(errorBetter);

                        work.m_error = ParallelMath::Min(combinedError, work.m_error);

                        ParallelMath::ConditionalSet(work.m_mode, errorBetter16, ParallelMath::MakeUInt16(mode));
                        ParallelMath::ConditionalSet(work.m_isr.m_rotation, errorBetter16, ParallelMath::MakeUInt16(rotation));
                        ParallelMath::ConditionalSet(work.m_isr.m_indexSelector, errorBetter16, ParallelMath::MakeUInt16(indexSelector));

                        for (int px = 0; px < 16; px++)
                        {
                            ParallelMath::ConditionalSet(work.m_indexes[px], errorBetter16, indexSelector ? bestAlphaIndexes[px] : bestRGBIndexes[px]);
                            ParallelMath::ConditionalSet(work.m_indexes2[px], errorBetter16, indexSelector ? bestRGBIndexes[px] : bestAlphaIndexes[px]);
                        }

                        for (int ep = 0; ep < 2; ep++)
                            for (int ch = 0; ch < 4; ch++)
                                ParallelMath::ConditionalSet(work.m_ep[0][ep][ch], errorBetter16, bestEP[ep][ch]);
                    }
                }
            }
        }

        template<class T>
        static void Swap(T& a, T& b)
        {
            T temp = a;
            a = b;
            b = temp;
        }

        static void Pack(DWORD flags, const InputBlock* inputs, uint8_t* packedBlocks, const float channelWeights[4])
        {
            MInt16 pixels[16][4];

            for (int px = 0; px < 16; px++)
            {
                MInt32 packedPx;
                ParallelMath::ReadPackedInputs(inputs, px, packedPx);

                for (int ch = 0; ch < 4; ch++)
                    ParallelMath::UnpackChannel(packedPx, ch, pixels[px][ch]);
            }

            WorkInfo work;
            memset(&work, 0, sizeof(work));

            work.m_error = ParallelMath::MakeFloat(FLT_MAX);

            TrySinglePlane(flags, pixels, channelWeights, work);
            TryDualPlane(flags, pixels, channelWeights, work);

            for (int block = 0; block < ParallelMath::ParallelSize; block++)
            {
                PackingVector pv;
                pv.Init();

                uint16_t mode = ParallelMath::ExtractUInt16(work.m_mode, block);
                uint16_t partition = ParallelMath::ExtractUInt16(work.m_partition, block);
                uint16_t indexSelector = ParallelMath::ExtractUInt16(work.m_isr.m_indexSelector, block);

                const BC7Data::BC7ModeInfo& modeInfo = BC7Data::g_modes[mode];

                uint16_t indexes[16];
                uint16_t indexes2[16];
                uint16_t endPoints[3][2][4];

                for (int i = 0; i < 16; i++)
                {
                    indexes[i] = ParallelMath::ExtractUInt16(work.m_indexes[i], block);
                    if (modeInfo.m_alphaMode == BC7Data::AlphaMode_Separate)
                        indexes2[i] = ParallelMath::ExtractUInt16(work.m_indexes2[i], block);
                }

                for (int subset = 0; subset < 3; subset++)
                {
                    for (int ep = 0; ep < 2; ep++)
                    {
                        for (int ch = 0; ch < 4; ch++)
                            endPoints[subset][ep][ch] = ParallelMath::ExtractUInt16(work.m_ep[subset][ep][ch], block);
                    }
                }

                int fixups[3] = { 0, 0, 0 };

                if (modeInfo.m_alphaMode == BC7Data::AlphaMode_Separate)
                {
                    bool flipRGB = ((indexes[0] & (1 << (modeInfo.m_indexBits - 1))) != 0);
                    bool flipAlpha = ((indexes2[0] & (1 << (modeInfo.m_alphaIndexBits - 1))) != 0);

                    if (flipRGB)
                    {
                        uint16_t highIndex = (1 << modeInfo.m_indexBits) - 1;
                        for (int px = 0; px < 16; px++)
                            indexes[px] = highIndex - indexes[px];
                    }

                    if (flipAlpha)
                    {
                        uint16_t highIndex = (1 << modeInfo.m_alphaIndexBits) - 1;
                        for (int px = 0; px < 16; px++)
                            indexes2[px] = highIndex - indexes2[px];
                    }

                    if (indexSelector)
                        Swap(flipRGB, flipAlpha);

                    if (flipRGB)
                    {
                        for (int ch = 0; ch < 3; ch++)
                            Swap(endPoints[0][0][ch], endPoints[0][1][ch]);
                    }
                    if (flipAlpha)
                        Swap(endPoints[0][0][3], endPoints[0][1][3]);

                }
                else
                {
                    if (modeInfo.m_numSubsets == 2)
                        fixups[1] = BC7Data::g_fixupIndexes2[partition];
                    else if (modeInfo.m_numSubsets == 3)
                    {
                        fixups[1] = BC7Data::g_fixupIndexes3[partition][0];
                        fixups[2] = BC7Data::g_fixupIndexes3[partition][1];
                    }

                    bool flip[3] = { false, false, false };
                    for (int subset = 0; subset < modeInfo.m_numSubsets; subset++)
                        flip[subset] = ((indexes[fixups[subset]] & (1 << (modeInfo.m_indexBits - 1))) != 0);

                    if (flip[0] || flip[1] || flip[2])
                    {
                        uint16_t highIndex = (1 << modeInfo.m_indexBits) - 1;
                        for (int px = 0; px < 16; px++)
                        {
                            int subset = 0;
                            if (modeInfo.m_numSubsets == 2)
                                subset = (BC7Data::g_partitionMap[partition] >> px) & 1;
                            else if (modeInfo.m_numSubsets == 3)
                                subset = (BC7Data::g_partitionMap2[partition] >> (px * 2)) & 3;

                            if (flip[subset])
                                indexes[px] = highIndex - indexes[px];
                        }

                        int maxCH = (modeInfo.m_alphaMode == BC7Data::AlphaMode_Combined) ? 4 : 3;
                        for (int subset = 0; subset < modeInfo.m_numSubsets; subset++)
                        {
                            if (flip[subset])
                                for (int ch = 0; ch < maxCH; ch++)
                                    Swap(endPoints[subset][0][ch], endPoints[subset][1][ch]);
                        }
                    }
                }

                pv.Pack(static_cast<uint8_t>(1 << mode), mode + 1);

                if (modeInfo.m_partitionBits)
                    pv.Pack(partition, modeInfo.m_partitionBits);

                if (modeInfo.m_alphaMode == BC7Data::AlphaMode_Separate)
                {
                    uint16_t rotation = ParallelMath::ExtractUInt16(work.m_isr.m_rotation, block);
                    pv.Pack(rotation, 2);
                }

                if (modeInfo.m_hasIndexSelector)
                    pv.Pack(indexSelector, 1);

                // Encode RGB
                for (int ch = 0; ch < 3; ch++)
                {
                    for (int subset = 0; subset < modeInfo.m_numSubsets; subset++)
                    {
                        for (int ep = 0; ep < 2; ep++)
                        {
                            uint16_t epPart = endPoints[subset][ep][ch];
                            epPart >>= (8 - modeInfo.m_rgbBits);

                            pv.Pack(epPart, modeInfo.m_rgbBits);
                        }
                    }
                }

                // Encode alpha
                if (modeInfo.m_alphaMode != BC7Data::AlphaMode_None)
                {
                    for (int subset = 0; subset < modeInfo.m_numSubsets; subset++)
                    {
                        for (int ep = 0; ep < 2; ep++)
                        {
                            uint16_t epPart = endPoints[subset][ep][3];
                            epPart >>= (8 - modeInfo.m_alphaBits);

                            pv.Pack(epPart, modeInfo.m_alphaBits);
                        }
                    }
                }

                // Encode parity bits
                if (modeInfo.m_pBitMode == BC7Data::PBitMode_PerSubset)
                {
                    for (int subset = 0; subset < modeInfo.m_numSubsets; subset++)
                    {
                        uint16_t epPart = endPoints[subset][0][0];
                        epPart >>= (7 - modeInfo.m_rgbBits);
                        epPart &= 1;

                        pv.Pack(epPart, 1);
                    }
                }
                else if (modeInfo.m_pBitMode == BC7Data::PBitMode_PerEndpoint)
                {
                    for (int subset = 0; subset < modeInfo.m_numSubsets; subset++)
                    {
                        for (int ep = 0; ep < 2; ep++)
                        {
                            uint16_t epPart = endPoints[subset][ep][0];
                            epPart >>= (7 - modeInfo.m_rgbBits);
                            epPart &= 1;

                            pv.Pack(epPart, 1);
                        }
                    }
                }

                // Encode indexes
                for (int px = 0; px < 16; px++)
                {
                    int bits = modeInfo.m_indexBits;
                    if ((px == 0) || (px == fixups[1]) || (px == fixups[2]))
                        bits--;

                    pv.Pack(indexes[px], bits);
                }

                // Encode secondary indexes
                if (modeInfo.m_alphaMode == BC7Data::AlphaMode_Separate)
                {
                    for (int px = 0; px < 16; px++)
                    {
                        int bits = modeInfo.m_alphaIndexBits;
                        if (px == 0)
                            bits--;

                        pv.Pack(indexes2[px], bits);
                    }
                }

                pv.Flush(packedBlocks);

                packedBlocks += 16;
            }
        }
    };

    class S3TCComputer
    {
    public:
        typedef ParallelMath::Float MFloat;
        typedef ParallelMath::Int16 MInt16;
        typedef ParallelMath::Int32 MInt32;

        static const int NumRGBRefineRounds = 2;
        static const int NumAlphaRefineRounds = 8;

        static void Init(MFloat& error)
        {
            error = ParallelMath::MakeFloat(FLT_MAX);
        }

        static void QuantizeToBits(MInt16& v, int bits)
        {
            v = ParallelMath::FloatToUInt16(ParallelMath::Clamp(ParallelMath::UInt16ToFloat(v) * ParallelMath::MakeFloat(1.0f / 255.0f) * static_cast<float>((1 << bits) - 1), 0.f, 255.f));
            v = (v << (8 - bits)) | ParallelMath::UnsignedRightShift(v, (bits * 2 - 8));
        }

        static void QuantizeTo565(MInt16 endPoint[3])
        {
            QuantizeToBits(endPoint[0], 5);
            QuantizeToBits(endPoint[1], 6);
            QuantizeToBits(endPoint[2], 5);
        }

        static void TestEndpoints(DWORD flags, const MInt16 pixels[16][4], const MInt16 unquantizedEndPoints[2][3], int range, const float* channelWeights,
            MFloat &bestError, MInt16 bestEndpoints[2][3], MInt16 bestIndexes[16], MInt16 &bestRange, EndpointRefiner<3> *refiner)
        {
            MInt16 endPoints[2][3];

            for (int ep = 0; ep < 2; ep++)
                for (int ch = 0; ch < 3; ch++)
                    endPoints[ep][ch] = unquantizedEndPoints[ep][ch];

            QuantizeTo565(endPoints[0]);
            QuantizeTo565(endPoints[1]);

            IndexSelector<3> selector;
            selector.Init(channelWeights, endPoints, range);

            MInt16 indexes[16];

            MFloat error = ParallelMath::MakeFloatZero();
            for (int px = 0; px < 16; px++)
            {
                MInt16 index = selector.SelectIndex(pixels[px]);
                indexes[px] = index;

                MFloat weight = ParallelMath::MakeFloat(1.0f);

                if (refiner)
                    refiner->Contribute(pixels[px], index, weight);

                MInt16 reconstructed[3];
                selector.Reconstruct(index, reconstructed);

                error = error + BCCommon::ComputeError<3>(flags, reconstructed, pixels[px], channelWeights);
            }

            ParallelMath::FloatCompFlag better = ParallelMath::Less(error, bestError);

            if (ParallelMath::AnySet(better))
            {
                ParallelMath::Int16CompFlag betterInt16 = ParallelMath::FloatFlagToInt16(better);

                ParallelMath::ConditionalSet(bestError, better, error);

                for (int ep = 0; ep < 2; ep++)
                    for (int ch = 0; ch < 3; ch++)
                        ParallelMath::ConditionalSet(bestEndpoints[ep][ch], betterInt16, endPoints[ep][ch]);

                for (int px = 0; px < 16; px++)
                    ParallelMath::ConditionalSet(bestIndexes[px], betterInt16, indexes[px]);

                ParallelMath::ConditionalSet(bestRange, betterInt16, ParallelMath::MakeUInt16(range));
            }
        }

        static void TestCounts(DWORD flags, const int *counts, int nCounts, MInt16 numElements, const MInt16 pixels[16][4], bool alphaTest,
            MInt16 sortedInputs[16][4], const float *channelWeights, MFloat &bestError, MInt16 bestEndpoints[2][3], MInt16 bestIndexes[16], MInt16 &bestRange)
        {
            EndpointRefiner<3> refiner;

            refiner.Init(nCounts, channelWeights);

            bool escape = false;
            int e = 0;
            for (int i = 0; i < nCounts; i++)
            {
                for (int n = 0; n < counts[i]; n++)
                {
                    ParallelMath::Int16CompFlag valid = ParallelMath::Less(ParallelMath::MakeUInt16(n), numElements);
                    if (!ParallelMath::AnySet(valid))
                    {
                        escape = true;
                        break;
                    }

                    MFloat weight = ParallelMath::Select(ParallelMath::Int16FlagToFloat(valid), ParallelMath::MakeFloat(1.0f), ParallelMath::MakeFloat(0.0f));
                    refiner.Contribute(sortedInputs[e++], ParallelMath::MakeUInt16(i), weight);
                }

                if (escape)
                    break;
            }

            MInt16 endPoints[2][3];
            refiner.GetRefinedEndpoints(endPoints);

            TestEndpoints(flags, pixels, endPoints, nCounts, channelWeights, bestError, bestEndpoints, bestIndexes, bestRange, nullptr);
        }

        static void PackExplicitAlpha(DWORD flags, const InputBlock* inputs, int inputChannel, uint8_t* packedBlocks, size_t packedBlockStride)
        {
            float weights[1] = { 1.0f };

            MInt16 pixels[16];
            MFloat floatPixels[16];

            for (int px = 0; px < 16; px++)
            {
                MInt32 packedPx;
                ParallelMath::ReadPackedInputs(inputs, px, packedPx);

                ParallelMath::UnpackChannel(packedPx, inputChannel, pixels[px]);
                floatPixels[px] = ParallelMath::UInt16ToFloat(pixels[px]);
            }

            MInt16 ep[2][1] = { { ParallelMath::MakeUInt16(0) }, { ParallelMath::MakeUInt16(255) } };

            IndexSelector<1> selector;
            selector.Init(weights, ep, 16);

            MInt16 indexes[16];

            for (int px = 0; px < 16; px++)
                indexes[px] = selector.SelectIndex(&pixels[px]);

            for (int block = 0; block < ParallelMath::ParallelSize; block++)
            {
                for (int px = 0; px < 16; px += 8)
                {
                    int index0 = ParallelMath::ExtractUInt16(indexes[px], block);
                    int index1 = ParallelMath::ExtractUInt16(indexes[px], block);

                    packedBlocks[px / 2] = static_cast<uint8_t>(index0 | (index1 << 4));
                }

                packedBlocks += packedBlockStride;
            }
        }

        static void PackInterpolatedAlpha(DWORD flags, const InputBlock* inputs, int inputChannel, uint8_t* packedBlocks, size_t packedBlockStride, bool isSigned)
        {
            float weights[1] = { 1.0f };

            MInt16 pixels[16];
            MFloat floatPixels[16];

            MInt16 highTerminal = isSigned ? ParallelMath::MakeUInt16(254) : ParallelMath::MakeUInt16(255);
            MInt16 highTerminalMinusOne = highTerminal - ParallelMath::MakeUInt16(1);

            for (int px = 0; px < 16; px++)
            {
                MInt32 packedPx;
                ParallelMath::ReadPackedInputs(inputs, px, packedPx);

                ParallelMath::UnpackChannel(packedPx, inputChannel, pixels[px]);

                if (isSigned)
                    pixels[px] = ParallelMath::Min(pixels[px], highTerminal);

                floatPixels[px] = ParallelMath::UInt16ToFloat(pixels[px]);
            }

            MInt16 sortedPixels[16];
            for (int px = 0; px < 16; px++)
                sortedPixels[px] = pixels[px];

            for (int sortEnd = 15; sortEnd > 0; sortEnd--)
            {
                for (int sortOffset = 0; sortOffset < sortEnd; sortOffset++)
                {
                    MInt16 a = sortedPixels[sortOffset];
                    MInt16 b = sortedPixels[sortOffset + 1];

                    sortedPixels[sortOffset] = ParallelMath::Min(a, b);
                    sortedPixels[sortOffset + 1] = ParallelMath::Max(a, b);
                }
            }

            MInt16 zero = ParallelMath::MakeUInt16(0);
            MInt16 one = ParallelMath::MakeUInt16(1);

            MInt16 bestIsFullRange = zero;
            MFloat bestError = ParallelMath::MakeFloat(FLT_MAX);
            MInt16 bestEP[2] = { zero, zero };
            MInt16 bestIndexes[16] = {
                zero, zero, zero, zero,
                zero, zero, zero, zero,
                zero, zero, zero, zero,
                zero, zero, zero, zero
            };

            // Full-precision
            {
                MInt16 minEP = sortedPixels[0];
                MInt16 maxEP = sortedPixels[15];

                MFloat base[1] = { ParallelMath::UInt16ToFloat(minEP) };
                MFloat offset[1] = { ParallelMath::UInt16ToFloat(maxEP - minEP) };

                UnfinishedEndpoints<1> ufep = UnfinishedEndpoints<1>(base, offset);

                for (int tweak = 0; tweak < BCCommon::TweakRoundsForRange(8); tweak++)
                {
                    MInt16 ep[2][1];

                    ufep.Finish(tweak, 8, ep[0], ep[1]);

                    if (isSigned)
                        for (int epi = 0; epi < 2; epi++)
                            ep[epi][0] = ParallelMath::Min(ep[epi][0], highTerminal);

                    EndpointRefiner<1> refiner;
                    refiner.Init(8, weights);

                    for (int refinePass = 0; refinePass < NumAlphaRefineRounds; refinePass++)
                    {
                        IndexSelector<1> indexSelector;
                        indexSelector.Init(weights, ep, 8);

                        MInt16 indexes[16];
                        MFloat error = ParallelMath::MakeFloatZero();

                        for (int px = 0; px < 16; px++)
                        {
                            MInt16 index = indexSelector.SelectIndex(&pixels[px]);

                            MInt16 reconstructedPixel;

                            indexSelector.Reconstruct(index, &reconstructedPixel);
                            error = error + BCCommon::ComputeError<1>(flags, &reconstructedPixel, &pixels[px], weights);

                            refiner.Contribute(&pixels[px], index, ParallelMath::MakeFloat(1.0f));

                            indexes[px] = index;
                        }

                        ParallelMath::FloatCompFlag errorBetter = ParallelMath::Less(error, bestError);
                        ParallelMath::Int16CompFlag errorBetter16 = ParallelMath::FloatFlagToInt16(errorBetter);

                        if (ParallelMath::AnySet(errorBetter16))
                        {
                            bestError = ParallelMath::Min(error, bestError);
                            ParallelMath::ConditionalSet(bestIsFullRange, errorBetter16, one);
                            for (int px = 0; px < 16; px++)
                                ParallelMath::ConditionalSet(bestIndexes[px], errorBetter16, indexes[px]);

                            for (int epi = 0; epi < 2; epi++)
                                ParallelMath::ConditionalSet(bestEP[epi], errorBetter16, ep[epi][0]);
                        }

                        if (refinePass != NumAlphaRefineRounds - 1)
                            refiner.GetRefinedEndpoints(ep);
                    }
                }
            }

            // Reduced precision with special endpoints
            {
                MInt16 mostAnchoredIndexes = ParallelMath::MakeUInt16(0);
                MInt16 bestHeuristicMin = sortedPixels[0];
                MInt16 bestHeuristicMax = sortedPixels[15];

                ParallelMath::Int16CompFlag canTryClipping;

                // In reduced precision, we want try putting endpoints at the reserved indexes at the ends.
                // The heuristic we use is to assign indexes to the end as long as they aren't off by more than half of the index range.
                // This will usually not find anything, but it's cheap to check.

                {
                    MInt16 largestPossibleRange = bestHeuristicMax - bestHeuristicMin;
                    MInt16 lowestPossibleClearance = ParallelMath::Min(bestHeuristicMin, static_cast<MInt16>(highTerminal - bestHeuristicMax));

                    MInt16 lowestPossibleClearanceTimes10 = (lowestPossibleClearance << 2) + (lowestPossibleClearance << 4);
                    canTryClipping = ParallelMath::LessOrEqual(lowestPossibleClearanceTimes10, largestPossibleRange);
                }

                if (ParallelMath::AnySet(canTryClipping))
                {
                    MInt16 lowClearances[16];
                    MInt16 highClearances[16];
                    MInt16 bestSkipCount = ParallelMath::MakeUInt16(0);

                    lowClearances[0] = highClearances[0] = ParallelMath::MakeUInt16(0);

                    for (int px = 1; px < 16; px++)
                    {
                        lowClearances[px] = sortedPixels[px - 1];
                        highClearances[px] = highTerminal - sortedPixels[16 - px];
                    }

                    for (uint16_t firstIndex = 0; firstIndex < 16; firstIndex++)
                    {
                        uint16_t numSkippedLow = firstIndex;

                        MInt16 lowClearance = lowClearances[firstIndex];
                        MInt16 hMin = sortedPixels[firstIndex];

                        for (uint16_t lastIndex = firstIndex; lastIndex < 16; lastIndex++)
                        {
                            uint16_t numSkippedHigh = 15 - lastIndex;
                            uint16_t numSkipped = numSkippedLow + numSkippedHigh;

                            MInt16 numSkippedV = ParallelMath::MakeUInt16(numSkipped);

                            ParallelMath::Int16CompFlag areMoreSkipped = ParallelMath::Less(bestSkipCount, numSkippedV);

                            if (!ParallelMath::AnySet(areMoreSkipped))
                                continue;

                            MInt16 clearance = ParallelMath::Max(highClearances[numSkippedHigh], lowClearance);
                            MInt16 clearanceTimes10 = (clearance << 2) + (clearance << 4);

                            MInt16 range = sortedPixels[lastIndex] - sortedPixels[firstIndex];

                            ParallelMath::Int16CompFlag isBetter = (areMoreSkipped & ParallelMath::LessOrEqual(clearanceTimes10, range));
                            ParallelMath::ConditionalSet(bestHeuristicMin, isBetter, sortedPixels[firstIndex]);
                            ParallelMath::ConditionalSet(bestHeuristicMax, isBetter, sortedPixels[lastIndex]);
                        }
                    }
                }

                MInt16 bestSimpleMin = one;
                MInt16 bestSimpleMax = highTerminalMinusOne;

                for (int px = 0; px < 16; px++)
                {
                    ParallelMath::ConditionalSet(bestSimpleMin, ParallelMath::Less(zero, sortedPixels[15 - px]), sortedPixels[15 - px]);
                    ParallelMath::ConditionalSet(bestSimpleMax, ParallelMath::Less(sortedPixels[px], highTerminal), sortedPixels[px]);
                }

                MInt16 minEPs[2] = { bestSimpleMin, bestHeuristicMin };
                MInt16 maxEPs[2] = { bestSimpleMax, bestHeuristicMax };

                int minEPRange = 2;
                if (ParallelMath::AllSet(ParallelMath::Equal(minEPs[0], minEPs[1])))
                    minEPRange = 1;

                int maxEPRange = 2;
                if (ParallelMath::AllSet(ParallelMath::Equal(maxEPs[0], maxEPs[1])))
                    maxEPRange = 1;

                for (int minEPIndex = 0; minEPIndex < minEPRange; minEPIndex++)
                {
                    for (int maxEPIndex = 0; maxEPIndex < maxEPRange; maxEPIndex++)
                    {
                        MFloat base[1] = { ParallelMath::UInt16ToFloat(minEPs[minEPIndex]) };
                        MFloat offset[1] = { ParallelMath::UInt16ToFloat(maxEPs[maxEPIndex] - minEPs[minEPIndex]) };

                        UnfinishedEndpoints<1> ufep = UnfinishedEndpoints<1>(base, offset);

                        EndpointRefiner<1> refiner;
                        refiner.Init(8, weights);

                        for (int tweak = 0; tweak < BCCommon::TweakRoundsForRange(6); tweak++)
                        {
                            MInt16 ep[2][1];

                            ufep.Finish(tweak, 8, ep[0], ep[1]);

                            for (int refinePass = 0; refinePass < NumAlphaRefineRounds; refinePass++)
                            {
                                EndpointRefiner<1> refiner;

                                refiner.Init(6, weights);

                                if (isSigned)
                                    for (int epi = 0; epi < 2; epi++)
                                        ep[epi][0] = ParallelMath::Min(ep[epi][0], highTerminal);

                                IndexSelector<1> indexSelector;
                                indexSelector.Init(weights, ep, 6);

                                MInt16 indexes[16];
                                MFloat error = ParallelMath::MakeFloatZero();

                                for (int px = 0; px < 16; px++)
                                {
                                    MInt16 selectedIndex = indexSelector.SelectIndex(&pixels[px]);

                                    MInt16 reconstructedPixel;

                                    indexSelector.Reconstruct(selectedIndex, &reconstructedPixel);

                                    MFloat zeroError = BCCommon::ComputeError<1>(flags, &zero, &pixels[px], weights);
                                    MFloat highTerminalError = BCCommon::ComputeError<1>(flags, &highTerminal, &pixels[px], weights);
                                    MFloat selectedIndexError = BCCommon::ComputeError<1>(flags, &reconstructedPixel, &pixels[px], weights);

                                    MFloat bestPixelError = zeroError;
                                    MInt16 index = ParallelMath::MakeUInt16(6);

                                    ParallelMath::ConditionalSet(index, ParallelMath::FloatFlagToInt16(ParallelMath::Less(highTerminalError, bestPixelError)), ParallelMath::MakeUInt16(7));
                                    bestPixelError = ParallelMath::Min(bestPixelError, highTerminalError);

                                    ParallelMath::FloatCompFlag selectedIndexBetter = ParallelMath::Less(selectedIndexError, bestPixelError);
                                    MFloat refineWeight = ParallelMath::Select(selectedIndexBetter, ParallelMath::MakeFloat(1.0f), ParallelMath::MakeFloatZero());

                                    refiner.Contribute(&pixels[px], selectedIndex, refineWeight);

                                    ParallelMath::ConditionalSet(index, ParallelMath::FloatFlagToInt16(selectedIndexBetter), selectedIndex);
                                    bestPixelError = ParallelMath::Min(bestPixelError, selectedIndexError);

                                    error = error + bestPixelError;

                                    indexes[px] = index;
                                }

                                ParallelMath::FloatCompFlag errorBetter = ParallelMath::Less(error, bestError);
                                ParallelMath::Int16CompFlag errorBetter16 = ParallelMath::FloatFlagToInt16(errorBetter);

                                if (ParallelMath::AnySet(errorBetter16))
                                {
                                    bestError = ParallelMath::Min(error, bestError);
                                    ParallelMath::ConditionalSet(bestIsFullRange, errorBetter16, zero);
                                    for (int px = 0; px < 16; px++)
                                        ParallelMath::ConditionalSet(bestIndexes[px], errorBetter16, indexes[px]);

                                    for (int epi = 0; epi < 2; epi++)
                                        ParallelMath::ConditionalSet(bestEP[epi], errorBetter16, ep[epi][0]);
                                }

                                if (refinePass != NumAlphaRefineRounds - 1)
                                    refiner.GetRefinedEndpoints(ep);
                            }
                        }
                    }
                }
            }

            for (int block = 0; block < ParallelMath::ParallelSize; block++)
            {
                int ep0 = ParallelMath::ExtractUInt16(bestEP[0], block);
                int ep1 = ParallelMath::ExtractUInt16(bestEP[1], block);
                int isFullRange = ParallelMath::ExtractUInt16(bestIsFullRange, block);

                if (isSigned)
                {
                    ep0 -= 127;
                    ep1 -= 127;

                    assert(ep0 >= -127 && ep0 <= 127);
                    assert(ep1 >= -127 && ep1 <= 127);
                }


                bool swapEndpoints = (isFullRange != 0) != (ep0 > ep1);

                if (swapEndpoints)
                    std::swap(ep0, ep1);

                uint16_t dumpBits = 0;
                int dumpBitsOffset = 0;
                int dumpByteOffset = 2;
                packedBlocks[0] = static_cast<uint8_t>(ep0 & 0xff);
                packedBlocks[1] = static_cast<uint8_t>(ep1 & 0xff);

                int maxValue = (isFullRange != 0) ? 7 : 5;

                for (int px = 0; px < 16; px++)
                {
                    int index = ParallelMath::ExtractUInt16(bestIndexes[px], block);

                    if (swapEndpoints && index <= maxValue)
                        index = maxValue - index;

                    if (index != 0)
                    {
                        if (index == maxValue)
                            index = 1;
                        else if (index < maxValue)
                            index++;
                    }

                    assert(index >= 0 && index < 8);

                    dumpBits |= static_cast<uint16_t>(index << dumpBitsOffset);
                    dumpBitsOffset += 3;

                    if (dumpBitsOffset >= 8)
                    {
                        assert(dumpByteOffset < 8);
                        packedBlocks[dumpByteOffset] = static_cast<uint8_t>(dumpBits & 0xff);
                        dumpBits >>= 8;
                        dumpBitsOffset -= 8;
                        dumpByteOffset++;
                    }
                }

                assert(dumpBitsOffset == 0);
                assert(dumpByteOffset == 8);

                packedBlocks += packedBlockStride;
            }
        }

        static void PackRGB(DWORD flags, const InputBlock* inputs, uint8_t* packedBlocks, size_t packedBlockStride, const float channelWeights[4], bool alphaTest, float alphaThreshold, bool exhaustive)
        {
            EndpointSelector<3, 8> endpointSelector;

            MInt16 pixels[16][4];

            MFloat preWeightedPixels[16][4];

            for (int px = 0; px < 16; px++)
            {
                MInt32 packedPx;
                ParallelMath::ReadPackedInputs(inputs, px, packedPx);

                for (int ch = 0; ch < 4; ch++)
                    ParallelMath::UnpackChannel(packedPx, ch, pixels[px][ch]);
            }

            if (alphaTest)
            {
                MInt16 threshold = ParallelMath::MakeUInt16(static_cast<uint16_t>(floorf(alphaThreshold * 255.0f + 0.5f)));

                for (int px = 0; px < 16; px++)
                {
                    ParallelMath::Int16CompFlag belowThreshold = ParallelMath::Less(pixels[px][3], threshold);
                    pixels[px][3] = ParallelMath::Select(belowThreshold, ParallelMath::MakeUInt16(0), ParallelMath::MakeUInt16(255));
                }
            }

            BCCommon::PreWeightPixels<4>(preWeightedPixels, pixels, channelWeights);

            MInt16 minAlpha = ParallelMath::MakeUInt16(255);

            for (int px = 0; px < 16; px++)
                minAlpha = ParallelMath::Min(minAlpha, pixels[px][3]);

            MFloat pixelWeights[16];
            for (int px = 0; px < 16; px++)
            {
                pixelWeights[px] = ParallelMath::MakeFloat(1.0f);
                if (alphaTest)
                {
                    ParallelMath::Int16CompFlag isTransparent = ParallelMath::Less(pixels[px][3], ParallelMath::MakeUInt16(255));

                    ParallelMath::ConditionalSet(pixelWeights[px], ParallelMath::Int16FlagToFloat(isTransparent), ParallelMath::MakeFloatZero());
                }
            }

            for (int pass = 0; pass < NumEndpointSelectorPasses; pass++)
            {
                for (int px = 0; px < 16; px++)
                    endpointSelector.ContributePass(preWeightedPixels[px], pass, pixelWeights[px]);

                endpointSelector.FinishPass(pass);
            }

            UnfinishedEndpoints<3> ufep = endpointSelector.GetEndpoints(channelWeights);

            MInt16 bestEndpoints[2][3];
            MInt16 bestIndexes[16];
            MInt16 bestRange = ParallelMath::MakeUInt16(0);
            MFloat bestError = ParallelMath::MakeFloat(FLT_MAX);

            for (int px = 0; px < 16; px++)
                bestIndexes[px] = ParallelMath::MakeUInt16(0);

            for (int ep = 0; ep < 2; ep++)
                for (int ch = 0; ch < 3; ch++)
                    bestEndpoints[ep][ch] = ParallelMath::MakeUInt16(0);

            if (exhaustive)
            {
                MInt16 sortBins[16];

                {
                    // Compute an 11-bit index, change it to signed, stuff it in the high bits of the sort bins,
                    // and pack the original indexes into the low bits.

                    MInt16 sortEP[2][3];
                    ufep.Finish(0, 11, sortEP[0], sortEP[1]);

                    IndexSelector<3> sortSelector;
                    sortSelector.Init(channelWeights, sortEP, 1 << 11);

                    for (int px = 0; px < 16; px++)
                    {
                        MInt16 sortBin = (sortSelector.SelectIndex(pixels[px]) << 4);

                        if (alphaTest)
                        {
                            ParallelMath::Int16CompFlag isTransparent = ParallelMath::Less(pixels[px][3], ParallelMath::MakeUInt16(255));

                            ParallelMath::ConditionalSet(sortBin, isTransparent, ParallelMath::MakeUInt16(-16));
                        }

                        sortBin = sortBin + ParallelMath::MakeUInt16(px);

                        sortBins[px] = sortBin;
                    }
                }

                // Sort bins
                for (int sortEnd = 1; sortEnd < 16; sortEnd++)
                {
                    for (int sortLoc = sortEnd; sortLoc > 0; sortLoc--)
                    {
                        MInt16 a = sortBins[sortLoc];
                        MInt16 b = sortBins[sortLoc - 1];

                        sortBins[sortLoc] = ParallelMath::Max(a, b);
                        sortBins[sortLoc - 1] = ParallelMath::Min(a, b);
                    }
                }

                MInt16 firstElement = ParallelMath::MakeUInt16(0);
                for (uint16_t e = 0; e < 16; e++)
                {
                    ParallelMath::Int16CompFlag isInvalid = ParallelMath::Less(sortBins[e], ParallelMath::MakeUInt16(0));
                    ParallelMath::ConditionalSet(firstElement, isInvalid, ParallelMath::MakeUInt16(e + 1));
                    if (!ParallelMath::AnySet(isInvalid))
                        break;
                }

                MInt16 numElements = ParallelMath::MakeUInt16(16) - firstElement;

                MInt16 sortedInputs[16][4];

                for (int e = 0; e < 16; e++)
                {
                    for (int ch = 0; ch < 4; ch++)
                        sortedInputs[e][ch] = ParallelMath::MakeUInt16(0);
                }

                for (int block = 0; block < ParallelMath::ParallelSize; block++)
                {
                    for (int e = ParallelMath::ExtractUInt16(firstElement, block); e < 16; e++)
                    {
                        uint16_t sortBin = ParallelMath::ExtractUInt16(sortBins[e], block);
                        int originalIndex = (sortBin & 15);

                        for (int ch = 0; ch < 4; ch++)
                            ParallelMath::PutUInt16(sortedInputs[15 - e][ch], block, ParallelMath::ExtractUInt16(pixels[originalIndex][ch], block));
                    }
                }

                for (int n0 = 0; n0 <= 15; n0++)
                {
                    int remainingFor1 = 16 - n0;

                    for (int n1 = 0; n1 <= remainingFor1; n1++)
                    {
                        int remainingFor2 = 16 - n1 - n0;

                        for (int n2 = 0; n2 <= remainingFor2; n2++)
                        {
                            int n3 = 16 - n2 - n1 - n0;

                            int counts[4] = { n0, n1, n2, n3 };

                            TestCounts(flags, counts, 4, numElements, pixels, alphaTest, sortedInputs, channelWeights, bestError, bestEndpoints, bestIndexes, bestRange);
                        }
                    }
                }

                if (alphaTest)
                {
                    for (int n0 = 0; n0 <= 15; n0++)
                    {
                        int remainingFor1 = 16 - n0;

                        for (int n1 = 0; n1 <= remainingFor1; n1++)
                        {
                            int remainingFor2 = 16 - n1 - n0;

                            int n2 = 16 - n1 - n0;

                            int counts[3] = { n0, n1, n2 };

                            TestCounts(flags, counts, 3, numElements, pixels, alphaTest, sortedInputs, channelWeights, bestError, bestEndpoints, bestIndexes, bestRange);
                        }
                    }
                }
            }
            else
            {
                int minRange = alphaTest ? 3 : 4;

                for (int range = minRange; range <= 4; range++)
                {
                    int tweakRounds = BCCommon::TweakRoundsForRange(range);
                    for (int tweak = 0; tweak < tweakRounds; tweak++)
                    {
                        MInt16 endPoints[2][3];

                        ufep.Finish(tweak, range, endPoints[0], endPoints[1]);

                        for (int refine = 0; refine < NumRGBRefineRounds; refine++)
                        {
                            EndpointRefiner<3> refiner;
                            refiner.Init(range, channelWeights);

                            TestEndpoints(flags, pixels, endPoints, range, channelWeights, bestError, bestEndpoints, bestIndexes, bestRange, &refiner);

                            if (refine != NumRGBRefineRounds - 1)
                                refiner.GetRefinedEndpoints(endPoints);
                        }
                    }
                }
            }

            for (int block = 0; block < ParallelMath::ParallelSize; block++)
            {
                uint16_t range = ParallelMath::ExtractUInt16(bestRange, block);
                assert(range == 3 || range == 4);

                uint16_t compressedEP[2];
                for (int ep = 0; ep < 2; ep++)
                {
                    uint16_t endPoint[3];
                    for (int ch = 0; ch < 3; ch++)
                        endPoint[ch] = ParallelMath::ExtractUInt16(bestEndpoints[ep][ch], block);

                    int compressed = (endPoint[0] & 0xf8) << 8;
                    compressed |= (endPoint[1] & 0xfc) << 3;
                    compressed |= (endPoint[2] & 0xf8) >> 3;

                    compressedEP[ep] = static_cast<uint16_t>(compressed);
                }

                int indexOrder[4];
                bool flipIndexes = false;

                if (range == 4)
                {
                    if (compressedEP[0] <= compressedEP[1])
                    {
                        std::swap(compressedEP[0], compressedEP[1]);
                        indexOrder[0] = 1;
                        indexOrder[1] = 3;
                        indexOrder[2] = 2;
                        indexOrder[3] = 0;
                    }
                    else
                    {
                        indexOrder[0] = 0;
                        indexOrder[1] = 2;
                        indexOrder[2] = 3;
                        indexOrder[3] = 1;
                    }
                }
                else
                {
                    assert(range == 3);

                    if (compressedEP[0] > compressedEP[1])
                    {
                        std::swap(compressedEP[0], compressedEP[1]);
                        indexOrder[0] = 1;
                        indexOrder[1] = 2;
                        indexOrder[2] = 0;
                    }
                    else
                    {
                        indexOrder[0] = 0;
                        indexOrder[1] = 2;
                        indexOrder[2] = 1;
                    }
                    indexOrder[3] = 3;
                }

                packedBlocks[0] = static_cast<uint8_t>(compressedEP[0] & 0xff);
                packedBlocks[1] = static_cast<uint8_t>((compressedEP[0] >> 8) & 0xff);
                packedBlocks[2] = static_cast<uint8_t>(compressedEP[1] & 0xff);
                packedBlocks[3] = static_cast<uint8_t>((compressedEP[1] >> 8) & 0xff);

                for (int i = 0; i < 16; i += 4)
                {
                    int packedIndexes = 0;
                    for (int subi = 0; subi < 4; subi++)
                    {
                        uint16_t index = ParallelMath::ExtractUInt16(bestIndexes[i + subi], block);
                        packedIndexes |= (indexOrder[index] << (subi * 2));
                    }

                    packedBlocks[4 + i / 4] = static_cast<uint8_t>(packedIndexes);
                }

                packedBlocks += packedBlockStride;
            }
        }
    };
}

static void PrepareInputBlock(InputBlock inputBlocks[NUM_PARALLEL_BLOCKS], const XMVECTOR *&pColor, DWORD flags)
{
    for (size_t block = 0; block < ParallelMath::ParallelSize; block++)
    {
        InputBlock& inputBlock = inputBlocks[block];

        for (size_t i = 0; i < NUM_PIXELS_PER_BLOCK; ++i)
        {
            int32_t packedPixel = 0;
            for (size_t ch = 0; ch < 4; ch++)
            {
                int32_t convertedValue = static_cast<int32_t>(std::floorf(std::max<float>(0.0f, std::min<float>(255.0f, XMVectorGetByIndex(*pColor, ch) * 255.0f + 0.5f))));
                packedPixel |= (convertedValue << (ch * 8));
            }

            inputBlock.m_pixels[i] = packedPixel;
            pColor++;
        }
    }
}

// Signed input blocks are converted into unsigned space, with the maximum value being 254
static void PrepareSignedInputBlock(InputBlock inputBlocks[NUM_PARALLEL_BLOCKS], const XMVECTOR *&pColor, DWORD flags)
{
    for (size_t block = 0; block < ParallelMath::ParallelSize; block++)
    {
        InputBlock& inputBlock = inputBlocks[block];

        for (size_t i = 0; i < NUM_PIXELS_PER_BLOCK; ++i)
        {
            int32_t packedPixel = 0;
            for (size_t ch = 0; ch < 4; ch++)
            {
                int32_t convertedValue = static_cast<int32_t>(std::floorf(std::max<float>(0.0f, std::min<float>(254.0f, XMVectorGetByIndex(*pColor, ch) * 127.0f + 127.5f))));
                packedPixel |= (convertedValue << (ch * 8));
            }

            inputBlock.m_pixels[i] = packedPixel;
            pColor++;
        }
    }
}

_Use_decl_annotations_
void DirectX::D3DXEncodeBC7Parallel(uint8_t *pBC, const XMVECTOR *pColor, DWORD flags)
{
    assert(pColor);
    assert(pBC);

    for (size_t blockBase = 0; blockBase < NUM_PARALLEL_BLOCKS; blockBase += ParallelMath::ParallelSize)
    {
        InputBlock inputBlocks[NUM_PARALLEL_BLOCKS];

        PrepareInputBlock(inputBlocks, pColor, flags);

        const float perceptualWeights[4] = { 0.2125f / 0.7154f, 1.0f, 0.0721f / 0.7154f, 1.0f };
        const float uniformWeights[4] = { 1.0f, 1.0f, 1.0f, 1.0f };

        BC7Computer::Pack(flags, inputBlocks, pBC, (flags & BC_FLAGS_UNIFORM) ? uniformWeights : perceptualWeights);

        pBC += ParallelMath::ParallelSize * 16;
    }
}

_Use_decl_annotations_
void DirectX::D3DXEncodeBC1Parallel(uint8_t *pBC, const XMVECTOR *pColor, _In_ float threshold, DWORD flags)
{
    assert(pColor);
    assert(pBC);

    if (!(flags & TEX_COMPRESS_HIGH_QUALITY))
    {
        for (size_t i = 0; i < NUM_PARALLEL_BLOCKS; i++)
            DirectX::D3DXEncodeBC1(pBC + i * 8, pColor + i * 16, threshold, flags);

        return;
    }

    for (size_t blockBase = 0; blockBase < NUM_PARALLEL_BLOCKS; blockBase += ParallelMath::ParallelSize)
    {
        InputBlock inputBlocks[NUM_PARALLEL_BLOCKS];

        PrepareInputBlock(inputBlocks, pColor, flags);

        const float perceptualWeights[4] = { 0.2125f / 0.7154f, 1.0f, 0.0721f / 0.7154f, 1.0f };
        const float uniformWeights[4] = { 1.0f, 1.0f, 1.0f, 1.0f };

        S3TCComputer::PackRGB(flags, inputBlocks, pBC, 8, (flags & BC_FLAGS_UNIFORM) ? uniformWeights : perceptualWeights, true, threshold, true);

        pBC += ParallelMath::ParallelSize * 8;
    }
}

_Use_decl_annotations_
void DirectX::D3DXEncodeBC2Parallel(uint8_t *pBC, const XMVECTOR *pColor, DWORD flags)
{
    assert(pColor);
    assert(pBC);

    if (!(flags & TEX_COMPRESS_HIGH_QUALITY))
    {
        for (size_t i = 0; i < NUM_PARALLEL_BLOCKS; i++)
            DirectX::D3DXEncodeBC2(pBC + i * 16, pColor + i * 16, flags);

        return;
    }

    for (size_t blockBase = 0; blockBase < NUM_PARALLEL_BLOCKS; blockBase += ParallelMath::ParallelSize)
    {
        InputBlock inputBlocks[NUM_PARALLEL_BLOCKS];

        PrepareInputBlock(inputBlocks, pColor, flags);

        const float perceptualWeights[4] = { 0.2125f / 0.7154f, 1.0f, 0.0721f / 0.7154f, 1.0f };
        const float uniformWeights[4] = { 1.0f, 1.0f, 1.0f, 1.0f };

        S3TCComputer::PackRGB(flags, inputBlocks, pBC + 8, 16, (flags & BC_FLAGS_UNIFORM) ? uniformWeights : perceptualWeights, false, 1.0f, true);
        S3TCComputer::PackExplicitAlpha(flags, inputBlocks, 3, pBC, 16);

        pBC += ParallelMath::ParallelSize * 16;
    }
}

_Use_decl_annotations_
void DirectX::D3DXEncodeBC3Parallel(uint8_t *pBC, const XMVECTOR *pColor, DWORD flags)
{
    assert(pColor);
    assert(pBC);

    if (!(flags & TEX_COMPRESS_HIGH_QUALITY))
    {
        for (size_t i = 0; i < NUM_PARALLEL_BLOCKS; i++)
            DirectX::D3DXEncodeBC3(pBC + i * 16, pColor + i * 16, flags);

        return;
    }

    for (size_t blockBase = 0; blockBase < NUM_PARALLEL_BLOCKS; blockBase += ParallelMath::ParallelSize)
    {
        InputBlock inputBlocks[NUM_PARALLEL_BLOCKS];

        PrepareInputBlock(inputBlocks, pColor, flags);

        const float perceptualWeights[4] = { 0.2125f / 0.7154f, 1.0f, 0.0721f / 0.7154f, 1.0f };
        const float uniformWeights[4] = { 1.0f, 1.0f, 1.0f, 1.0f };

        S3TCComputer::PackRGB(flags, inputBlocks, pBC + 8, 16, (flags & BC_FLAGS_UNIFORM) ? uniformWeights : perceptualWeights, false, 1.0f, true);
        S3TCComputer::PackInterpolatedAlpha(flags, inputBlocks, 3, pBC, 16, false);

        pBC += ParallelMath::ParallelSize * 16;
    }
}

void DirectX::D3DXEncodeBC4UParallel(uint8_t *pBC, const XMVECTOR *pColor, DWORD flags)
{
    assert(pColor);
    assert(pBC);

    if (!(flags & TEX_COMPRESS_HIGH_QUALITY))
    {
        for (size_t i = 0; i < NUM_PARALLEL_BLOCKS; i++)
            DirectX::D3DXEncodeBC4U(pBC + i * 8, pColor + i * 16, flags);

        return;
    }

    for (size_t blockBase = 0; blockBase < NUM_PARALLEL_BLOCKS; blockBase += ParallelMath::ParallelSize)
    {
        InputBlock inputBlocks[NUM_PARALLEL_BLOCKS];

        PrepareInputBlock(inputBlocks, pColor, flags);

        S3TCComputer::PackInterpolatedAlpha(flags, inputBlocks, 0, pBC, 8, false);

        pBC += ParallelMath::ParallelSize * 8;
    }
}

void DirectX::D3DXEncodeBC4SParallel(uint8_t *pBC, const XMVECTOR *pColor, DWORD flags)
{
    assert(pColor);
    assert(pBC);

    if (!(flags & TEX_COMPRESS_HIGH_QUALITY))
    {
        for (size_t i = 0; i < NUM_PARALLEL_BLOCKS; i++)
            DirectX::D3DXEncodeBC4S(pBC + i * 8, pColor + i * 16, flags);

        return;
    }

    for (size_t blockBase = 0; blockBase < NUM_PARALLEL_BLOCKS; blockBase += ParallelMath::ParallelSize)
    {
        InputBlock inputBlocks[NUM_PARALLEL_BLOCKS];

        PrepareSignedInputBlock(inputBlocks, pColor, flags);

        S3TCComputer::PackInterpolatedAlpha(flags, inputBlocks, 0, pBC, 8, true);

        pBC += ParallelMath::ParallelSize * 8;
    }
}

void DirectX::D3DXEncodeBC5UParallel(uint8_t *pBC, const XMVECTOR *pColor, DWORD flags)
{
    assert(pColor);
    assert(pBC);

    if (!(flags & TEX_COMPRESS_HIGH_QUALITY))
    {
        for (size_t i = 0; i < NUM_PARALLEL_BLOCKS; i++)
            DirectX::D3DXEncodeBC5U(pBC + i * 16, pColor + i * 16, flags);

        return;
    }

    for (size_t blockBase = 0; blockBase < NUM_PARALLEL_BLOCKS; blockBase += ParallelMath::ParallelSize)
    {
        InputBlock inputBlocks[NUM_PARALLEL_BLOCKS];

        PrepareInputBlock(inputBlocks, pColor, flags);

        S3TCComputer::PackInterpolatedAlpha(flags, inputBlocks, 0, pBC, 16, false);
        S3TCComputer::PackInterpolatedAlpha(flags, inputBlocks, 1, pBC + 8, 16, false);

        pBC += ParallelMath::ParallelSize * 16;
    }
}


void DirectX::D3DXEncodeBC5SParallel(uint8_t *pBC, const XMVECTOR *pColor, DWORD flags)
{
    assert(pColor);
    assert(pBC);

    if (!(flags & TEX_COMPRESS_HIGH_QUALITY))
    {
        for (size_t i = 0; i < NUM_PARALLEL_BLOCKS; i++)
            DirectX::D3DXEncodeBC5S(pBC + i * 16, pColor + i * 16, flags);

        return;
    }

    for (size_t blockBase = 0; blockBase < NUM_PARALLEL_BLOCKS; blockBase += ParallelMath::ParallelSize)
    {
        InputBlock inputBlocks[NUM_PARALLEL_BLOCKS];

        PrepareSignedInputBlock(inputBlocks, pColor, flags);

        S3TCComputer::PackInterpolatedAlpha(flags, inputBlocks, 0, pBC, 16, true);
        S3TCComputer::PackInterpolatedAlpha(flags, inputBlocks, 1, pBC + 8, 16, true);

        pBC += ParallelMath::ParallelSize * 16;
    }
}
